{"version":3,"sources":["Constants.ts","Lib/Lib.ts","CellComponent/Cell.tsx","Row/Row.tsx","Grid/Grid.tsx","index.tsx"],"names":["GridRows","GridColumns","PlayerStartPosition","x","y","StartingSnakeLength","getActorColor","actor","getRandomGridCoordinates","Math","ceil","random","Cell","props","cellStyle","backgroundColor","width","height","left","row","top","column","position","style","Row","actors","map","color","index","key","Grid","gameTickTimer","direction","playerCoordinates","playerStartPositions","i","lastPosition","push","getPlayerStartPositions","fruitCoordinates","gridActors","grid","rowActors","getInitialGrid","forEach","coord","state","snakeLength","gameLost","onKeyUp","bind","gameTick","this","document","addEventListener","window","setInterval","removeEventListener","clearInterval","newPlayerCoordinate","coordinate","newCoordinates","getNextCoordinate","setState","gameLostMessage","some","coords","setNewFruitPosition","pop","e","keyCode","keyCodeToDirection","currentDirection","newDirection","getOppositeDirection","toString","React","Component","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.90376c34.chunk.js","sourcesContent":["import { GridCoordinates } from \"./Models\";\r\n\r\n/**\r\n * Constants used in the game.\r\n */\r\n\r\n/**\r\n * Number of rows in the game grid\r\n */\r\nexport const GridRows = 51;\r\n\r\n/**\r\n * Number of columns in the game grid.\r\n */\r\nexport const GridColumns = 51;\r\n\r\n/**\r\n * Player start position.\r\n */\r\nexport const PlayerStartPosition: GridCoordinates = { x: 25, y: 25 };\r\n\r\n/**\r\n * The length of the snake at the start of the game.\r\n */\r\nexport const StartingSnakeLength = 3;","/**\r\n * Lib. Lots of helper functions.\r\n */\r\n\r\nimport { GridColumns, GridRows, StartingSnakeLength, PlayerStartPosition } from \"../Constants\";\r\nimport { GridCoordinates } from \"../Models\";\r\nimport { Actors, Directions } from \"../Types\";\r\n\r\n/**\r\n * Creates the initial game grid.\r\n */\r\nexport function getInitialGrid(): Actors[][] {\r\n    const grid: Actors[][] = [];\r\n\r\n    for (let row = 0; row < GridRows; row++) {\r\n        const rowActors: Actors[] = [];\r\n\r\n        for (let column = 0; column < GridColumns; column++) {\r\n            rowActors.push(\"background\");\r\n        }\r\n\r\n        grid.push(rowActors);\r\n    }\r\n\r\n    return grid;\r\n}\r\n\r\n/**\r\n * Converts an actor to a color.\r\n * @returns {string}. A color\r\n */\r\nexport function getActorColor(actor: Actors): string {\r\n    switch (actor) {\r\n        case \"background\":\r\n            return \"green\";\r\n        case \"fruit\":\r\n            return \"red\";\r\n        case \"player\":\r\n            return \"yellow\";\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a random position on the grid.\r\n */\r\nexport function getRandomGridCoordinates(): GridCoordinates {\r\n    const x = Math.ceil(Math.random() * (GridRows - 1));\r\n    const y = Math.ceil(Math.random() * (GridColumns - 1));\r\n\r\n    return {\r\n        x,\r\n        y\r\n    };\r\n}\r\n\r\n/**\r\n * Gets the grid coordinates where the player's body will be based on the initial snake length\r\n * @returns {GridCoordinates}. The player's initial grid coordinates.\r\n */\r\nexport function getPlayerStartPositions(): GridCoordinates[] {\r\n    const playerStartPositions: GridCoordinates[] = [PlayerStartPosition];\r\n    for (let i = 1; i < StartingSnakeLength; i++) {\r\n        const lastPosition = {...playerStartPositions[i - 1]};\r\n        lastPosition.y++;\r\n        playerStartPositions.push(lastPosition);\r\n    }\r\n\r\n    return playerStartPositions;\r\n}\r\n\r\n/**\r\n * Returns the direction for left, up, right, down.\r\n * @param {number} keyCode.\r\n */\r\nexport function keyCodeToDirection(keyCode: number): Directions {\r\n    switch (keyCode) {\r\n        case 37:\r\n            return \"left\";\r\n        case 38:\r\n            return \"up\";\r\n        case 39:\r\n            return \"right\";\r\n        case 40:\r\n            return \"down\";\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the next coordinate based on the passed direction\r\n * @returns {GridCoordinates}. A new grid coordinate\r\n */\r\nexport function getNextCoordinate(coordinate: GridCoordinates, direction: Directions): GridCoordinates {\r\n\r\n    const newCoordinates = { ...coordinate };\r\n\r\n    switch (direction) {\r\n        case \"left\":\r\n            newCoordinates.x--;\r\n            break;\r\n        case \"up\":\r\n            newCoordinates.y--;\r\n            break;\r\n        case \"right\":\r\n            newCoordinates.x++;\r\n            break;\r\n        case \"down\":\r\n            newCoordinates.y++;\r\n            break;\r\n    }\r\n\r\n    return newCoordinates;\r\n}\r\n\r\n/**\r\n * Returns true if the new direction is valid\r\n * @param {Directions} currentDirection. The current direction.\r\n * @param {Directions} newDirection. The new direciotn.\r\n */\r\nexport function validNewDirection(currentDirection: Directions, newDirection: Directions): boolean {\r\n    return getOppositeDirection(currentDirection) !== newDirection;\r\n}\r\n\r\n/**\r\n * Returns the oposite direction.\r\n * @param {Directions} direction. A direction.\r\n * @returns {Directions}. The oposite direction.\r\n */\r\nfunction getOppositeDirection(direction: Directions): Directions {\r\n    switch (direction) {\r\n        case \"up\":\r\n            return \"down\";\r\n        case \"down\":\r\n            return \"up\";\r\n        case \"left\":\r\n            return \"right\";\r\n        case \"right\":\r\n            return \"left\";\r\n    }\r\n}","/**\r\n * The cell component.\r\n */\r\n\r\nimport React, { CSSProperties } from \"react\";\r\nimport { getActorColor } from \"../Lib/Lib\";\r\nimport { Properties } from \"./Properties\";\r\n\r\nexport const Cell: React.FC<Properties> = (props) => {\r\n\r\n    const width  = 15;\r\n    const height = 15;\r\n\r\n    /**\r\n     * The cell style\r\n     */\r\n    const cellStyle: CSSProperties = {\r\n        backgroundColor: getActorColor(props.actor),\r\n        width: `${width}px`,\r\n        height: `${height}px`,\r\n        left: props.row * width,\r\n        top: props.column * height,\r\n        position: \"absolute\",\r\n    };\r\n\r\n    /**\r\n     * Renders the component\r\n     * @returns {ReactNode}\r\n     */\r\n    return (\r\n        <div style={cellStyle}></div>\r\n    );\r\n};","\r\n/**\r\n * Row component\r\n */\r\n\r\nimport React from \"react\";\r\nimport { Cell } from \"../CellComponent/Cell\";\r\nimport { Properties } from \"./Properties\";\r\nexport const Row: React.FC<Properties> = (props) => {\r\n\r\n    return (\r\n        <>\r\n            {\r\n                props.actors.map((color, index) => <Cell key={index} row={props.row} column={index} actor={color} />)\r\n            }\r\n        </>\r\n    );\r\n};","/**\r\n * The grid component.\r\n */\r\n\r\nimport React from \"react\";\r\nimport { GridColumns, GridRows } from \"../Constants\";\r\nimport { getInitialGrid, getNextCoordinate, getPlayerStartPositions, getRandomGridCoordinates, keyCodeToDirection, validNewDirection } from \"../Lib/Lib\";\r\nimport { GridCoordinates } from \"../Models\";\r\nimport { Row } from \"../Row/Row\";\r\nimport { Directions } from \"../Types\";\r\nimport { State } from \"./State\";\r\nimport { StartingSnakeLength } from \"../Constants\"\r\n\r\nexport class Grid extends React.Component<{}, State> {\r\n\r\n    /**\r\n     * Reference number to the interval.\r\n     */\r\n    private gameTickTimer: number | undefined;\r\n\r\n    /**\r\n     * The direction the player is traveling in.\r\n     */\r\n    private direction: Directions = \"up\";\r\n\r\n    /**\r\n     * The current player coordinates\r\n     */\r\n    private playerCoordinates: GridCoordinates[] = getPlayerStartPositions();\r\n\r\n    /**\r\n     * The coordinates of the fruit.\r\n     */\r\n    private fruitCoordinates: GridCoordinates = getRandomGridCoordinates();\r\n\r\n    /**\r\n     * Constructs the component.\r\n     */\r\n    constructor(props: object) {\r\n        super(props);\r\n\r\n        const gridActors = getInitialGrid();\r\n        this.playerCoordinates.forEach((coord) => gridActors[coord.x][coord.y] = \"player\");\r\n        gridActors[this.fruitCoordinates.x][this.fruitCoordinates.y] = \"fruit\";\r\n\r\n        this.state = {\r\n            gridActors,\r\n            snakeLength: StartingSnakeLength,\r\n            gameLost: false,\r\n        };\r\n\r\n        this.onKeyUp = this.onKeyUp.bind(this);\r\n        this.gameTick = this.gameTick.bind(this);\r\n    }\r\n\r\n    private setNewFruitPosition(): void {\r\n        this.fruitCoordinates = getRandomGridCoordinates();\r\n    }\r\n\r\n    /**\r\n     * Called after the component mounts\r\n     */\r\n    public componentDidMount(): void {\r\n        document.addEventListener(\"keyup\", this.onKeyUp);\r\n\r\n        this.gameTickTimer = window.setInterval(this.gameTick, 200);\r\n    }\r\n\r\n    /**\r\n     * Called just before the component unmounts\r\n     */\r\n    public componentWillUnmount(): void {\r\n        document.removeEventListener(\"keyup\", this.onKeyUp);\r\n\r\n        window.clearInterval(this.gameTickTimer);\r\n    }\r\n\r\n    /**\r\n     * Main game loop\r\n     */\r\n    private gameTick(): void {\r\n\r\n        if (this.state.gameLost) {\r\n            return;\r\n        }\r\n\r\n        const gridActors = [...this.state.gridActors];\r\n        this.playerCoordinates.forEach((coord) => gridActors[coord.x][coord.y] = \"background\");\r\n\r\n        const newPlayerCoordinate = getNextCoordinate(this.playerCoordinates[0], this.direction);\r\n\r\n        if (newPlayerCoordinate.x < 0 ||\r\n            newPlayerCoordinate.x >= GridColumns ||\r\n            newPlayerCoordinate.y < 0 ||\r\n            newPlayerCoordinate.y >= GridRows) {\r\n            this.setState({ gameLost: true, gameLostMessage: \"You went outside the play field.\" });\r\n            return;\r\n        }\r\n\r\n        const hitTail = this.playerCoordinates.some((coords) => coords.x === newPlayerCoordinate.x && coords.y === newPlayerCoordinate.y);\r\n        if (hitTail) {\r\n            this.setState({ gameLost: true, gameLostMessage: \"You hit your tail.\" });\r\n        }\r\n\r\n        let snakeLength = this.state.snakeLength;\r\n        if (gridActors[newPlayerCoordinate.x][newPlayerCoordinate.y] === \"fruit\") {\r\n            snakeLength++;\r\n\r\n            gridActors[this.fruitCoordinates.x][this.fruitCoordinates.y] = \"background\";\r\n            this.setNewFruitPosition();\r\n            gridActors[this.fruitCoordinates.x][this.fruitCoordinates.y] = \"fruit\";\r\n\r\n            this.playerCoordinates = [newPlayerCoordinate, ...this.playerCoordinates];\r\n\r\n        } else {\r\n            // Remove last element\r\n            this.playerCoordinates.pop();\r\n\r\n            this.playerCoordinates = [newPlayerCoordinate, ...this.playerCoordinates];\r\n        }\r\n\r\n        this.playerCoordinates.forEach((coord) => gridActors[coord.x][coord.y] = \"player\");\r\n        this.setState({ gridActors, snakeLength });\r\n    }\r\n\r\n    /**\r\n     * Handles a keypress.\r\n     * @param {KeyboardEvent } e. A keyboard event.\r\n     */\r\n    private onKeyUp(e: KeyboardEvent): void {\r\n        if (e) {\r\n            const direction = keyCodeToDirection(e.keyCode);\r\n            if (validNewDirection(direction, this.direction)) {\r\n                this.direction = direction;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the game grid.\r\n     * @returns {ReactNode}.\r\n     */\r\n    public render(): React.ReactNode {\r\n        return (\r\n            <>\r\n                {\r\n                    this.state.gameLost ?\r\n                    <>\r\n                        <p>{this.state.gameLostMessage}</p>\r\n                        <p>The length of the snake was: {this.state.snakeLength.toString()}</p>\r\n                    </>\r\n                             :\r\n\r\n                        this.state.gridActors.map((rowActors, index) => <Row key={index} row={index} actors={rowActors} />)\r\n                }\r\n            </>\r\n        );\r\n    }\r\n}","/**\n * Entry point\n */\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Grid } from \"./Grid/Grid\";\n\nReactDOM.render(<Grid />, document.getElementById(\"root\"));\n"],"sourceRoot":""}