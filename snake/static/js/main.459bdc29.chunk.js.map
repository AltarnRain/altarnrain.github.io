{"version":3,"sources":["Constants.ts","Lib/Lib.ts","Game/Game.tsx","index.tsx"],"names":["GameRows","GameColumns","PlayerStartCoordinateX","Math","ceil","PlayerStartCoordinateY","StartingSnakeLength","CellWidthAndHeight","window","screen","height","screenXOffset","innerWidth","screenYOffset","innerHeight","DebugOptions","getRandomGridCoordinates","exclude","coordinate","x","random","y","coordinateExistsInSet","coordinates","some","coords","Game","props","gameTickTimer","currentDirection","newDirection","state","getInitialState","onKeyUp","bind","gameTick","playAgain","playerCoordinates","playerStartCoordinates","i","lastCoordinate","push","getPlayerStartCoordinates","fruitCoordinate","snakeLength","gameLost","document","addEventListener","this","setInterval","removeEventListener","clearInterval","callback","direction","getOppositeDirection","undefined","newPlayerCoordinate","newCoordinate","getNextCoordinate","setState","gameLostMessage","pop","e","keyCode","keyCodeToDirection","blockStyle","position","width","gameFieldStyle","backgroundColor","left","top","fruitStyle","borderRadius","snakeStyle","scoreStype","color","style","onClick","map","key","React","Component","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.459bdc29.chunk.js","sourcesContent":["/**\r\n * Constants used in the game.\r\n */\r\n\r\n/**\r\n * Number of rows in the game grid\r\n */\r\nexport const GameRows = 31;\r\n\r\n/**\r\n * Number of columns in the game grid.\r\n */\r\nexport const GameColumns = 31;\r\n\r\n/**\r\n * Player start position on the X axis\r\n */\r\nexport const PlayerStartCoordinateX = Math.ceil(GameRows / 2);\r\n\r\n/**\r\n * Player start position on the Y axis\r\n */\r\nexport const PlayerStartCoordinateY = Math.ceil(GameColumns / 2);\r\n\r\n/**\r\n * The length of the snake at the start of the game.\r\n */\r\nexport const StartingSnakeLength = 5;\r\n\r\n/**\r\n * A constant value to calculate the best fitting CellWidth and Height.\r\n */\r\nexport const ResizeFactor = 0.027;\r\n\r\n/**\r\n * Cell width.\r\n */\r\nexport const CellWidthAndHeight = window.screen.height * ResizeFactor;\r\n\r\n/**\r\n * Offset where to position cells on the X axis.\r\n */\r\nexport const screenXOffset = (window.innerWidth / 2) - (CellWidthAndHeight * PlayerStartCoordinateX);\r\n\r\n/**\r\n * Offset where to postion cells on the Y axis.\r\n */\r\nexport const screenYOffset = (window.innerHeight / 2) - (CellWidthAndHeight * PlayerStartCoordinateY);\r\n\r\n/**\r\n * The number of milisecond between gameticks\r\n */\r\nexport const TimeTick = 100;\r\n\r\nexport const DebugOptions = {\r\n    manualMovement: false,\r\n};\r\n","/**\r\n * Lib. Lots of helper functions.\r\n */\r\n\r\nimport { GameColumns, GameRows, PlayerStartCoordinateX, PlayerStartCoordinateY, StartingSnakeLength } from \"../Constants\";\r\nimport { GameCoordinate } from \"../Models\";\r\nimport { Directions } from \"../Types\";\r\n\r\n/**\r\n * Returns a random position on the grid.\r\n */\r\nexport function getRandomGridCoordinates(exclude?: GameCoordinate[]): GameCoordinate {\r\n\r\n    while (true) {\r\n        const x = Math.ceil(Math.random() * (GameRows - 1));\r\n        const y = Math.ceil(Math.random() * (GameColumns - 1));\r\n\r\n        const coordinate: GameCoordinate = { x, y };\r\n\r\n        // Ensure a fruit is never placed on a player.\r\n        if (exclude) {\r\n            if (!coordinateExistsInSet(exclude, coordinate)) {\r\n                return coordinate;\r\n            }\r\n        } else {\r\n            return coordinate;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the grid coordinates where the player's body will be based on the initial snake length\r\n * @returns {GameCoordinate}. The player's initial grid coordinates.\r\n */\r\nexport function getPlayerStartCoordinates(): GameCoordinate[] {\r\n    const playerStartCoordinates: GameCoordinate[] = [{ x: PlayerStartCoordinateX, y: PlayerStartCoordinateY }];\r\n    for (let i = 1; i < StartingSnakeLength; i++) {\r\n        const lastCoordinate = { ...playerStartCoordinates[i - 1] };\r\n        lastCoordinate.y++;\r\n        playerStartCoordinates.push(lastCoordinate);\r\n    }\r\n\r\n    return playerStartCoordinates;\r\n}\r\n\r\n/**\r\n * Returns the direction for left, up, right, down.\r\n * @param {number} keyCode.\r\n */\r\nexport function keyCodeToDirection(keyCode: number): Directions {\r\n    switch (keyCode) {\r\n        case 37:\r\n            return \"left\";\r\n        case 38:\r\n            return \"up\";\r\n        case 39:\r\n            return \"right\";\r\n        case 40:\r\n            return \"down\";\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the next coordinate based on the passed direction\r\n * @returns {GameCoordinate}. A new grid coordinate\r\n */\r\nexport function getNextCoordinate(coordinate: GameCoordinate, direction: Directions): GameCoordinate {\r\n\r\n    const newCoordinate = { ...coordinate };\r\n\r\n    switch (direction) {\r\n        case \"left\":\r\n            newCoordinate.x--;\r\n            break;\r\n        case \"up\":\r\n            newCoordinate.y--;\r\n            break;\r\n        case \"right\":\r\n            newCoordinate.x++;\r\n            break;\r\n        case \"down\":\r\n            newCoordinate.y++;\r\n            break;\r\n    }\r\n\r\n    return newCoordinate;\r\n}\r\n\r\n/**\r\n * Returns true if the new direction is valid\r\n * @param {Directions} currentDirection. The current direction.\r\n * @param {Directions} newDirection. The new direciotn.\r\n */\r\nexport function validNewDirection(currentDirection: Directions, newDirection: Directions): boolean {\r\n    return getOppositeDirection(currentDirection) !== newDirection;\r\n}\r\n\r\n/**\r\n * Returns true of the passed coordinates are outside the bounds of the game grid.\r\n * @param {GameCoordinate} coordinates The coordinate to check\r\n * @returns {boolean}. True if the coordinats are outside the game grid.\r\n */\r\nexport function areCoordinatesOutsideGrid(coordinate: GameCoordinate): boolean {\r\n    return (coordinate.x < 0 ||\r\n        coordinate.x >= GameColumns ||\r\n        coordinate.y < 0 ||\r\n        coordinate.y >= GameRows);\r\n}\r\n\r\n/**\r\n * Checks if coordinates overlap between two arrays of GridCoordinates\r\n * @param {GameCoordinate[]} coordinateSet. Set of coordinates.\r\n * @param {GameCoordinate} coordinates. The coordinate to check\r\n */\r\nexport function coordinateExistsInSet(coordinates: GameCoordinate[], coordinate: GameCoordinate): boolean {\r\n    return coordinates.some((coords) => coords.x === coordinate.x && coords.y === coordinate.y);\r\n}\r\n\r\n/**\r\n * Returns the oposite direction.\r\n * @param {Directions} direction. A direction.\r\n * @returns {Directions}. The oposite direction.\r\n */\r\nfunction getOppositeDirection(direction: Directions): Directions {\r\n    switch (direction) {\r\n        case \"up\":\r\n            return \"down\";\r\n        case \"down\":\r\n            return \"up\";\r\n        case \"left\":\r\n            return \"right\";\r\n        case \"right\":\r\n            return \"left\";\r\n    }\r\n}","/**\r\n * The grid component.\r\n */\r\n\r\nimport React, { CSSProperties } from \"react\";\r\nimport { CellWidthAndHeight, DebugOptions, GameColumns, GameRows, screenXOffset, screenYOffset, StartingSnakeLength, TimeTick } from \"../Constants\";\r\nimport { areCoordinatesOutsideGrid, coordinateExistsInSet, getNextCoordinate, getPlayerStartCoordinates, getRandomGridCoordinates, keyCodeToDirection, validNewDirection } from \"../Lib/Lib\";\r\nimport { GameCoordinate } from \"../Models\";\r\nimport { Directions } from \"../Types\";\r\nimport { State } from \"./State\";\r\n\r\nexport class Game extends React.Component<{}, State> {\r\n\r\n    /**\r\n     * Reference number to the interval.\r\n     */\r\n    private gameTickTimer: number | undefined;\r\n\r\n    /**\r\n     * The direction the snake is traveling in. This is never updated directly by a keypress.\r\n     * It is set in the GameTick method when the newDirection is valid.\r\n     * It is also used to move the snake when no keypress was pending.\r\n     */\r\n    private currentDirection: Directions = \"up\";\r\n\r\n    /**\r\n     * The direction given my player input.\r\n     */\r\n    private newDirection?: Directions;\r\n\r\n    /**\r\n     * Constructs the component.\r\n     */\r\n    constructor(props: object) {\r\n        super(props);\r\n\r\n        this.state = this.getInitialState();\r\n\r\n        this.onKeyUp = this.onKeyUp.bind(this);\r\n        this.gameTick = this.gameTick.bind(this);\r\n        this.playAgain = this.playAgain.bind(this);\r\n    }\r\n\r\n    private getInitialState(): State {\r\n        const playerCoordinates = getPlayerStartCoordinates();\r\n        const fruitCoordinate = getRandomGridCoordinates(playerCoordinates);\r\n\r\n        return {\r\n            playerCoordinates,\r\n            fruitCoordinate,\r\n            snakeLength: StartingSnakeLength,\r\n            gameLost: false,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Called after the component mounts\r\n     */\r\n    public componentDidMount(): void {\r\n        document.addEventListener(\"keyup\", this.onKeyUp);\r\n\r\n        if (!DebugOptions.manualMovement) {\r\n            this.gameTickTimer = window.setInterval(this.gameTick, TimeTick);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called just before the component unmounts\r\n     */\r\n    public componentWillUnmount(): void {\r\n        document.removeEventListener(\"keyup\", this.onKeyUp);\r\n\r\n        if (typeof this.gameTickTimer !== \"undefined\") {\r\n            window.clearInterval(this.gameTickTimer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main game loop\r\n     */\r\n    private gameTick(callback?: () => void): void {\r\n\r\n        // Stop the game from updating if the player lost the game.\r\n        if (this.state.gameLost) {\r\n            return;\r\n        }\r\n\r\n        if (typeof this.newDirection !== \"undefined\" && validNewDirection(this.newDirection, this.currentDirection)) {\r\n            // The new direction is valid comparied to the current one. Update this.currentDirection to set\r\n            // the new direction of travel.\r\n            this.currentDirection = this.newDirection;\r\n\r\n            // Clear this.newDirection to indicate no move is pending.\r\n            this.newDirection = undefined;\r\n        }\r\n\r\n        const newPlayerCoordinate = getNextCoordinate(this.state.playerCoordinates[0], this.currentDirection);\r\n\r\n        if (areCoordinatesOutsideGrid(newPlayerCoordinate)) {\r\n            this.setState({ gameLost: true, gameLostMessage: \"You went outside the play field.\" });\r\n            return;\r\n        }\r\n\r\n        let snakeLength = this.state.snakeLength;\r\n        let fruitCoordinate = this.state.fruitCoordinate;\r\n\r\n        let playerCoordinates: GameCoordinate[] = [...this.state.playerCoordinates];\r\n        if (this.state.fruitCoordinate.x === newPlayerCoordinate.x &&\r\n            this.state.fruitCoordinate.y === newPlayerCoordinate.y) {\r\n\r\n            snakeLength++;\r\n            fruitCoordinate = getRandomGridCoordinates(playerCoordinates);\r\n        } else {\r\n            // Remove last element\r\n            playerCoordinates.pop();\r\n        }\r\n\r\n        // It is possible from length 5 or bigger to hit your tail, not before.\r\n        if (snakeLength > 4) {\r\n            if (coordinateExistsInSet(playerCoordinates, newPlayerCoordinate)) {\r\n                this.setState({ gameLost: true, gameLostMessage: \"You hit your tail.\" });\r\n                return;\r\n            }\r\n        }\r\n\r\n        playerCoordinates = [newPlayerCoordinate, ...playerCoordinates];\r\n\r\n        this.setState({ playerCoordinates, snakeLength, fruitCoordinate }, callback);\r\n    }\r\n\r\n    /**\r\n     * Handles a keypress.\r\n     * @param {KeyboardEvent } e. A keyboard event.\r\n     */\r\n    private onKeyUp(e: KeyboardEvent): void {\r\n        if (e) {\r\n            const direction = keyCodeToDirection(e.keyCode);\r\n\r\n            this.newDirection = direction;\r\n\r\n            if (DebugOptions.manualMovement) {\r\n                this.gameTick();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stars a new game\r\n     */\r\n    private playAgain(): void {\r\n        this.setState(this.getInitialState());\r\n    }\r\n\r\n    /**\r\n     * Renders the game grid.\r\n     * @returns {ReactNode}.\r\n     */\r\n    public render(): React.ReactNode {\r\n\r\n        const blockStyle: CSSProperties = {\r\n            position: \"absolute\",\r\n            height: `${CellWidthAndHeight}px`,\r\n            width: `${CellWidthAndHeight}px`,\r\n        };\r\n\r\n        const gameFieldStyle: CSSProperties = {\r\n            position: \"absolute\",\r\n            height: `${CellWidthAndHeight * GameColumns}px`,\r\n            width: `${CellWidthAndHeight * GameRows}px`,\r\n            backgroundColor: \"green\",\r\n            left: screenXOffset,\r\n            top: screenYOffset,\r\n        };\r\n\r\n        const fruitStyle: CSSProperties = {\r\n            ...blockStyle,\r\n            backgroundColor: \"red\",\r\n            left: this.state.fruitCoordinate.x * CellWidthAndHeight,\r\n            top: this.state.fruitCoordinate.y * CellWidthAndHeight,\r\n            borderRadius: \"50%\"\r\n        };\r\n\r\n        const snakeStyle: CSSProperties = {\r\n            ...blockStyle,\r\n            backgroundColor: this.state.gameLost ? \"brown\" : \"yellow\",\r\n        };\r\n\r\n        const scoreStype: CSSProperties = {\r\n            position: \"absolute\",\r\n            color: \"white\",\r\n            top: screenYOffset,\r\n            left: screenXOffset - 100\r\n        };\r\n\r\n        return (\r\n            <div>\r\n                <p style={scoreStype}>Length: {this.state.snakeLength}</p>\r\n                <p style={{ ...scoreStype, top: screenYOffset + 30 }}>Fruits: {this.state.snakeLength - StartingSnakeLength}</p>\r\n                {\r\n                    this.state.gameLost ?\r\n                        <button style={{ position: \"absolute\", top: screenYOffset + 70, left: screenXOffset - 100 }} onClick={this.playAgain}>Play again?</button>\r\n                        : null\r\n                }\r\n                <div style={gameFieldStyle}>\r\n                    <div style={fruitStyle} />\r\n                    {\r\n                        this.state.playerCoordinates.map((coordinate, key) =>\r\n                            <div key={key} style={\r\n                                {\r\n                                    ...snakeStyle,\r\n                                    left: coordinate.x * CellWidthAndHeight,\r\n                                    top: coordinate.y * CellWidthAndHeight,\r\n                                }\r\n                            } />\r\n                        )\r\n                    }\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","/**\n * Entry point\n */\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Game } from \"./Game/Game\";\n\nReactDOM.render(<Game />, document.getElementById(\"root\"));\n"],"sourceRoot":""}