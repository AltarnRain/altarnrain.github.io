{"version":3,"sources":["GameDimensions.ts","State/GameActions.ts","Constants.ts","Lib.ts","Guard.ts","Reducers/BallReducer.ts","Reducers/BlockReducer.ts","Reducers/PaddleReducer.ts","Store.ts","Reducers/GameStateReducer.ts","WallConstants.ts","Main.tsx","index.tsx"],"names":["gameDimensions","GameActions","DegreeToRadian","Math","PI","InitialBallVelocity","BallResizeFactor","NumberOfBlockColumns","WindowResizeConstant","PaddleWithFactor","PaddleHeightFactor","PaddlePositionFactor","BallSpeedIncreasePerBlock","BallSpeedIncreasePerLevel","getGameDimensions","size","window","innerHeight","innerWidth","left","top","blockHeight","blockWidth","getInitialBlocks","blocks","index","r","c","block","color","x","y","height","width","hit","push","overlaps","shape1","shape2","left1","ceil","right1","floor","top1","bottom1","left2","right2","top2","bottom2","angleRandomizer","angleManipulator","random","getBounceAction","ball","shape","shapeLeft","shapeRight","shapeTop","shapeBottom","ballLeft","ballRight","ballTop","ballBottom","withinVerticalBounds","withinHorizantalBounds","directions","angle","returnValue","getNextX","getNextY","getDirectionFromAngle","goingLeft","some","d","goingRight","goingUp","goingDown","ballBounceHorizantally","ballBounceVertically","console","log","changeAngle","paddle","abs","distance","currentY","sin","currentX","cos","Guard","isPaddle","value","reducers","state","action","type","initialize","nextLevel","initialState","forEach","b","hitBlock","payload","hitBlockState","indexOf","tick","hitBlocks","map","length","tickBlockState","factor","halfFactor","splice","paddleMove","velocity","lastObject","angleChange","gameState","gameMode","level","score","gameLost","allReducers","combineReducers","store","createStore","appStore","appState","getState","Walls","leftWall","rightWall","topWall","bottomWall","Main","props","tickHandler","tickStart","subscription","onMouseMove","bind","onPlayAgain","e","clientX","dispatch","this","requestAnimationFrame","paddleBounceAction","find","syncStateWithRedux","addEventListener","subscribe","applicationState","setState","cancelAnimationFrame","removeEventListener","position","borderColor","borderStyle","display","justifyContent","flexDirection","backgroundColor","newPosition","positionStyle","borderRadius","Object","keys","key","componentStateProperty","applicationStatProperty","style","gameScorebarStyle","marginLeft","gameFieldStyle","ballStyle","alignSelf","onClick","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.e9348eb4.chunk.js","sourcesContent":["/**\r\n * Provides game dimensions.\r\n */\r\n\r\nimport { NumberOfBlockColumns, WindowResizeConstant } from \"./Constants\";\r\nimport { GameDimensions } from \"./State/GameDimensions\";\r\n\r\nlet gameDimensions: GameDimensions;\r\n\r\nexport function getGameDimensions(): GameDimensions {\r\n    if (!gameDimensions) {\r\n        let size = 0;\r\n\r\n        if (window.innerHeight > window.innerWidth) {\r\n            size = window.innerWidth * WindowResizeConstant;\r\n        } else {\r\n            size = window.innerHeight * WindowResizeConstant;\r\n        }\r\n\r\n        const left = (window.innerWidth / 2) - (size / 2);\r\n        const top = (window.innerHeight / 2) - (size / 2);\r\n        const blockHeight = size / (NumberOfBlockColumns * 2);\r\n        const blockWidth = size / NumberOfBlockColumns;\r\n\r\n        gameDimensions = { left, top, size, blockHeight, blockWidth, };\r\n    }\r\n\r\n    return gameDimensions;\r\n}","export enum GameActions {\r\n    initialize,\r\n    hitBlock,\r\n    paddleMove,\r\n    tick,\r\n    ballBounceHorizantally,\r\n    ballBounceVertically,\r\n    gameLost,\r\n    nextLevel,\r\n}","\r\n/**\r\n * A constants used to convert the angle from degree's to radians.\r\n */\r\nexport const DegreeToRadian = Math.PI / 180;\r\n\r\n/**\r\n * A constants that contains the time in milli second for a frame.\r\n */\r\nexport const GameTick = 1000 / 60;\r\n\r\n/**\r\n * Constants for the initial ball velocity.\r\n */\r\nexport const InitialBallVelocity = 10;\r\n\r\n/**\r\n * Constants used in a calculation to randomize the ball's initial angle.\r\n */\r\nexport const BallAngleStartRandomFactor = 10;\r\n\r\n/**\r\n * Constants used in calculation the width and height of the ball relative to the game field diminsions.\r\n */\r\nexport const BallResizeFactor = 0.02;\r\n\r\n/**\r\n * A Constants used ina calculation to increase or decrease the angle of the ball depending on where it hits the paddle.\r\n */\r\nexport const BounceAngleIncreaseConstant = 40;\r\n\r\n/**\r\n * The number of blocks from top to bottom\r\n */\r\nexport const NumberOfBlockRows = 5;\r\n\r\n/**\r\n * The number of blocks from left to right.\r\n */\r\nexport const NumberOfBlockColumns = 12;\r\n\r\n/**\r\n * Constant to used to calculate the size of the playing field.\r\n */\r\nexport const WindowResizeConstant = 0.9;\r\n\r\n/**\r\n * Used to calculate the paddle with relative to the game field width.\r\n */\r\nexport const PaddleWithFactor = 40;\r\n\r\n/**\r\n * Used to calculate the height of the paddle relative to the game field height.\r\n */\r\nexport const PaddleHeightFactor = 10;\r\n\r\n/**\r\n * Used to calculate the paddle's top coordinate relative to the game field height.\r\n */\r\nexport const PaddlePositionFactor = 0.9;\r\n\r\n/**\r\n * Speed increase factor for each hit block\r\n */\r\nexport const BallSpeedIncreasePerBlock = 1.02;\r\n\r\n/**\r\n * Speed increase factor for each level.\r\n */\r\nexport const BallSpeedIncreasePerLevel = 0.5;","import { BallAngleStartRandomFactor, BounceAngleIncreaseConstant, DegreeToRadian, NumberOfBlockColumns, NumberOfBlockRows } from \"./Constants\";\r\nimport { Ball } from \"./Definitions/Ball\";\r\nimport { Block } from \"./Definitions/Block\";\r\nimport { Direction } from \"./Definitions/Direction\";\r\nimport { ScreenObject } from \"./Definitions/ScreenObject\";\r\nimport { GameActions } from \"./State/GameActions\";\r\n\r\n/**\r\n * Returns the initial block setup.\r\n * @returns {Block[]}.\r\n */\r\nexport const getInitialBlocks = (): Block[] => {\r\n\r\n    const blocks: Block[] = [];\r\n\r\n    let index = 0;\r\n    for (let r = 0; r < NumberOfBlockRows; r++) {\r\n        index++;\r\n        for (let c = 0; c < NumberOfBlockColumns; c++) {\r\n            const block: Block = {\r\n                color: index % 2 === 0 ? \"red\" : \"blue\",\r\n                x: c,\r\n                y: r,\r\n                left: 0,\r\n                top: 0,\r\n                height: 0,\r\n                width: 0,\r\n                hit: false\r\n            };\r\n\r\n            index++;\r\n            blocks.push(block);\r\n        }\r\n    }\r\n\r\n    return blocks;\r\n};\r\n\r\n/**\r\n * Checks if two shapes overlap\r\n * @param {ScreenObject} shape1. A Shape.\r\n * @param {ScreenObject} shape2. A Shape\r\n */\r\nexport const overlaps = (shape1: ScreenObject, shape2: ScreenObject) => {\r\n\r\n    const left1 = Math.ceil(shape1.left);\r\n    const right1 = Math.floor(shape1.left + shape1.width);\r\n    const top1 = Math.ceil(shape1.top);\r\n    const bottom1 = Math.floor(shape1.top + shape1.height);\r\n\r\n    const left2 = Math.ceil(shape2.left);\r\n    const right2 = Math.floor(shape2.left + shape2.width);\r\n    const top2 = Math.ceil(shape2.top);\r\n    const bottom2 = Math.floor(shape2.top + shape2.height);\r\n\r\n    if (bottom1 < top2 || top1 > bottom2) {\r\n        return false;\r\n    }\r\n\r\n    if (right2 < left1 || left2 > right1) {\r\n        return false;\r\n    }\r\n\r\n    // Rectangles overlap\r\n    return true;\r\n};\r\n\r\n/**\r\n * Randomizes an angle.\r\n * @returns {number}. A number that can be added to an angle to slightly change it.\r\n */\r\nexport const angleRandomizer = (): number => {\r\n    const angleManipulator = (Math.random() * BallAngleStartRandomFactor);\r\n    if (Math.random() >= 0.5) {\r\n        return angleManipulator;\r\n    } else {\r\n        return angleManipulator * -1;\r\n    }\r\n};\r\n\r\n/**\r\n * Determine the right action to dispatch when the ball bounces off an object.\r\n * @param {Ball} ball. Ball object.\r\n * @param {ScreenObject} shape. A shape object.\r\n * @returns {GameActions}. The bounce action or undefined if no bounce action could be determined.\r\n */\r\nexport const getBounceAction = (ball: Ball, shape: ScreenObject): GameActions.ballBounceHorizantally | GameActions.ballBounceVertically => {\r\n\r\n    const shapeLeft = shape.left;\r\n    const shapeRight = shape.left + shape.width;\r\n    const shapeTop = shape.top;\r\n    const shapeBottom = shape.top + shape.height;\r\n\r\n    const ballLeft = ball.left;\r\n    const ballRight = ball.left + ball.width;\r\n\r\n    const ballTop = ball.top;\r\n    const ballBottom = ball.top + ball.height;\r\n\r\n    const withinVerticalBounds = (ballRight > shapeLeft && ballLeft < shapeRight);\r\n    const withinHorizantalBounds = (ballBottom > shapeTop && ballTop < shapeBottom);\r\n\r\n    const directions = getDirectionFromAngle(ball.angle);\r\n\r\n    const goingLeft = directions.some((d) => d === \"left\");\r\n    const goingRight = directions.some((d) => d === \"right\");\r\n    const goingUp = directions.some((d) => d === \"up\");\r\n    const goingDown = directions.some((d) => d === \"down\");\r\n\r\n    // Most times the top or bottom of a ScreenObject will be hit so check those first.\r\n    if (goingUp && ballTop < shapeBottom && withinVerticalBounds) {\r\n        return GameActions.ballBounceHorizantally;\r\n        // bottom\r\n    } else if (goingDown && ballBottom > shapeTop && withinVerticalBounds) {\r\n        // Top\r\n        return GameActions.ballBounceHorizantally;\r\n    } else if (goingLeft && ballRight > shapeRight && withinHorizantalBounds) {\r\n        // Right\r\n        return GameActions.ballBounceVertically;\r\n    } else if (goingRight && ballLeft < shapeLeft && withinHorizantalBounds) {\r\n        // Left\r\n        return GameActions.ballBounceVertically;\r\n    }\r\n\r\n    // tslint:disable-next-line: no-console\r\n    console.log(\"Failed hit detection\");\r\n    return GameActions.ballBounceHorizantally;\r\n};\r\n\r\n/**\r\n * Changes the angle based on the position of impact.\r\n * @param {Ball} ball. A ball object\r\n * @param {Paddle} paddle. A paddle object\r\n */\r\nexport const changeAngle = (ball: ScreenObject, paddle: ScreenObject): number => {\r\n    const p = Math.abs(ball.left - paddle.left);\r\n\r\n    // calculate a factor based on the shape's width. Since this is a horizantol hit, this results in a\r\n    // number between 0 and 1.\r\n    const v = p / paddle.width;\r\n    const returnValue = BounceAngleIncreaseConstant * (0.5 - v) * -1;\r\n    return returnValue;\r\n};\r\n\r\nexport function getNextY(angle: number, distance: number, currentY: number) {\r\n    return Math.sin(angle * DegreeToRadian * -1) * distance + currentY;\r\n}\r\n\r\nexport function getNextX(angle: number, distance: number, currentX: number) {\r\n    return Math.cos(angle * DegreeToRadian * -1) * distance + currentX;\r\n}\r\n\r\nexport function getDirectionFromAngle(angle: number): Direction[] {\r\n\r\n    // A ball can travel at two directions at most so the return\r\n    // Value has to be an array with a size of 1 or two.\r\n    const returnValue: Direction[] = [];\r\n\r\n    const x = getNextX(angle, 10, 0);\r\n    const y = getNextY(angle, 10, 0);\r\n\r\n    if (x > 0) {\r\n        // Ball travels to the right\r\n        returnValue.push(\"right\");\r\n    }\r\n\r\n    if (x < 0) {\r\n        // Ball travels to the left.\r\n        returnValue.push(\"left\");\r\n    }\r\n\r\n    if (y > 0) {\r\n        // Ball travels down.\r\n        returnValue.push(\"down\");\r\n    }\r\n\r\n    if (y < 0) {\r\n        returnValue.push(\"up\");\r\n    }\r\n\r\n    return returnValue;\r\n}\r\n\r\n/**\r\n * Compares the key value of the referenceObject to the sourceObject.\r\n * @param {any} sourceObject. Can be any object.\r\n * @param {any} referenceObject. Can be any object.\r\n */\r\nexport function getUpdatedOjbect(sourceObject: any, referenceObject: any): any {\r\n    const newObject: any = {};\r\n    Object.keys(sourceObject).forEach((key: string) => {\r\n\r\n        // Get the objects using the key values from the application state.\r\n        const referenceObjectKeyValue = referenceObject[key];\r\n        const sourceObjectKeyValue = sourceObject[key];\r\n\r\n        // Check if the objects have the same reference, if not expand the state object\r\n        if (referenceObjectKeyValue !== sourceObjectKeyValue) {\r\n            newObject[key] = sourceObjectKeyValue;\r\n        }\r\n    });\r\n\r\n    if (Object.keys(newObject).length > 0) {\r\n        return newObject;\r\n    } else {\r\n        return undefined;\r\n    }\r\n}","import { Paddle } from \"./Definitions/Paddle\";\r\n\r\n/**\r\n * A constats that contains type guards.\r\n */\r\nexport const Guard = {\r\n\r\n    /**\r\n     * Typeguard for determining if a shape is actually the paddle.\r\n     * @returns {boolean}. True if the object is a paddle, false otherwise.\r\n     */\r\n    isPaddle: (value: any): value is Paddle => {\r\n        return value && value.isPaddle;\r\n    }\r\n};","import { BallResizeFactor, BallSpeedIncreasePerBlock, BallSpeedIncreasePerLevel, InitialBallVelocity } from \"../Constants\";\r\nimport { Ball } from \"../Definitions/Ball\";\r\nimport { ScreenObject } from \"../Definitions/ScreenObject\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { Guard } from \"../Guard\";\r\nimport { angleRandomizer, changeAngle, getNextX, getNextY } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles ball actions.\r\n */\r\nexport function ballReducer(state: Ball = {} as Ball, action: ActionPayload<ScreenObject>): Ball {\r\n\r\n    switch (action.type) {\r\n        case GameActions.initialize: {\r\n            const angle = 90 + angleRandomizer();\r\n            return {\r\n                angle,\r\n                color: \"yellow\",\r\n                height: gameDimensions.size * BallResizeFactor,\r\n                width: gameDimensions.size * BallResizeFactor,\r\n                left: (gameDimensions.size / 2) - (gameDimensions.size * BallResizeFactor / 2),\r\n                top: (gameDimensions.size / 2) - (gameDimensions.size * BallResizeFactor / 2),\r\n                velocity: InitialBallVelocity,\r\n                lastObject: {},\r\n            };\r\n        }\r\n\r\n        case GameActions.tick: {\r\n            const x = getNextX(state.angle, state.velocity, state.left);\r\n            const y = getNextY(state.angle, state.velocity, state.top);\r\n\r\n            return { ...state, left: x, top: y };\r\n        }\r\n\r\n        case GameActions.ballBounceHorizantally:\r\n        case GameActions.ballBounceVertically: {\r\n            if (action.payload && action.payload !== state.lastObject) {\r\n                let angle = state.angle;\r\n                let angleChange = 1;\r\n\r\n                if (action.type === GameActions.ballBounceHorizantally) {\r\n\r\n                    // If the baddle is hit we want the ball's angle to increase if it hit\r\n                    // the edges.\r\n                    if (Guard.isPaddle(action.payload)) {\r\n                        // calculate where the ball hit relative to the shape from the left size.\r\n                        angleChange = changeAngle(state, action.payload);\r\n                    }\r\n\r\n                    // When the ball top or bottom makes contact, multiply the current angle by -1 for it to bounce.\r\n                    angle = (angle + angleChange) * -1;\r\n                } else {\r\n                    if (action.payload && action.payload !== state.lastObject) {\r\n                        // If the ball hits a side, the new angle is 180 - current angle.\r\n                        angle = 180 - angle;\r\n                    }\r\n                }\r\n\r\n                return { ...state, angle, lastObject: action.payload };\r\n            }\r\n\r\n            return state;\r\n        }\r\n\r\n        case GameActions.hitBlock:\r\n            // Increase the ball speed for each hit block\r\n            return { ...state, velocity: state.velocity * BallSpeedIncreasePerBlock };\r\n        case GameActions.nextLevel:\r\n            // Increase ball speed for each level.\r\n            return { ...state, velocity: state.velocity + BallSpeedIncreasePerLevel };\r\n        default:\r\n            return state;\r\n    }\r\n}","import { Block } from \"../Definitions/Block\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { getInitialBlocks } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\nexport function blockReducer(state: Block[] = [], action: ActionPayload<Block>): Block[] {\r\n    switch (action.type) {\r\n        case GameActions.initialize:\r\n        case GameActions.nextLevel:\r\n            const initialState = getInitialBlocks();\r\n\r\n            initialState.forEach((b) => {\r\n                b.height = gameDimensions.blockHeight;\r\n                b.width = gameDimensions.blockWidth;\r\n                b.left = b.x * gameDimensions.blockWidth;\r\n                b.top = b.y * gameDimensions.blockHeight;\r\n            });\r\n\r\n            return initialState;\r\n\r\n        case GameActions.hitBlock:\r\n            if (action.payload) {\r\n                const hitBlockState = [...state];\r\n                const hitBlockIndex = state.indexOf(action.payload);\r\n\r\n                hitBlockState[hitBlockIndex].hit = true;\r\n\r\n                return hitBlockState;\r\n            }\r\n\r\n            return state;\r\n\r\n        case GameActions.tick:\r\n\r\n            const hitBlocks = state.map((b, index) => {\r\n                if (b.hit === true) {\r\n                    return { block: b, index };\r\n                } else {\r\n                    return undefined;\r\n                }\r\n            });\r\n\r\n            if (hitBlocks.length > 0) {\r\n\r\n                const tickBlockState = [...state];\r\n\r\n                const factor = gameDimensions.blockHeight * 0.1;\r\n                const halfFactor = factor / 2;\r\n                hitBlocks.forEach((b) => {\r\n                    if (b) {\r\n                        const block = { ...b.block };\r\n\r\n                        block.height -= factor;\r\n                        block.width -= factor;\r\n                        block.left += halfFactor;\r\n                        block.top += halfFactor;\r\n\r\n                        if (block.height <= 0 || block.width <= 0) {\r\n                            // Block has reached size '0', time to remove it.\r\n                            tickBlockState.splice(b.index, 1);\r\n                        } else {\r\n                            tickBlockState[b.index] = block;\r\n                        }\r\n                    }\r\n                });\r\n\r\n                return tickBlockState;\r\n            } else {\r\n                return state;\r\n            }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}","\r\nimport { PaddleHeightFactor, PaddlePositionFactor, PaddleWithFactor } from \"../Constants\";\r\nimport { Paddle } from \"../Definitions/Paddle\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles paddle actions\r\n * @param {Paddle} state. The paddle state.\r\n * @param {ActionPayload<number> }action. An action to be performed on the paddle. Number is the 'left' coordinate of the paddle.\r\n */\r\nexport function paddleReducer(state: Paddle = { isPaddle: true } as Paddle, action: ActionPayload<number>): Paddle {\r\n    switch (action.type) {\r\n        case GameActions.initialize:\r\n\r\n            const height = gameDimensions.size / PaddleWithFactor;\r\n            const width = gameDimensions.size / PaddleHeightFactor;\r\n            const left = (gameDimensions.size / 2) - (width / 2);\r\n            const top = gameDimensions.size * PaddlePositionFactor;\r\n\r\n            return {\r\n                color: \"white\",\r\n                width,\r\n                top,\r\n                left,\r\n                height,\r\n                isPaddle: true\r\n            };\r\n\r\n        case GameActions.paddleMove:\r\n\r\n            // Prevent the paddle from being drawn outside the playfield.\r\n            if (typeof (action.payload) !== \"undefined\") {\r\n\r\n                let x;\r\n\r\n                if (action.payload - state.width / 2 <= 0) {\r\n                    x = 0;\r\n                } else if (action.payload - state.width / 2 >= (gameDimensions.size - state.width)) {\r\n                    x = gameDimensions.size - state.width;\r\n                } else {\r\n                    x = action.payload - (state.width / 2);\r\n                }\r\n\r\n                if (state.left === x) {\r\n                    return state;\r\n                } else {\r\n                    const newState = { ...state, left: x };\r\n                    return newState;\r\n                }\r\n            } else {\r\n                return state;\r\n            }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}","import { combineReducers, createStore, ReducersMapObject, Store } from \"redux\";\r\nimport { gameStateReducer } from \"./Reducers/GameStateReducer\";\r\nimport { ballReducer } from \"./Reducers/BallReducer\";\r\nimport { blockReducer } from \"./Reducers/BlockReducer\";\r\nimport { paddleReducer } from \"./Reducers/PaddleReducer\";\r\nimport ActionPayload from \"./State/ActionPayLoad\";\r\nimport { AppState } from \"./State/AppState\";\r\n\r\nconst reducers: ReducersMapObject<AppState, ActionPayload<any>> = {\r\n    blocks: blockReducer,\r\n    paddle: paddleReducer,\r\n    ball: ballReducer,\r\n    gameState: gameStateReducer\r\n};\r\n\r\nconst allReducers = combineReducers(reducers);\r\n\r\nconst store = createStore<AppState, ActionPayload<any>, AppState, AppState>(allReducers);\r\n\r\n/**\r\n * Returns the store\r\n * @returns {Store}. The redux store.\r\n */\r\nexport function appStore(): Store<AppState, ActionPayload<any>> {\r\n    return store;\r\n}\r\n\r\n/**\r\n * Returns the State\r\n * @returns {AppState}. The application state.\r\n */\r\nexport function appState(): AppState {\r\n    return appStore().getState();\r\n}","import { Action } from \"redux\";\r\nimport { GameState } from \"../Definitions/GameState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\n/**\r\n * Miscellaneous reducer.\r\n */\r\nexport function gameStateReducer(state: GameState = {} as GameState, action: Action<GameActions>): GameState {\r\n    switch (action.type) {\r\n        case GameActions.initialize:\r\n            return { gameMode: \"running\", level: 1, score: 0 };\r\n        case GameActions.gameLost:\r\n            return { ...state, gameMode: \"ended\" };\r\n        case GameActions.nextLevel:\r\n            return { ...state, level: state.level + 1 };\r\n        case GameActions.hitBlock:\r\n            return { ...state, score: state.score + 1 };\r\n        default:\r\n            return state;\r\n    }\r\n}","\r\n/**\r\n * A constant object that has an object for each wall. Used to eliminate double bounces.\r\n */\r\nexport const Walls = {\r\n    leftWall: {},\r\n    rightWall: {},\r\n    topWall: {},\r\n    bottomWall: {}\r\n};","import React, { CSSProperties } from \"react\";\nimport { GameTick } from \"./Constants\";\nimport { Ball } from \"./Definitions/Ball\";\nimport { GameObject } from \"./Definitions/GameObject\";\nimport { getGameDimensions } from \"./GameDimensions\";\nimport { getBounceAction, overlaps } from \"./Lib\";\nimport { AppState } from \"./State/AppState\";\nimport { GameActions } from \"./State/GameActions\";\nimport { appState, appStore } from \"./Store\";\nimport { Walls } from \"./WallConstants\";\n\nconst gameDimensions = getGameDimensions();\n\n/**\n * Main game component.\n */\nexport class Main extends React.Component<{}, AppState> {\n\n    /**\n     * Stores a reference to the animation that draws the game.\n     */\n    private tickHandler?: number;\n\n    /**\n     * Used to store the beginning of a game tick.\n     */\n    private tickStart?: number;\n\n    /**\n     * Refux subscription\n     */\n    private subscription?: () => void;\n\n    /**\n     * Initializes the Main component.\n     */\n    constructor(props: object) {\n        super(props);\n\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.tick = this.tick.bind(this);\n        this.onPlayAgain = this.onPlayAgain.bind(this);\n\n        // Sync the redux state with the component state.\n        this.state = appState();\n    }\n\n    /**\n     * Handles mouse movement. Used to move the paddle.\n     * @param {MouseEvent} e. MouseEvent.\n     */\n    private onMouseMove(e: MouseEvent): void {\n        if (e) {\n            const x = e.clientX - gameDimensions.left;\n            appStore().dispatch({ type: GameActions.paddleMove, payload: x });\n        }\n    }\n\n    /**\n     * Handles a play again click.\n     */\n    private onPlayAgain(): void {\n        // Reset game state.\n\n        appStore().dispatch({ type: GameActions.initialize });\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Handles a game tick.\n     * @param {number} tick. Current tick count.\n     */\n    public tick(tick: number): void {\n\n        if (!this.tickStart) {\n            this.tickStart = tick;\n        }\n\n        if (this.state.gameState.gameMode === \"ended\") {\n            return;\n        }\n\n        const diff = tick - this.tickStart;\n\n        // Redraw at 60 fps.\n        if (diff > GameTick) {\n            const ball = appState().ball;\n            const blocks = appState().blocks;\n            const paddle = appState().paddle;\n\n            if (blocks.length === 0) {\n                appStore().dispatch({ type: GameActions.nextLevel });\n            }\n\n            const paddleHit = overlaps(ball, paddle);\n\n            if (paddleHit) {\n                const paddleBounceAction = getBounceAction(ball, paddle);\n                appStore().dispatch({ type: paddleBounceAction, payload: paddle });\n            } else if (blocks) {\n\n                const hitBlock = blocks.find((b) => overlaps(ball, b) && b.hit === false);\n                if (hitBlock) {\n                    appStore().dispatch({ type: GameActions.hitBlock, payload: hitBlock });\n\n                    const action = getBounceAction(ball, hitBlock);\n\n                    if (typeof (action) !== \"undefined\") {\n                        appStore().dispatch({ type: action, payload: hitBlock });\n                    }\n\n                } else if (ball.top <= 0) {\n                    // The ball's top and left are inside the game field.\n                    // Use the game dimension object to store a wall hit.\n                    // Hit the top  wall\n                    appStore().dispatch({ type: GameActions.ballBounceHorizantally, payload: Walls.topWall });\n\n                } else if (ball.left <= 0) {\n                    // Hit the left wall\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.leftWall });\n\n                } else if (ball.left + ball.width >= gameDimensions.size) {\n                    // Hit the right wall\n\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.rightWall });\n                } else if (ball.top + ball.width >= gameDimensions.size) {\n                    // Hit bottom wall.\n                    appStore().dispatch({ type: GameActions.gameLost });\n                }\n            }\n\n            appStore().dispatch({ type: GameActions.tick });\n\n            this.syncStateWithRedux();\n            this.tickStart = tick;\n        }\n\n        this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Called when the component mounted.\n     */\n    public componentDidMount(): void {\n\n        appStore().dispatch({ type: GameActions.initialize });\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n\n        window.addEventListener(\"mousemove\", this.onMouseMove);\n\n        this.subscription = appStore().subscribe(() => {\n            const applicationState = appState();\n\n            if (applicationState.gameState !== this.state.gameState) {\n                this.setState({ gameState: applicationState.gameState });\n\n                if (applicationState.gameState.gameMode === \"ended\") {\n                    if (this.tickHandler) {\n                        window.cancelAnimationFrame(this.tickHandler);\n                    }\n                }\n            }\n\n        });\n    }\n\n    /**\n     * Called before the component unmounts.\n     */\n    public componentWillUnmount(): void {\n        if (this.tickHandler) {\n            window.cancelAnimationFrame(this.tickHandler);\n        }\n\n        window.removeEventListener(\"mousemove\", this.onMouseMove);\n\n        if (this.subscription) {\n            this.subscription();\n            delete this.subscription;\n        }\n    }\n\n    /**\n     * Returns the styling for the game field.\n     * @returns {CSSProperties}. CSSProperties for the gamefield.\n     */\n    private gameFieldStyle(): CSSProperties | undefined {\n\n        return {\n            position: \"absolute\",\n            left: gameDimensions.left,\n            top: gameDimensions.top,\n            width: gameDimensions.size,\n            height: gameDimensions.size,\n            borderColor: \"white\",\n            borderStyle: \"solid\",\n            display: \"flex\",\n            justifyContent: \"center\"\n        };\n    }\n\n    private gameScorebarStyle(): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: gameDimensions.left,\n            width: gameDimensions.size,\n            top: gameDimensions.top - 25,\n            height: 22,\n            borderColor: \"white\",\n            borderStyle: \"solid\",\n            display: \"flex\",\n            flexDirection: \"row\",\n        };\n    }\n\n    /**\n     * Returns css properties for positioning a shape.\n     * @param {ScreenObject} shape. A shape object.\n     * @returns {CSSProperties}.\n     */\n    private positionStyle(shape: GameObject): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: shape.left,\n            top: shape.top,\n            height: shape.height,\n            width: shape.width,\n            backgroundColor: shape.color,\n        };\n    }\n\n    /**\n     * Returns css properties for positioning and drawing the ball.\n     * @param {Ball} ball.\n     * @returns {CSSProperties}.\n     */\n    private ballStyle(ball: Ball): CSSProperties {\n        const newPosition = this.positionStyle(ball);\n        newPosition.borderRadius = \"50%\";\n\n        return newPosition;\n    }\n\n    /**\n     * Syncs this components state with the redux state.\n     */\n    private syncStateWithRedux(): void {\n        const applicationState = appState();\n\n        // Start with an empty 'state' object.\n        // This component's state is the same definitation as the application state in redux\n        const state: AppState = {} as AppState;\n\n        Object.keys(applicationState).forEach((key: string) => {\n\n            // Get the objects using the key values from the application state.\n            const componentStateProperty = this.state[key];\n            const applicationStatProperty = applicationState[key];\n\n            // Check if the objects have the same reference, if not expand the state object\n            if (componentStateProperty !== applicationStatProperty) {\n                state[key] = applicationStatProperty;\n            }\n        });\n\n        // The state object has keys meaning it was expected. SetState and let React figure out\n        // the rest.\n        if (Object.keys(state).length > 0) {\n            this.setState(state);\n        }\n    }\n\n    /**\n     * Renders the component.\n     */\n    public render(): React.ReactNode {\n        return (\n            <div>\n\n                <div style={this.gameScorebarStyle()}>\n                    <div key={1} style={{ color: \"white\", justifyContent: \"center\", marginLeft: \"10px\" }}>Level: {this.state.gameState.level}</div>>\n                <div key={2} style={{ color: \"white\", justifyContent: \"center\" }}>Score: {this.state.gameState.score}</div>>\n            </div>\n                <div>\n                    {\n                        this.state.blocks && this.state.paddle && this.state.ball ?\n                            <div style={this.gameFieldStyle()}>\n                                {\n                                    this.state.blocks.map((b, index) => <div key={index} style={this.positionStyle(b)} />)\n                                }\n                                <div style={this.positionStyle(this.state.paddle)} />\n                                <div style={this.ballStyle(this.state.ball)} />\n                                {\n                                    this.state.gameState.gameMode === \"ended\" ?\n                                        <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"center\" }}>\n                                            <p style={{ alignSelf: \"center\", color: \"white\" }}>Game over</p>\n                                            <button onClick={this.onPlayAgain} style={{ alignSelf: \"center\" }}>Play again</button>\n                                        </div>\n                                        : null\n                                }\n\n                            </div> : null\n                    }\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default Main;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Main from \"./Main\";\n\nReactDOM.render(<Main />, document.getElementById(\"root\"));\n"],"sourceRoot":""}