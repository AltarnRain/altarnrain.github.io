{"version":3,"sources":["GameDimensions.ts","State/GameActions.ts","Constants/Constants.ts","Constants/WallConstants.ts","Lib.ts","Guards/Guard.ts","Reducers/BallReducer.ts","Reducers/BlockReducer.ts","Reducers/GameStateReducer.ts","Reducers/PaddleReducer.ts","State/Store.ts","Components/Main.tsx","index.tsx"],"names":["gameDimensions","GameActions","DegreeToRadian","Math","PI","Walls","leftWall","rightWall","topWall","bottomWall","getGameDimensions","size","window","innerHeight","innerWidth","left","top","getBlocks","numberOfBlockRows","numberOfBlockColumns","blocks","r","c","red","ceil","random","green","trans","block","color","x","y","height","width","hit","push","overlaps","shape1","shape2","left1","right1","floor","top1","bottom1","left2","right2","top2","bottom2","getBounceAction","ball","shape","hitSide","getHitSide","ballBounceVertically","ballBounceHorizantally","console","log","shapeLeft","shapeRight","shapeTop","shapeBottom","ballLeft","ballRight","ballTop","withinVerticalBounds","withinHorizantalBounds","directions","getDirectionFromAngle","angle","goingLeft","some","d","goingRight","goingUp","goingDown","changeAngle","paddle","abs","getNextY","distance","currentY","sin","getNextX","currentX","cos","returnValue","Guard","value","isPaddle","getBallSize","getNewState","angleManipulator","angleRandomizer","velocity","lastObject","rows","columns","calculateBlockWidth","calculateBlockHeight","forEach","b","gameMode","level","score","reducers","blockState","state","action","type","reset","nextLevel","nextLevelState","hitBlock","payload","hitBlockState","hitBlockIndex","indexOf","tick","hitBlocks","filter","length","widthReductionFactor","heightReductionFactor","tickBlocks","splice","paddleMove","newState","nextLevelPaddle","angleChange","gameState","gameLost","resume","pause","allReducers","combineReducers","store","createStore","appStore","appState","getState","Main","props","tickHandler","tickStart","subscription","bounceSound","hitBlockSound","onMouseMove","bind","onMouseClick","onPlayAgain","onKeyUp","this","requestAnimationFrame","addEventListener","subscribe","applicationState","setState","cancelAnimationFrame","Howl","src","removeEventListener","e","code","dispatch","clientX","paddleBounceAction","playBounce","find","playHitBlock","updatedState","sourceObject","referenceObject","newObject","Object","keys","key","referenceObjectKeyValue","sourceObjectKeyValue","getUpdatedOjbect","play","position","borderColor","borderStyle","display","justifyContent","flexDirection","backgroundColor","newPosition","positionStyle","borderRadius","backgroundImage","style","gameScorebarStyle","marginLeft","gameFieldStyle","map","index","ballStyle","alignSelf","onClick","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.d4363a6e.chunk.js","sourcesContent":["/**\r\n * Provides game dimensions.\r\n */\r\n\r\nimport { WindowResizeConstant } from \"./Constants/Constants\";\r\nimport { GameDimensions } from \"./State/GameDimensions\";\r\n\r\nlet gameDimensions: GameDimensions;\r\n\r\nexport const getGameDimensions = (): GameDimensions => {\r\n    if (!gameDimensions) {\r\n        let size = 0;\r\n\r\n        if (window.innerHeight > window.innerWidth) {\r\n            size = window.innerWidth * WindowResizeConstant;\r\n        } else {\r\n            size = window.innerHeight * WindowResizeConstant;\r\n        }\r\n\r\n        const left = (window.innerWidth / 2) - (size / 2);\r\n        const top = (window.innerHeight / 2) - (size / 2);\r\n\r\n        gameDimensions = { left, top, size };\r\n    }\r\n\r\n    return gameDimensions;\r\n};","export enum GameActions {\r\n    /**\r\n     * An action that instructs the reducers to return an initial objects to play the game.\r\n     */\r\n    reset,\r\n    /**\r\n     * Dispatched when a block is hit.\r\n     */\r\n    hitBlock,\r\n    /**\r\n     * Dispatched when the user moves the mouse causing th paddle to move.\r\n     */\r\n    paddleMove,\r\n    /**\r\n     * Dispatch for a game tick.\r\n     */\r\n    tick,\r\n    /**\r\n     * Dispatchen when the ball bounces of top or bottom of an object.\r\n     */\r\n    ballBounceHorizantally,\r\n    /**\r\n     * Dispatched when the ball bounces of the side of an object.\r\n     */\r\n    ballBounceVertically,\r\n    /**\r\n     * Dispatched when the ball hits the bottom of the play field.\r\n     */\r\n    gameLost,\r\n    /**\r\n     * Dispatched when all the blocks are cleared.\r\n     */\r\n    nextLevel,\r\n    /**\r\n     * Resume the game.\r\n     */\r\n    resume,\r\n    pause\r\n}","\r\n/**\r\n * A constants used to convert the angle from degree's to radians.\r\n */\r\nexport const DegreeToRadian = Math.PI / 180;\r\n\r\n/**\r\n * A constants that contains the time in milli second for a frame.\r\n */\r\nexport const GameTick = 1000 / 60;\r\n\r\n/**\r\n * Constants for the initial ball velocity.\r\n */\r\nexport const InitialBallVelocity = 10;\r\n\r\n/**\r\n * Constants used in a calculation to randomize the ball's initial angle.\r\n */\r\nexport const BallAngleStartRandomFactor = 10;\r\n\r\n/**\r\n * Constants used in calculation the width and height of the ball relative to the game field diminsions.\r\n */\r\nexport const BallResizeFactor = 0.02;\r\n\r\n/**\r\n * A Constants used ina calculation to increase or decrease the angle of the ball depending on where it hits the paddle.\r\n */\r\nexport const BounceAngleIncreaseConstant = 40;\r\n\r\n/**\r\n * Constant to used to calculate the size of the playing field.\r\n */\r\nexport const WindowResizeConstant = 0.9;\r\n\r\n/**\r\n * Used to calculate the paddle with relative to the game field width.\r\n */\r\nexport const PaddleWithFactor = 40;\r\n\r\n/**\r\n * Used to calculate the height of the paddle relative to the game field height.\r\n */\r\nexport const PaddleHeightFactor = 10;\r\n\r\n/**\r\n * Used to calculate the paddle's top coordinate relative to the game field height.\r\n */\r\nexport const PaddlePositionFactor = 0.9;\r\n\r\n/**\r\n * Speed increase factor for each hit block\r\n */\r\nexport const BallSpeedIncreasePerBlock = 1.02;\r\n\r\n/**\r\n * Speed increase factor for each level.\r\n */\r\nexport const BallSpeedIncreasePerLevel = 0.5;\r\n\r\n/**\r\n * Border color\r\n */\r\nexport const GameFieldBorderColor = \"#2c1145\";\r\n\r\n/**\r\n * The paddle color\r\n */\r\nexport const PaddleColor = \"#8b25ae\";","\r\n/**\r\n * A constant object that has an object for each wall. Used to eliminate double bounces.\r\n */\r\nexport const Walls = {\r\n    /**\r\n     * Reference constant for the left wall.\r\n     */\r\n    leftWall: {},\r\n\r\n    /**\r\n     * Reference constants for the right wall\r\n     */\r\n    rightWall: {},\r\n\r\n    /**\r\n     * Reference constant for the top wall.\r\n     */\r\n    topWall: {},\r\n\r\n    /**\r\n     * Reference constant for the bottom wall.\r\n     */\r\n    bottomWall: {}\r\n};","/**\r\n * This is a library module that contains functions user throughout the entire game.\r\n */\r\n\r\nimport { BallAngleStartRandomFactor, BounceAngleIncreaseConstant, DegreeToRadian } from \"./Constants/Constants\";\r\nimport { Ball } from \"./Definitions/Ball\";\r\nimport { Block } from \"./Definitions/Block\";\r\nimport { ScreenObject } from \"./Definitions/ScreenObject\";\r\nimport { Direction, hitSide as HitSide } from \"./Definitions/Types\";\r\nimport { GameActions } from \"./State/GameActions\";\r\n\r\n/**\r\n * Returns the initial block setup.\r\n * @param {number} numberOfBlockRows. The amount of rows to add to the block array.\r\n * @param {number} numberOfBlockColumns. The mount of columns to add to the block array.\r\n * @returns {Block[]}. A 1d array that contains block objects.\r\n */\r\nexport const getBlocks = (numberOfBlockRows: number, numberOfBlockColumns: number): Block[] => {\r\n\r\n    const blocks: Block[] = [];\r\n    for (let r = 0; r < numberOfBlockRows; r++) {\r\n        for (let c = 0; c < numberOfBlockColumns; c++) {\r\n\r\n            const red = Math.ceil(Math.random() * 70);\r\n            const green = Math.ceil(Math.random() * 200);\r\n\r\n            let trans = Math.random();\r\n            if (trans < 0.5) {\r\n                trans = 1;\r\n            }\r\n            const block: Block = {\r\n                color: `rgba(${red}, ${green}, 120, ${trans})`,\r\n                x: c,\r\n                y: r,\r\n                left: 0,\r\n                top: 0,\r\n                height: 0,\r\n                width: 0,\r\n                hit: false\r\n            };\r\n\r\n            blocks.push(block);\r\n        }\r\n    }\r\n\r\n    return blocks;\r\n};\r\n\r\n/**\r\n * Checks if two shapes overlap\r\n * @param {ScreenObject} shape1. A Shape.\r\n * @param {ScreenObject} shape2. A Shape\r\n * @returns {boolean}. True if the shapes overlap, false otherwise.\r\n */\r\nexport const overlaps = (shape1: ScreenObject, shape2: ScreenObject): boolean => {\r\n\r\n    const left1 = Math.ceil(shape1.left);\r\n    const right1 = Math.floor(shape1.left + shape1.width);\r\n    const top1 = Math.ceil(shape1.top);\r\n    const bottom1 = Math.floor(shape1.top + shape1.height);\r\n\r\n    const left2 = Math.ceil(shape2.left);\r\n    const right2 = Math.floor(shape2.left + shape2.width);\r\n    const top2 = Math.ceil(shape2.top);\r\n    const bottom2 = Math.floor(shape2.top + shape2.height);\r\n\r\n    if (bottom1 < top2 || top1 > bottom2) {\r\n        return false;\r\n    }\r\n\r\n    if (right2 < left1 || left2 > right1) {\r\n        return false;\r\n    }\r\n\r\n    // Rectangles overlap\r\n    return true;\r\n};\r\n\r\n/**\r\n * Randomizes an angle.\r\n * @returns {number}. A number that can be added to an angle to slightly change it.\r\n */\r\nexport const angleRandomizer = (): number => {\r\n    const angleManipulator = (Math.random() * BallAngleStartRandomFactor);\r\n    if (Math.random() >= 0.5) {\r\n        return angleManipulator;\r\n    } else {\r\n        return angleManipulator * -1;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the bounce action depending on the balls heading an screen object's position.\r\n * @param {Ball} ball. A ball object.\r\n * @param {Shape} shape. Any game object that derives from ScreenObject.\r\n * @returns {GameActions.ballBounceHorizantally | GameActions.ballBounceVertically }. A ball can bounce vertically or horizantally.\r\n */\r\nexport const getBounceAction = (ball: Ball, shape: ScreenObject): GameActions.ballBounceHorizantally | GameActions.ballBounceVertically => {\r\n    const hitSide = getHitSide(ball, shape);\r\n\r\n    if (hitSide === \"left\" || hitSide === \"right\") {\r\n        return GameActions.ballBounceVertically;\r\n    } else if (hitSide === \"top\" || hitSide === \"bottom\") {\r\n        return GameActions.ballBounceHorizantally;\r\n    } else {\r\n        // tslint:disable-next-line: no-console\r\n        console.log(\"Failed hit detection\");\r\n        return GameActions.ballBounceHorizantally;\r\n    }\r\n};\r\n\r\n/**\r\n * Determine the right action to dispatch when the ball bounces off an object.\r\n * @param {Ball} ball. Ball object.\r\n * @param {ScreenObject} shape. A shape object.\r\n * @returns {HitSide}. The side where the ball would bounce based on its current position and the shape's position.\r\n */\r\nexport const getHitSide = (ball: Ball, shape: ScreenObject): HitSide => {\r\n\r\n    const shapeLeft = shape.left;\r\n    const shapeRight = shape.left + shape.width;\r\n    const shapeTop = shape.top;\r\n    const shapeBottom = shape.top + shape.height;\r\n\r\n    const ballLeft = ball.left;\r\n    const ballRight = ball.left + ball.width;\r\n\r\n    const ballTop = ball.top;\r\n    const ballBottom = ball.top + ball.height;\r\n\r\n    const withinVerticalBounds = (ballBottom > shapeTop && ballTop < shapeBottom);\r\n    const withinHorizantalBounds = (ballRight > shapeLeft && ballLeft < shapeRight);\r\n\r\n    const directions = getDirectionFromAngle(ball.angle);\r\n\r\n    const goingLeft = directions.some((d) => d === \"left\");\r\n    const goingRight = directions.some((d) => d === \"right\");\r\n    const goingUp = directions.some((d) => d === \"up\");\r\n    const goingDown = directions.some((d) => d === \"down\");\r\n\r\n    // Most times the top or bottom of a ScreenObject will be hit so check those first.\r\n    if (goingUp && withinHorizantalBounds) {\r\n        return \"bottom\";\r\n        // bottom\r\n    } else if (goingDown && withinHorizantalBounds) {\r\n        // Top\r\n        return \"top\";\r\n    } else if (goingLeft && withinVerticalBounds) {\r\n        // Right\r\n        return \"right\";\r\n    } else if (goingRight && withinVerticalBounds) {\r\n        // Left\r\n        return \"left\";\r\n    } else {\r\n        return undefined;\r\n    }\r\n};\r\n\r\n/**\r\n * Changes the angle based on the position of impact.\r\n * @param {Ball} ball. A ball object\r\n * @param {Paddle} paddle. A paddle object\r\n * @returns {number}. An angle that is slightly altered.\r\n */\r\nexport const changeAngle = (ball: ScreenObject, paddle: ScreenObject): number => {\r\n    const p = Math.abs(ball.left - paddle.left);\r\n\r\n    // calculate a factor based on the shape's width. Since this is a horizantol hit, this results in a\r\n    // number between 0 and 1.\r\n    const v = p / paddle.width;\r\n    const returnValue = BounceAngleIncreaseConstant * (0.5 - v) * -1;\r\n    return returnValue;\r\n};\r\n\r\n/**\r\n * Get next Y (position)\r\n * @param {number} angle. The angle of an object.\r\n * @param {number} distance. The distance the object will travel.\r\n * @param {number} currentY. The current Y coordinate of the object.\r\n * @returns {number}. The next Y position based on the object's angle and 'speed'.\r\n */\r\nexport const getNextY = (angle: number, distance: number, currentY: number) => {\r\n    return Math.sin(angle * DegreeToRadian * -1) * distance + currentY;\r\n};\r\n\r\n/**\r\n * Get next X (position)\r\n * @param {number} angle. The angle of an object.\r\n * @param {number} distance. The distance the object will travel.\r\n * @param {number} currentY. The current X coordinate of the object.\r\n * @returns {number}. The next X position based on the object's angle and 'speed'.\r\n */\r\nexport const getNextX = (angle: number, distance: number, currentX: number) => {\r\n    return Math.cos(angle * DegreeToRadian * -1) * distance + currentX;\r\n};\r\n\r\n/**\r\n * Get the directions from an angle\r\n * @param {number} angle. The angle of an object.\r\n * @returns {Direction[]}. The directions the object is traveling in. e.g. Down-left, or Up-right.\r\n */\r\nexport const getDirectionFromAngle = (angle: number): Direction[] => {\r\n\r\n    // A ball can travel at two directions at most so the return\r\n    // Value has to be an array with a size of 1 or two.\r\n    const returnValue: Direction[] = [];\r\n\r\n    const x = getNextX(angle, 10, 0);\r\n    const y = getNextY(angle, 10, 0);\r\n\r\n    if (x > 0) {\r\n        // Ball travels to the right\r\n        returnValue.push(\"right\");\r\n    }\r\n\r\n    if (x < 0) {\r\n        // Ball travels to the left.\r\n        returnValue.push(\"left\");\r\n    }\r\n\r\n    if (y > 0) {\r\n        // Ball travels down.\r\n        returnValue.push(\"down\");\r\n    }\r\n\r\n    if (y < 0) {\r\n        returnValue.push(\"up\");\r\n    }\r\n\r\n    return returnValue;\r\n};\r\n\r\n/**\r\n * Compares the key value of the referenceObject to the sourceObject.\r\n * This function is used to sync the Redux state to the Main object State.\r\n * @param {any} sourceObject. Can be any object.\r\n * @param {any} referenceObject. Can be any object.\r\n * @returns {any}. Updated object.\r\n */\r\nexport const getUpdatedOjbect = (sourceObject: any, referenceObject: any): any => {\r\n    const newObject: any = {};\r\n    Object.keys(sourceObject).forEach((key: string) => {\r\n\r\n        // Get the objects using the key values from the application state.\r\n        const referenceObjectKeyValue = referenceObject[key];\r\n        const sourceObjectKeyValue = sourceObject[key];\r\n\r\n        // Check if the objects have the same reference, if not expand the state object\r\n        if (referenceObjectKeyValue !== sourceObjectKeyValue) {\r\n            newObject[key] = sourceObjectKeyValue;\r\n        }\r\n    });\r\n\r\n    if (Object.keys(newObject).length > 0) {\r\n        return newObject;\r\n    } else {\r\n        return undefined;\r\n    }\r\n};","import { Paddle } from \"../Definitions/Paddle\";\r\n\r\n/**\r\n * A constant that contains type guards.\r\n */\r\nexport const Guard = {\r\n\r\n    /**\r\n     * Typeguard for determining if a shape is actually the paddle.\r\n     * @returns {boolean}. True if the object is a paddle, false otherwise.\r\n     */\r\n    isPaddle: (value: any): value is Paddle => {\r\n        return value && value.isPaddle;\r\n    }\r\n};","import { BallResizeFactor, BallSpeedIncreasePerBlock, BallSpeedIncreasePerLevel, InitialBallVelocity } from \"../Constants/Constants\";\r\nimport { Ball } from \"../Definitions/Ball\";\r\nimport { ScreenObject } from \"../Definitions/ScreenObject\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { Guard } from \"../Guards/Guard\";\r\nimport { angleRandomizer, changeAngle, getNextX, getNextY } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles ball actions.\r\n * @param {ball} state. The current ball state.\r\n * @param {ActionPayLoad}. An action, payload optional.\r\n * @returns {Ball}. The ball state.\r\n */\r\nexport const ballReducer = (state: Ball = getNewState(), action: ActionPayload<ScreenObject>): Ball => {\r\n\r\n    switch (action.type) {\r\n        case GameActions.reset: {\r\n            return getNewState();\r\n        }\r\n\r\n        case GameActions.tick: {\r\n            const x = getNextX(state.angle, state.velocity, state.left);\r\n            const y = getNextY(state.angle, state.velocity, state.top);\r\n\r\n            return { ...state, left: x, top: y };\r\n        }\r\n\r\n        case GameActions.ballBounceHorizantally:\r\n        case GameActions.ballBounceVertically: {\r\n            if (action.payload && action.payload !== state.lastObject) {\r\n                let angle = state.angle;\r\n                let angleChange = 1;\r\n\r\n                if (action.type === GameActions.ballBounceHorizantally) {\r\n\r\n                    // If the baddle is hit we want the ball's angle to increase if it hit\r\n                    // the edges.\r\n                    if (Guard.isPaddle(action.payload)) {\r\n                        // calculate where the ball hit relative to the shape from the left size.\r\n                        angleChange = changeAngle(state, action.payload);\r\n                    }\r\n\r\n                    // When the ball top or bottom makes contact, multiply the current angle by -1 for it to bounce.\r\n                    angle = (angle + angleChange) * -1;\r\n                } else {\r\n                    if (action.payload && action.payload !== state.lastObject) {\r\n                        // If the ball hits a side, the new angle is 180 - current angle.\r\n                        angle = 180 - angle;\r\n                    }\r\n                }\r\n\r\n                return { ...state, angle, lastObject: action.payload };\r\n            }\r\n\r\n            return state;\r\n        }\r\n\r\n        case GameActions.hitBlock:\r\n            // Increase the ball speed for each hit block\r\n            return { ...state, velocity: state.velocity * BallSpeedIncreasePerBlock };\r\n        case GameActions.nextLevel:\r\n            // Increase ball speed for each level.\r\n            return { ...state, velocity: state.velocity + BallSpeedIncreasePerLevel };\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the ball size that fits the screen size.\r\n * @returns {number}. The size of the ball.\r\n */\r\nconst getBallSize = (): number => {\r\n    return gameDimensions.size * BallResizeFactor;\r\n};\r\n\r\n/**\r\n * Calculate the ball position in the center of the game field.\r\n * @returns {number}. The ball's X or Y coordinate.\r\n */\r\nconst getBallPositionX = (): number => {\r\n    return gameDimensions.size / 2 - gameDimensions.size * BallResizeFactor / 2;\r\n};\r\n\r\n/**\r\n * Calculate the ball position in the center of the game field.\r\n * @returns {number}. The ball's X or Y coordinate.\r\n */\r\nconst getBallPositionY = (): number => {\r\n    return gameDimensions.size / 1.5 - gameDimensions.size * BallResizeFactor / 2;\r\n};\r\n\r\n/**\r\n * Used to obtain a new state for the ball.\r\n * @returns {Ball}. A new ball state.\r\n */\r\nconst getNewState = (): Ball => {\r\n    const angle = 90 + angleRandomizer();\r\n    return {\r\n        angle,\r\n        color: \"radial-gradient(yellow, orange, brown)\",\r\n        height: getBallSize(),\r\n        width: getBallSize(),\r\n        left: getBallPositionX(),\r\n        top: getBallPositionY(),\r\n        velocity: InitialBallVelocity,\r\n        lastObject: {},\r\n    };\r\n};\r\n","import { Block } from \"../Definitions/Block\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { getBlocks } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\nimport { BlockState } from \"../Definitions/BlockState\";\r\n\r\n/**\r\n * The block reducer.\r\n * @param {BlockState} state. The current block state.\r\n * @param {ActionPayload} action. An action, payload optional.\r\n * @returns {BlockState}. A 'new' block state.\r\n */\r\nexport const blockReducer = (state: BlockState = getNewState(), action: ActionPayload<Block>): BlockState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n            return getNewState();\r\n        case GameActions.nextLevel:\r\n\r\n            if (state.rows <= 10) {\r\n                // Increase the number of blocks until we hit 10 rows.\r\n                const nextLevelState = getNewState(state.rows + 1, state.columns + 1);\r\n                return nextLevelState;\r\n            } else {\r\n                return getNewState(state.rows, state.columns);\r\n            }\r\n\r\n        case GameActions.hitBlock:\r\n            if (action.payload && action.payload) {\r\n                const hitBlockState = [...state.blocks];\r\n                const hitBlockIndex = hitBlockState.indexOf(action.payload);\r\n\r\n                hitBlockState[hitBlockIndex].hit = true;\r\n\r\n                return { ...state, blocks: hitBlockState };\r\n            }\r\n\r\n            return state;\r\n\r\n        case GameActions.tick:\r\n\r\n            const hitBlocks = state.blocks.filter((b) => b.hit === true);\r\n\r\n            if (hitBlocks.length > 0) {\r\n\r\n                // Reduce a hit block by 10% of its original height\r\n                const widthReductionFactor = calculateBlockWidth(state.columns) * 0.1;\r\n                const heightReductionFactor = calculateBlockHeight(state.rows) * 0.1;\r\n\r\n                const tickBlocks = [...state.blocks];\r\n\r\n                // Redcue size for a hit block\r\n                hitBlocks.forEach((block) => {\r\n\r\n                    block.width -= widthReductionFactor;\r\n                    block.height -= heightReductionFactor;\r\n\r\n                    // Add half of the mount of pixels to the top and left to make it appear as the block shrinks to its center.\r\n                    block.top += heightReductionFactor / 2;\r\n                    block.left += widthReductionFactor / 2;\r\n\r\n                    const hitBlockIndex = tickBlocks.indexOf(block);\r\n\r\n                    if (block.height <= 0 || block.width <= 0) {\r\n                        // Block has reached size '0', time to remove it.\r\n                        tickBlocks.splice(hitBlockIndex, 1);\r\n                    }\r\n\r\n                });\r\n\r\n                return { ...state, blocks: tickBlocks };\r\n            } else {\r\n                return state;\r\n            }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets a new state for the blocks.\r\n * @param {number} rows. The number of rows the new state should have.\r\n * @param {number} columns. The number of columns the new state should have. Also used to calculate the block size.\r\n * @returns {BlockState}. A new block state.\r\n */\r\nconst getNewState = (rows: number = 5, columns: number = 12): BlockState => {\r\n    const blocks = getBlocks(rows, columns);\r\n\r\n    const width = calculateBlockWidth(columns);\r\n    const height = calculateBlockHeight(columns);\r\n\r\n    blocks.forEach((b) => {\r\n        b.width = width;\r\n        b.height = height;\r\n        b.left = b.x * width;\r\n        b.top = b.y * height;\r\n    });\r\n\r\n    return {\r\n        blocks,\r\n        columns,\r\n        rows,\r\n        height,\r\n        width\r\n    };\r\n};\r\n\r\n/**\r\n * Calculates the height of a block using the screen size and the number of rows.\r\n * @param {number} rows. Amount of rows.\r\n * @returns {number}. The height of a block based on the amount of colums.\r\n */\r\nfunction calculateBlockHeight(columns: number): number {\r\n    // The simples way to draw rectangles is to half the width.\r\n    return calculateBlockWidth(columns) / 2;\r\n}\r\n\r\n/**\r\n * Calculats the width of a block using the screensize.\r\n * @param {number} columns. Amount of colums.\r\n * @returns {number}. The block width based on the amount of colums.\r\n */\r\nfunction calculateBlockWidth(columns: number): number {\r\n    const size = getGameDimensions().size;\r\n    return size / columns;\r\n}\r\n","import { Action } from \"redux\";\r\nimport { GameState } from \"../Definitions/GameState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\n/**\r\n * game state reducer. Keeps track of score, losing a game, etc.\r\n * @param {GameState} state. The current game state\r\n * @param {Action}. A reduc action. No payload.\r\n * @returns {GameState}. The next game state.\r\n */\r\nexport const gameStateReducer = (state: GameState = getNewState(), action: Action<GameActions>): GameState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n            return getNewState();\r\n        case GameActions.gameLost:\r\n            return { ...state, gameMode: \"ended\" };\r\n        case GameActions.nextLevel:\r\n            return { ...state, level: state.level + 1 };\r\n        case GameActions.hitBlock:\r\n            return { ...state, score: state.score + 1 };\r\n        case GameActions.resume:\r\n            return { ...state, gameMode: \"running\" };\r\n        case GameActions.pause:\r\n            return { ...state, gameMode: \"paused\" };\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Creates a new GameState state\r\n * @returns {GameState}. A new game state.\r\n */\r\nconst getNewState = (): GameState => {\r\n    return { gameMode: \"paused\", level: 1, score: 0 };\r\n};\r\n","\r\nimport { PaddleColor, PaddleHeightFactor, PaddlePositionFactor, PaddleWithFactor } from \"../Constants/Constants\";\r\nimport { Paddle } from \"../Definitions/Paddle\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles paddle actions\r\n * @param {Paddle} state. The paddle state.\r\n * @param {ActionPayload<number> }action. An action to be performed on the paddle. Number is the 'left' coordinate of the paddle.\r\n * @returns {Paddle}. Paddle state.\r\n */\r\nexport const paddleReducer = (state: Paddle = getNewState(), action: ActionPayload<number>): Paddle => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n\r\n            return getNewState();\r\n\r\n        case GameActions.paddleMove:\r\n\r\n            // Prevent the paddle from being drawn outside the playfield.\r\n            if (typeof (action.payload) !== \"undefined\") {\r\n\r\n                let x;\r\n\r\n                if (action.payload - state.width / 2 <= 0) {\r\n                    x = 0;\r\n                } else if (action.payload - state.width / 2 >= (gameDimensions.size - state.width)) {\r\n                    x = gameDimensions.size - state.width;\r\n                } else {\r\n                    x = action.payload - (state.width / 2);\r\n                }\r\n\r\n                if (state.left === x) {\r\n                    return state;\r\n                } else {\r\n                    const newState = { ...state, left: x };\r\n                    return newState;\r\n                }\r\n            } else {\r\n                return state;\r\n            }\r\n\r\n        case GameActions.nextLevel:\r\n            const nextLevelPaddle = { ...state };\r\n\r\n            // Redude the paddle size each level by 5%\r\n            nextLevelPaddle.width *= 0.95;\r\n\r\n            if (nextLevelPaddle.width < gameDimensions.size / PaddleHeightFactor / 2) {\r\n                // Paddle doesn't get smaller than half its size.\r\n                return state;\r\n            } else {\r\n                return nextLevelPaddle;\r\n            }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Generates a new state for the paddle\r\n * @returns {Paddle}. A new state for the paddle\r\n */\r\nconst getNewState = (): Paddle => {\r\n    return {\r\n        color: PaddleColor,\r\n        width: gameDimensions.size / PaddleHeightFactor,\r\n        height: gameDimensions.size / PaddleWithFactor,\r\n        top: gameDimensions.size * PaddlePositionFactor,\r\n        left: (gameDimensions.size / 2) - (gameDimensions.size / PaddleHeightFactor / 2),\r\n        isPaddle: true\r\n    };\r\n};","import { combineReducers, createStore, ReducersMapObject, Store } from \"redux\";\r\nimport { ballReducer } from \"../Reducers/BallReducer\";\r\nimport { blockReducer } from \"../Reducers/BlockReducer\";\r\nimport { gameStateReducer } from \"../Reducers/GameStateReducer\";\r\nimport { paddleReducer } from \"../Reducers/PaddleReducer\";\r\nimport ActionPayload from \"./ActionPayLoad\";\r\nimport { AppState } from \"./AppState\";\r\n\r\n/**\r\n * All reducer that build the application state.\r\n */\r\nconst reducers: ReducersMapObject<AppState, ActionPayload<any>> = {\r\n    blockState: blockReducer,\r\n    paddle: paddleReducer,\r\n    ball: ballReducer,\r\n    gameState: gameStateReducer,\r\n};\r\n\r\nconst allReducers = combineReducers(reducers);\r\n\r\nconst store = createStore<AppState, ActionPayload<any>, AppState, AppState>(allReducers);\r\n\r\n/**\r\n * Returns the store\r\n * @returns {Store}. The redux store.\r\n */\r\nexport const appStore = (): Store<AppState, ActionPayload<any>> => {\r\n    return store;\r\n};\r\n\r\n/**\r\n * Returns the State\r\n * @returns {AppState}. The application state.\r\n */\r\nexport const appState = (): AppState => {\r\n    return appStore().getState();\r\n};","import { Howl } from \"howler\";\nimport React, { CSSProperties } from \"react\";\nimport { Bounce, HitBlock } from \"../Constants/Base64Audio\";\nimport { GameFieldBorderColor, GameTick } from \"../Constants/Constants\";\nimport { Walls } from \"../Constants/WallConstants\";\nimport { Ball } from \"../Definitions/Ball\";\nimport { GameObject } from \"../Definitions/GameObject\";\nimport { getGameDimensions } from \"../GameDimensions\";\nimport { getBounceAction, getUpdatedOjbect, overlaps } from \"../Lib\";\nimport { AppState } from \"../State/AppState\";\nimport { GameActions } from \"../State/GameActions\";\nimport { appState, appStore } from \"../State/Store\";\n\nconst gameDimensions = getGameDimensions();\n\n/**\n * Main game component.\n */\nexport class Main extends React.Component<{}, AppState> {\n\n    /**\n     * Stores a reference to the animation that draws the game.\n     */\n    private tickHandler?: number;\n\n    /**\n     * Used to store the beginning of a game tick.\n     */\n    private tickStart?: number;\n\n    /**\n     * Refux subscription\n     */\n    private subscription?: () => void;\n\n    /**\n     * The bounce sound.\n     */\n    private bounceSound!: Howl;\n\n    /**\n     * The sound when the ball hits a block\n     */\n    private hitBlockSound!: Howl;\n\n    /**\n     * Initializes the Main component.\n     */\n    constructor(props: object) {\n        super(props);\n\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.onMouseClick = this.onMouseClick.bind(this);\n        this.tick = this.tick.bind(this);\n        this.onPlayAgain = this.onPlayAgain.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n\n        // Sync the redux state with the component state.\n        this.state = appState();\n    }\n\n    /**\n     * Called when the component mounted.\n     */\n    public componentDidMount(): void {\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n\n        window.addEventListener(\"mousemove\", this.onMouseMove);\n        window.addEventListener(\"click\", this.onMouseClick);\n        window.addEventListener(\"keyup\", this.onKeyUp);\n\n        this.subscription = appStore().subscribe(() => {\n            const applicationState = appState();\n\n            if (applicationState.gameState !== this.state.gameState) {\n                this.setState({ gameState: applicationState.gameState });\n\n                if (applicationState.gameState.gameMode === \"ended\") {\n                    if (this.tickHandler) {\n                        window.cancelAnimationFrame(this.tickHandler);\n                    }\n                }\n            }\n        });\n\n        this.bounceSound = new Howl({ src: [\"data:audio/wav;base64,\" + Bounce] });\n        this.hitBlockSound = new Howl({ src: [\"data:audio/wav;base64,\" + HitBlock] });\n    }\n\n    /**\n     * Called before the component unmounts.\n     */\n    public componentWillUnmount(): void {\n        if (this.tickHandler) {\n            window.cancelAnimationFrame(this.tickHandler);\n        }\n\n        window.removeEventListener(\"mousemove\", this.onMouseMove);\n        window.removeEventListener(\"click\", this.onMouseClick);\n\n        if (this.subscription) {\n            this.subscription();\n            delete this.subscription;\n        }\n    }\n\n    private onKeyUp(e: KeyboardEvent): void {\n        switch (e.code) {\n            case \"KeyW\":\n                appStore().dispatch({ type: GameActions.nextLevel });\n                break;\n            case \"Space\":\n                appStore().dispatch({ type: GameActions.pause });\n                break;\n\n        }\n    }\n\n    /**\n     * Handles mouse movement. Used to move the paddle.\n     * @param {MouseEvent} e. MouseEvent.\n     */\n    private onMouseMove(e: MouseEvent): void {\n        if (e) {\n            const x = e.clientX - gameDimensions.left;\n            appStore().dispatch({ type: GameActions.paddleMove, payload: x });\n        }\n    }\n\n    /**\n     * Event fires when the user clicks the mouse.\n     */\n    private onMouseClick(): void {\n        if (this.state.gameState.gameMode === \"paused\") {\n            appStore().dispatch({ type: GameActions.resume });\n            this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n        }\n    }\n\n    /**\n     * Handles a play again click.\n     */\n    private onPlayAgain(): void {\n        // Reset game state.\n        appStore().dispatch({ type: GameActions.reset });\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Handles a game tick.\n     * @param {number} tick. Current tick count.\n     */\n    public tick(tick: number): void {\n\n        if (!this.tickStart) {\n            this.tickStart = tick;\n        }\n\n        if (this.state.gameState.gameMode !== \"running\") {\n            return;\n        }\n\n        const diff = tick - this.tickStart;\n\n        // Redraw at 60 fps.\n        if (diff > GameTick) {\n            const ball = appState().ball;\n            const blocks = appState().blockState.blocks;\n            const paddle = appState().paddle;\n\n            if (blocks.length === 0) {\n                appStore().dispatch({ type: GameActions.nextLevel });\n            }\n\n            const paddleHit = overlaps(ball, paddle);\n\n            if (paddleHit) {\n                const paddleBounceAction = getBounceAction(ball, paddle);\n                appStore().dispatch({ type: paddleBounceAction, payload: paddle });\n\n                this.playBounce();\n\n            } else if (blocks) {\n\n                const hitBlock = blocks.find((b) => overlaps(ball, b) && b.hit === false);\n                if (hitBlock) {\n\n                    this.playHitBlock();\n                    appStore().dispatch({ type: GameActions.hitBlock, payload: hitBlock });\n\n                    const action = getBounceAction(ball, hitBlock);\n\n                    if (typeof (action) !== \"undefined\") {\n                        appStore().dispatch({ type: action, payload: hitBlock });\n                    }\n\n                } else if (ball.top <= 0) {\n                    // The ball's top and left are inside the game field.\n                    // Use the game dimension object to store a wall hit.\n                    // Hit the top  wall\n                    appStore().dispatch({ type: GameActions.ballBounceHorizantally, payload: Walls.topWall });\n                    this.playBounce();\n\n                } else if (ball.left <= 0) {\n                    // Hit the left wall\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.leftWall });\n                    this.playBounce();\n\n                } else if (ball.left + ball.width >= gameDimensions.size) {\n                    // Hit the right wall\n\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.rightWall });\n                    this.playBounce();\n                } else if (ball.top + ball.width >= gameDimensions.size) {\n                    // Hit bottom wall.\n                    appStore().dispatch({ type: GameActions.gameLost });\n                }\n            }\n\n            appStore().dispatch({ type: GameActions.tick });\n\n            const updatedState = getUpdatedOjbect(appState(), this.state);\n            if (updatedState) {\n                this.setState(updatedState);\n            }\n            this.tickStart = tick;\n        }\n\n        this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n    private playHitBlock(): void {\n        this.hitBlockSound.play();\n    }\n\n    private playBounce(): void {\n\n        this.bounceSound.play();\n    }\n\n    /**\n     * Returns the styling for the game field.\n     * @returns {CSSProperties}. CSSProperties for the gamefield.\n     */\n    private gameFieldStyle(): CSSProperties | undefined {\n\n        return {\n            position: \"absolute\",\n            left: getGameDimensions().left,\n            top: getGameDimensions().top,\n            width: getGameDimensions().size,\n            height: getGameDimensions().size,\n            borderColor: GameFieldBorderColor,\n            borderStyle: \"solid\",\n            display: \"flex\",\n            justifyContent: \"center\"\n        };\n    }\n\n    /**\n     * Game score style\n     * @returns {CSSProperties}. A style that will draw a rectangle above the game field.\n     */\n    private gameScorebarStyle(): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: getGameDimensions().left,\n            width: getGameDimensions().size,\n            top: getGameDimensions().top - 25,\n            height: 22,\n            borderColor: GameFieldBorderColor,\n            borderStyle: \"solid\",\n            display: \"flex\",\n            flexDirection: \"row\",\n        };\n    }\n\n    /**\n     * Returns css properties for positioning a shape.\n     * @param {ScreenObject} shape. A shape object.\n     * @returns {CSSProperties}. CSS properties for a shape.\n     */\n    private positionStyle(shape: GameObject): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: shape.left,\n            top: shape.top,\n            height: shape.height,\n            width: shape.width,\n            backgroundColor: shape.color,\n        };\n    }\n\n    /**\n     * Returns css properties for positioning and drawing the ball.\n     * @param {Ball} ball.\n     * @returns {CSSProperties}.\n     */\n    private ballStyle(ball: Ball): CSSProperties {\n        const newPosition = this.positionStyle(ball);\n        newPosition.borderRadius = \"50%\";\n        newPosition.backgroundImage = ball.color;\n        return newPosition;\n    }\n\n    /**\n     * Renders the component.\n     */\n    public render(): React.ReactNode {\n        return (\n            <div>\n                <div style={this.gameScorebarStyle()} >\n                    <div key={1} style={{ color: \"white\", justifyContent: \"center\", marginLeft: \"10px\" }}>Level: {this.state.gameState.level}</div>>\n                    <div key={2} style={{ color: \"white\", justifyContent: \"center\" }}>Score: {this.state.gameState.score}</div>>\n                </div>\n                <>\n                    {\n                        this.state.blockState && this.state.paddle && this.state.ball ?\n                            <div style={this.gameFieldStyle()}>\n                                {\n                                    this.state.blockState.blocks.map((b, index) => <div key={index} style={this.positionStyle(b)} />)\n                                }\n                                <div style={this.positionStyle(this.state.paddle)} />\n                                <div style={this.ballStyle(this.state.ball)} />\n                                {\n                                    this.state.gameState.gameMode === \"ended\" ?\n                                        <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"center\" }}>\n                                            <p style={{ alignSelf: \"center\", color: \"white\" }}>Game over</p>\n                                            <button onClick={this.onPlayAgain} style={{ alignSelf: \"center\" }}>Play again</button>\n                                        </div> :\n                                        this.state.gameState.gameMode === \"paused\" ?\n                                            <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"center\" }}>\n                                                <p style={{ alignSelf: \"center\", color: \"white\" }}>Click the left mouse button to resume.</p>\n                                            </div> : null\n                                }\n\n                            </div> : null\n                    }\n                </>\n            </div>\n        );\n    }\n}\n\nexport default Main;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Main from \"./Components/Main\";\n\nReactDOM.render(<Main />, document.getElementById(\"root\"));\n"],"sourceRoot":""}