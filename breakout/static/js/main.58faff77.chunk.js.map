{"version":3,"sources":["GameDimensions.ts","State/GameActions.ts","Constants.ts","Lib.ts","Guards/Guard.ts","Reducers/BallReducer.ts","Reducers/BlockReducer.ts","Reducers/GameStateReducer.ts","Reducers/PaddleReducer.ts","State/Store.ts","WallConstants.ts","Main.tsx","index.tsx"],"names":["gameDimensions","GameActions","DegreeToRadian","Math","PI","getGameDimensions","size","window","innerHeight","innerWidth","left","top","getBlocks","numberOfBlockRows","numberOfBlockColumns","blocks","r","c","red","ceil","random","green","trans","block","color","x","y","height","width","hit","push","overlaps","shape1","shape2","left1","right1","floor","top1","bottom1","left2","right2","top2","bottom2","getBounceAction","ball","shape","hitSide","getHitSide","ballBounceVertically","ballBounceHorizantally","console","log","shapeLeft","shapeRight","shapeTop","shapeBottom","ballLeft","ballRight","ballTop","withinVerticalBounds","withinHorizantalBounds","directions","getDirectionFromAngle","angle","goingLeft","some","d","goingRight","goingUp","goingDown","changeAngle","paddle","abs","getNextY","distance","currentY","sin","getNextX","currentX","cos","returnValue","Guard","value","isPaddle","getBallSize","getBallPosition","getNewState","angleManipulator","angleRandomizer","velocity","lastObject","rows","columns","calculateBlockWidth","calculateBlockHeight","forEach","b","gameMode","level","score","reducers","blockState","state","action","type","reset","nextLevel","nextLevelState","hitBlock","payload","hitBlockState","hitBlockIndex","indexOf","tick","hitBlocks","filter","length","widthReductionFactor","heightReductionFactor","tickBlocks","splice","paddleMove","newState","nextLevelPaddle","angleChange","gameState","gameLost","allReducers","combineReducers","store","createStore","appStore","appState","getState","Walls","leftWall","rightWall","topWall","bottomWall","Main","props","tickHandler","tickStart","subscription","onMouseMove","bind","onPlayAgain","onKeyUp","this","requestAnimationFrame","addEventListener","subscribe","applicationState","setState","cancelAnimationFrame","removeEventListener","e","code","dispatch","clientX","paddleBounceAction","find","updatedState","sourceObject","referenceObject","newObject","Object","keys","key","referenceObjectKeyValue","sourceObjectKeyValue","getUpdatedOjbect","position","borderColor","borderStyle","display","justifyContent","flexDirection","backgroundColor","newPosition","positionStyle","borderRadius","backgroundImage","style","gameScorebarStyle","marginLeft","gameFieldStyle","map","index","ballStyle","alignSelf","onClick","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.58faff77.chunk.js","sourcesContent":["/**\r\n * Provides game dimensions.\r\n */\r\n\r\nimport { WindowResizeConstant } from \"./Constants\";\r\nimport { GameDimensions } from \"./State/GameDimensions\";\r\n\r\nlet gameDimensions: GameDimensions;\r\n\r\nexport const getGameDimensions = (): GameDimensions => {\r\n    if (!gameDimensions) {\r\n        let size = 0;\r\n\r\n        if (window.innerHeight > window.innerWidth) {\r\n            size = window.innerWidth * WindowResizeConstant;\r\n        } else {\r\n            size = window.innerHeight * WindowResizeConstant;\r\n        }\r\n\r\n        const left = (window.innerWidth / 2) - (size / 2);\r\n        const top = (window.innerHeight / 2) - (size / 2);\r\n\r\n        gameDimensions = { left, top, size };\r\n    }\r\n\r\n    return gameDimensions;\r\n};","export enum GameActions {\r\n    /**\r\n     * An action that instructs the reducers to return an initial objects to play the game.\r\n     */\r\n    reset,\r\n\r\n    /**\r\n     * Dispatched when a block is hit.\r\n     */\r\n    hitBlock,\r\n\r\n    /**\r\n     * Dispatched when the user moves the mouse causing th paddle to move.\r\n     */\r\n    paddleMove,\r\n\r\n    /**\r\n     * Dispatch for a game tick.\r\n     */\r\n    tick,\r\n\r\n    /**\r\n     * Dispatchen when the ball bounces of top or bottom of an object.\r\n     */\r\n    ballBounceHorizantally,\r\n\r\n    /**\r\n     * Dispatched when the ball bounces of the side of an object.\r\n     */\r\n    ballBounceVertically,\r\n\r\n    /**\r\n     * Dispatched when the ball hits the bottom of the play field.\r\n     */\r\n    gameLost,\r\n\r\n    /**\r\n     * Dispatched when all the blocks are cleared.\r\n     */\r\n    nextLevel,\r\n}","\r\n/**\r\n * A constants used to convert the angle from degree's to radians.\r\n */\r\nexport const DegreeToRadian = Math.PI / 180;\r\n\r\n/**\r\n * A constants that contains the time in milli second for a frame.\r\n */\r\nexport const GameTick = 1000 / 60;\r\n\r\n/**\r\n * Constants for the initial ball velocity.\r\n */\r\nexport const InitialBallVelocity = 10;\r\n\r\n/**\r\n * Constants used in a calculation to randomize the ball's initial angle.\r\n */\r\nexport const BallAngleStartRandomFactor = 10;\r\n\r\n/**\r\n * Constants used in calculation the width and height of the ball relative to the game field diminsions.\r\n */\r\nexport const BallResizeFactor = 0.02;\r\n\r\n/**\r\n * A Constants used ina calculation to increase or decrease the angle of the ball depending on where it hits the paddle.\r\n */\r\nexport const BounceAngleIncreaseConstant = 40;\r\n\r\n/**\r\n * Constant to used to calculate the size of the playing field.\r\n */\r\nexport const WindowResizeConstant = 0.9;\r\n\r\n/**\r\n * Used to calculate the paddle with relative to the game field width.\r\n */\r\nexport const PaddleWithFactor = 40;\r\n\r\n/**\r\n * Used to calculate the height of the paddle relative to the game field height.\r\n */\r\nexport const PaddleHeightFactor = 10;\r\n\r\n/**\r\n * Used to calculate the paddle's top coordinate relative to the game field height.\r\n */\r\nexport const PaddlePositionFactor = 0.9;\r\n\r\n/**\r\n * Speed increase factor for each hit block\r\n */\r\nexport const BallSpeedIncreasePerBlock = 1.02;\r\n\r\n/**\r\n * Speed increase factor for each level.\r\n */\r\nexport const BallSpeedIncreasePerLevel = 0.5;\r\n\r\n/**\r\n * Border color\r\n */\r\nexport const GameFieldBorderColor = \"#2c1145\";\r\n\r\n/**\r\n * The paddle color\r\n */\r\nexport const PaddleColor = \"#8b25ae\";","/**\r\n * This is a library module that contains functions user throughout the entire game.\r\n */\r\n\r\n\r\nimport { BallAngleStartRandomFactor, BounceAngleIncreaseConstant, DegreeToRadian } from \"./Constants\";\r\nimport { Ball } from \"./Definitions/Ball\";\r\nimport { Block } from \"./Definitions/Block\";\r\nimport { ScreenObject } from \"./Definitions/ScreenObject\";\r\nimport { Direction, hitSide as HitSide } from \"./Definitions/Types\";\r\nimport { GameActions } from \"./State/GameActions\";\r\n\r\n/**\r\n * Returns the initial block setup.\r\n * @param {number} numberOfBlockRows. The amount of rows to add to the block array.\r\n * @param {number} numberOfBlockColumns. The mount of columns to add to the block array.\r\n * @returns {Block[]}. A 1d array that contains block objects.\r\n */\r\nexport const getBlocks = (numberOfBlockRows: number, numberOfBlockColumns: number): Block[] => {\r\n\r\n    const blocks: Block[] = [];\r\n    for (let r = 0; r < numberOfBlockRows; r++) {\r\n        for (let c = 0; c < numberOfBlockColumns; c++) {\r\n\r\n            const red = Math.ceil(Math.random() * 70);\r\n            const green = Math.ceil(Math.random() * 200);\r\n\r\n            let trans = Math.random();\r\n            if (trans < 0.5) {\r\n                trans = 1;\r\n            }\r\n            const block: Block = {\r\n                color: `rgba(${red}, ${green}, 120, ${trans})`,\r\n                x: c,\r\n                y: r,\r\n                left: 0,\r\n                top: 0,\r\n                height: 0,\r\n                width: 0,\r\n                hit: false\r\n            };\r\n\r\n            blocks.push(block);\r\n        }\r\n    }\r\n\r\n    return blocks;\r\n};\r\n\r\n/**\r\n * Checks if two shapes overlap\r\n * @param {ScreenObject} shape1. A Shape.\r\n * @param {ScreenObject} shape2. A Shape\r\n * @returns {boolean}. True if the shapes overlap, false otherwise.\r\n */\r\nexport const overlaps = (shape1: ScreenObject, shape2: ScreenObject): boolean => {\r\n\r\n    const left1 = Math.ceil(shape1.left);\r\n    const right1 = Math.floor(shape1.left + shape1.width);\r\n    const top1 = Math.ceil(shape1.top);\r\n    const bottom1 = Math.floor(shape1.top + shape1.height);\r\n\r\n    const left2 = Math.ceil(shape2.left);\r\n    const right2 = Math.floor(shape2.left + shape2.width);\r\n    const top2 = Math.ceil(shape2.top);\r\n    const bottom2 = Math.floor(shape2.top + shape2.height);\r\n\r\n    if (bottom1 < top2 || top1 > bottom2) {\r\n        return false;\r\n    }\r\n\r\n    if (right2 < left1 || left2 > right1) {\r\n        return false;\r\n    }\r\n\r\n    // Rectangles overlap\r\n    return true;\r\n};\r\n\r\n/**\r\n * Randomizes an angle.\r\n * @returns {number}. A number that can be added to an angle to slightly change it.\r\n */\r\nexport const angleRandomizer = (): number => {\r\n    const angleManipulator = (Math.random() * BallAngleStartRandomFactor);\r\n    if (Math.random() >= 0.5) {\r\n        return angleManipulator;\r\n    } else {\r\n        return angleManipulator * -1;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the bounce action depending on the balls heading an screen object's position.\r\n * @param {Ball} ball. A ball object.\r\n * @param {Shape} shape. Any game object that derives from ScreenObject.\r\n * @returns {GameActions.ballBounceHorizantally | GameActions.ballBounceVertically }. A ball can bounce vertically or horizantally.\r\n */\r\nexport const getBounceAction = (ball: Ball, shape: ScreenObject): GameActions.ballBounceHorizantally | GameActions.ballBounceVertically => {\r\n    const hitSide = getHitSide(ball, shape);\r\n\r\n    if (hitSide === \"left\" || hitSide === \"right\") {\r\n        return GameActions.ballBounceVertically;\r\n    } else if (hitSide === \"top\" || hitSide === \"bottom\") {\r\n        return GameActions.ballBounceHorizantally;\r\n    } else {\r\n        // tslint:disable-next-line: no-console\r\n        console.log(\"Failed hit detection\");\r\n        return GameActions.ballBounceHorizantally;\r\n    }\r\n};\r\n\r\n/**\r\n * Determine the right action to dispatch when the ball bounces off an object.\r\n * @param {Ball} ball. Ball object.\r\n * @param {ScreenObject} shape. A shape object.\r\n * @returns {HitSide}. The side where the ball would bounce based on its current position and the shape's position.\r\n */\r\nexport const getHitSide = (ball: Ball, shape: ScreenObject): HitSide => {\r\n\r\n    const shapeLeft = shape.left;\r\n    const shapeRight = shape.left + shape.width;\r\n    const shapeTop = shape.top;\r\n    const shapeBottom = shape.top + shape.height;\r\n\r\n    const ballLeft = ball.left;\r\n    const ballRight = ball.left + ball.width;\r\n\r\n    const ballTop = ball.top;\r\n    const ballBottom = ball.top + ball.height;\r\n\r\n    const withinVerticalBounds = (ballBottom > shapeTop && ballTop < shapeBottom);\r\n    const withinHorizantalBounds = (ballRight > shapeLeft && ballLeft < shapeRight);\r\n\r\n    const directions = getDirectionFromAngle(ball.angle);\r\n\r\n    const goingLeft = directions.some((d) => d === \"left\");\r\n    const goingRight = directions.some((d) => d === \"right\");\r\n    const goingUp = directions.some((d) => d === \"up\");\r\n    const goingDown = directions.some((d) => d === \"down\");\r\n\r\n    // Most times the top or bottom of a ScreenObject will be hit so check those first.\r\n    if (goingUp && withinHorizantalBounds) {\r\n        return \"bottom\";\r\n        // bottom\r\n    } else if (goingDown && withinHorizantalBounds) {\r\n        // Top\r\n        return \"top\";\r\n    } else if (goingLeft && withinVerticalBounds) {\r\n        // Right\r\n        return \"right\";\r\n    } else if (goingRight && withinVerticalBounds) {\r\n        // Left\r\n        return \"left\";\r\n    } else {\r\n        return undefined;\r\n    }\r\n};\r\n\r\n/**\r\n * Changes the angle based on the position of impact.\r\n * @param {Ball} ball. A ball object\r\n * @param {Paddle} paddle. A paddle object\r\n * @returns {number}. An angle that is slightly altered.\r\n */\r\nexport const changeAngle = (ball: ScreenObject, paddle: ScreenObject): number => {\r\n    const p = Math.abs(ball.left - paddle.left);\r\n\r\n    // calculate a factor based on the shape's width. Since this is a horizantol hit, this results in a\r\n    // number between 0 and 1.\r\n    const v = p / paddle.width;\r\n    const returnValue = BounceAngleIncreaseConstant * (0.5 - v) * -1;\r\n    return returnValue;\r\n};\r\n\r\n/**\r\n * Get next Y (position)\r\n * @param {number} angle. The angle of an object.\r\n * @param {number} distance. The distance the object will travel.\r\n * @param {number} currentY. The current Y coordinate of the object.\r\n * @returns {number}. The next Y position based on the object's angle and 'speed'.\r\n */\r\nexport const getNextY = (angle: number, distance: number, currentY: number) => {\r\n    return Math.sin(angle * DegreeToRadian * -1) * distance + currentY;\r\n};\r\n\r\n/**\r\n * Get next X (position)\r\n * @param {number} angle. The angle of an object.\r\n * @param {number} distance. The distance the object will travel.\r\n * @param {number} currentY. The current X coordinate of the object.\r\n * @returns {number}. The next X position based on the object's angle and 'speed'.\r\n */\r\nexport const getNextX = (angle: number, distance: number, currentX: number) => {\r\n    return Math.cos(angle * DegreeToRadian * -1) * distance + currentX;\r\n};\r\n\r\n/**\r\n * Get the directions from an angle\r\n * @param {number} angle. The angle of an object.\r\n * @returns {Direction[]}. The directions the object is traveling in. e.g. Down-left, or Up-right.\r\n */\r\nexport const getDirectionFromAngle = (angle: number): Direction[] => {\r\n\r\n    // A ball can travel at two directions at most so the return\r\n    // Value has to be an array with a size of 1 or two.\r\n    const returnValue: Direction[] = [];\r\n\r\n    const x = getNextX(angle, 10, 0);\r\n    const y = getNextY(angle, 10, 0);\r\n\r\n    if (x > 0) {\r\n        // Ball travels to the right\r\n        returnValue.push(\"right\");\r\n    }\r\n\r\n    if (x < 0) {\r\n        // Ball travels to the left.\r\n        returnValue.push(\"left\");\r\n    }\r\n\r\n    if (y > 0) {\r\n        // Ball travels down.\r\n        returnValue.push(\"down\");\r\n    }\r\n\r\n    if (y < 0) {\r\n        returnValue.push(\"up\");\r\n    }\r\n\r\n    return returnValue;\r\n};\r\n\r\n/**\r\n * Compares the key value of the referenceObject to the sourceObject.\r\n * This function is used to sync the Redux state to the Main object State.\r\n * @param {any} sourceObject. Can be any object.\r\n * @param {any} referenceObject. Can be any object.\r\n * @returns {any}. Updated object.\r\n */\r\nexport const getUpdatedOjbect = (sourceObject: any, referenceObject: any): any => {\r\n    const newObject: any = {};\r\n    Object.keys(sourceObject).forEach((key: string) => {\r\n\r\n        // Get the objects using the key values from the application state.\r\n        const referenceObjectKeyValue = referenceObject[key];\r\n        const sourceObjectKeyValue = sourceObject[key];\r\n\r\n        // Check if the objects have the same reference, if not expand the state object\r\n        if (referenceObjectKeyValue !== sourceObjectKeyValue) {\r\n            newObject[key] = sourceObjectKeyValue;\r\n        }\r\n    });\r\n\r\n    if (Object.keys(newObject).length > 0) {\r\n        return newObject;\r\n    } else {\r\n        return undefined;\r\n    }\r\n};","import { Paddle } from \"../Definitions/Paddle\";\r\n\r\n/**\r\n * A constant that contains type guards.\r\n */\r\nexport const Guard = {\r\n\r\n    /**\r\n     * Typeguard for determining if a shape is actually the paddle.\r\n     * @returns {boolean}. True if the object is a paddle, false otherwise.\r\n     */\r\n    isPaddle: (value: any): value is Paddle => {\r\n        return value && value.isPaddle;\r\n    }\r\n};","import { BallResizeFactor, BallSpeedIncreasePerBlock, BallSpeedIncreasePerLevel, InitialBallVelocity } from \"../Constants\";\r\nimport { Ball } from \"../Definitions/Ball\";\r\nimport { ScreenObject } from \"../Definitions/ScreenObject\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { Guard } from \"../Guards/Guard\";\r\nimport { angleRandomizer, changeAngle, getNextX, getNextY } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles ball actions.\r\n * @param {ball} state. The current ball state.\r\n * @param {ActionPayLoad}. An action, payload optional.\r\n * @returns {Ball}. The ball state.\r\n */\r\nexport const ballReducer = (state: Ball = getNewState(), action: ActionPayload<ScreenObject>): Ball => {\r\n\r\n    switch (action.type) {\r\n        case GameActions.reset: {\r\n            return getNewState();\r\n        }\r\n\r\n        case GameActions.tick: {\r\n            const x = getNextX(state.angle, state.velocity, state.left);\r\n            const y = getNextY(state.angle, state.velocity, state.top);\r\n\r\n            return { ...state, left: x, top: y };\r\n        }\r\n\r\n        case GameActions.ballBounceHorizantally:\r\n        case GameActions.ballBounceVertically: {\r\n            if (action.payload && action.payload !== state.lastObject) {\r\n                let angle = state.angle;\r\n                let angleChange = 1;\r\n\r\n                if (action.type === GameActions.ballBounceHorizantally) {\r\n\r\n                    // If the baddle is hit we want the ball's angle to increase if it hit\r\n                    // the edges.\r\n                    if (Guard.isPaddle(action.payload)) {\r\n                        // calculate where the ball hit relative to the shape from the left size.\r\n                        angleChange = changeAngle(state, action.payload);\r\n                    }\r\n\r\n                    // When the ball top or bottom makes contact, multiply the current angle by -1 for it to bounce.\r\n                    angle = (angle + angleChange) * -1;\r\n                } else {\r\n                    if (action.payload && action.payload !== state.lastObject) {\r\n                        // If the ball hits a side, the new angle is 180 - current angle.\r\n                        angle = 180 - angle;\r\n                    }\r\n                }\r\n\r\n                return { ...state, angle, lastObject: action.payload };\r\n            }\r\n\r\n            return state;\r\n        }\r\n\r\n        case GameActions.hitBlock:\r\n            // Increase the ball speed for each hit block\r\n            return { ...state, velocity: state.velocity * BallSpeedIncreasePerBlock };\r\n        case GameActions.nextLevel:\r\n            // Increase ball speed for each level.\r\n            return { ...state, velocity: state.velocity + BallSpeedIncreasePerLevel };\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the ball size that fits the screen size.\r\n * @returns {number}. The size of the ball.\r\n */\r\nconst getBallSize = (): number => {\r\n    return gameDimensions.size * BallResizeFactor;\r\n};\r\n\r\n/**\r\n * Calculate the ball position in the center of the game field.\r\n * @returns {number}. The ball's X or Y coordinate.\r\n */\r\nconst getBallPosition = (): number => {\r\n    return gameDimensions.size / 2 - gameDimensions.size * BallResizeFactor / 2;\r\n};\r\n\r\n/**\r\n * Used to obtain a new state for the ball.\r\n * @returns {Ball}. A new ball state.\r\n */\r\nconst getNewState = (): Ball => {\r\n    const angle = 90 + angleRandomizer();\r\n    return {\r\n        angle,\r\n        color: \"radial-gradient(yellow, orange, brown)\",\r\n        height: getBallSize(),\r\n        width: getBallSize(),\r\n        left: getBallPosition(),\r\n        top: getBallPosition(),\r\n        velocity: InitialBallVelocity,\r\n        lastObject: {},\r\n    };\r\n};\r\n","import { Block } from \"../Definitions/Block\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { getBlocks } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\nimport { BlockState } from \"../Definitions/BlockState\";\r\n\r\n/**\r\n * The block reducer.\r\n * @param {BlockState} state. The current block state.\r\n * @param {ActionPayload} action. An action, payload optional.\r\n * @returns {BlockState}. A 'new' block state.\r\n */\r\nexport const blockReducer = (state: BlockState = getNewState(), action: ActionPayload<Block>): BlockState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n            return getNewState();\r\n        case GameActions.nextLevel:\r\n\r\n            if (state.rows <= 10) {\r\n                // Increase the number of blocks until we hit 10 rows.\r\n                const nextLevelState = getNewState(state.rows + 1, state.columns + 1);\r\n                return nextLevelState;\r\n            } else {\r\n                return getNewState(state.rows, state.columns);\r\n            }\r\n\r\n        case GameActions.hitBlock:\r\n            if (action.payload && action.payload) {\r\n                const hitBlockState = [...state.blocks];\r\n                const hitBlockIndex = hitBlockState.indexOf(action.payload);\r\n\r\n                hitBlockState[hitBlockIndex].hit = true;\r\n\r\n                return { ...state, blocks: hitBlockState };\r\n            }\r\n\r\n            return state;\r\n\r\n        case GameActions.tick:\r\n\r\n            const hitBlocks = state.blocks.filter((b) => b.hit === true);\r\n\r\n            if (hitBlocks.length > 0) {\r\n\r\n                // Reduce a hit block by 10% of its original height\r\n                const widthReductionFactor = calculateBlockWidth(state.columns) * 0.1;\r\n                const heightReductionFactor = calculateBlockHeight(state.rows) * 0.1;\r\n\r\n                const tickBlocks = [...state.blocks];\r\n\r\n                // Redcue size for a hit block\r\n                hitBlocks.forEach((block) => {\r\n\r\n                    block.width -= widthReductionFactor;\r\n                    block.height -= heightReductionFactor;\r\n\r\n                    // Add half of the mount of pixels to the top and left to make it appear as the block shrinks to its center.\r\n                    block.top += heightReductionFactor / 2;\r\n                    block.left += widthReductionFactor / 2;\r\n\r\n                    const hitBlockIndex = tickBlocks.indexOf(block);\r\n\r\n                    if (block.height <= 0 || block.width <= 0) {\r\n                        // Block has reached size '0', time to remove it.\r\n                        tickBlocks.splice(hitBlockIndex, 1);\r\n                    }\r\n\r\n                });\r\n\r\n                return { ...state, blocks: tickBlocks };\r\n            } else {\r\n                return state;\r\n            }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets a new state for the blocks.\r\n * @param {number} rows. The number of rows the new state should have.\r\n * @param {number} columns. The number of columns the new state should have. Also used to calculate the block size.\r\n * @returns {BlockState}. A new block state.\r\n */\r\nconst getNewState = (rows: number = 5, columns: number = 12): BlockState => {\r\n    const blocks = getBlocks(rows, columns);\r\n\r\n    const width = calculateBlockWidth(columns);\r\n    const height = calculateBlockHeight(columns);\r\n\r\n    blocks.forEach((b) => {\r\n        b.width = width;\r\n        b.height = height;\r\n        b.left = b.x * width;\r\n        b.top = b.y * height;\r\n    });\r\n\r\n    return {\r\n        blocks,\r\n        columns,\r\n        rows,\r\n        height,\r\n        width\r\n    };\r\n};\r\n\r\n/**\r\n * Calculates the height of a block using the screen size and the number of rows.\r\n * @param {number} rows. Amount of rows.\r\n * @returns {number}. The height of a block based on the amount of colums.\r\n */\r\nfunction calculateBlockHeight(columns: number): number {\r\n    // The simples way to draw rectangles is to half the width.\r\n    return calculateBlockWidth(columns) / 2;\r\n}\r\n\r\n/**\r\n * Calculats the width of a block using the screensize.\r\n * @param {number} columns. Amount of colums.\r\n * @returns {number}. The block width based on the amount of colums.\r\n */\r\nfunction calculateBlockWidth(columns: number): number {\r\n    const size = getGameDimensions().size;\r\n    return size / columns;\r\n}\r\n","import { Action } from \"redux\";\r\nimport { GameState } from \"../Definitions/GameState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\n/**\r\n * game state reducer. Keeps track of score, losing a game, etc.\r\n * @param {GameState} state. The current game state\r\n * @param {Action}. A reduc action. No payload.\r\n * @returns {GameState}. The next game state.\r\n */\r\nexport const gameStateReducer = (state: GameState = getNewState(), action: Action<GameActions>): GameState  => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n            return getNewState();\r\n        case GameActions.gameLost:\r\n            return { ...state, gameMode: \"ended\" };\r\n        case GameActions.nextLevel:\r\n            return { ...state, level: state.level + 1 };\r\n        case GameActions.hitBlock:\r\n            return { ...state, score: state.score + 1 };\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Creates a new GameState state\r\n * @returns {GameState}. A new game state.\r\n */\r\nconst getNewState = (): GameState => {\r\n    return { gameMode: \"running\", level: 1, score: 0 };\r\n};\r\n","\r\nimport { PaddleColor, PaddleHeightFactor, PaddlePositionFactor, PaddleWithFactor } from \"../Constants\";\r\nimport { Paddle } from \"../Definitions/Paddle\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles paddle actions\r\n * @param {Paddle} state. The paddle state.\r\n * @param {ActionPayload<number> }action. An action to be performed on the paddle. Number is the 'left' coordinate of the paddle.\r\n * @returns {Paddle}. Paddle state.\r\n */\r\nexport const paddleReducer = (state: Paddle = getNewState(), action: ActionPayload<number>): Paddle => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n\r\n            return getNewState();\r\n\r\n        case GameActions.paddleMove:\r\n\r\n            // Prevent the paddle from being drawn outside the playfield.\r\n            if (typeof (action.payload) !== \"undefined\") {\r\n\r\n                let x;\r\n\r\n                if (action.payload - state.width / 2 <= 0) {\r\n                    x = 0;\r\n                } else if (action.payload - state.width / 2 >= (gameDimensions.size - state.width)) {\r\n                    x = gameDimensions.size - state.width;\r\n                } else {\r\n                    x = action.payload - (state.width / 2);\r\n                }\r\n\r\n                if (state.left === x) {\r\n                    return state;\r\n                } else {\r\n                    const newState = { ...state, left: x };\r\n                    return newState;\r\n                }\r\n            } else {\r\n                return state;\r\n            }\r\n\r\n        case GameActions.nextLevel:\r\n            const nextLevelPaddle = { ...state };\r\n\r\n            // Redude the paddle size each level by 5%\r\n            nextLevelPaddle.width *= 0.95;\r\n\r\n            if (nextLevelPaddle.width < gameDimensions.size / PaddleHeightFactor / 2) {\r\n                // Paddle doesn't get smaller than half its size.\r\n                return state;\r\n            } else {\r\n                return nextLevelPaddle;\r\n            }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Generates a new state for the paddle\r\n * @returns {Paddle}. A new state for the paddle\r\n */\r\nconst getNewState = (): Paddle => {\r\n    return {\r\n        color: PaddleColor,\r\n        width: gameDimensions.size / PaddleHeightFactor,\r\n        height: gameDimensions.size / PaddleWithFactor,\r\n        top: gameDimensions.size * PaddlePositionFactor,\r\n        left: (gameDimensions.size / 2) - (gameDimensions.size / PaddleHeightFactor / 2),\r\n        isPaddle: true\r\n    };\r\n};","import { combineReducers, createStore, ReducersMapObject, Store } from \"redux\";\r\nimport { ballReducer } from \"../Reducers/BallReducer\";\r\nimport { blockReducer } from \"../Reducers/BlockReducer\";\r\nimport { gameStateReducer } from \"../Reducers/GameStateReducer\";\r\nimport { paddleReducer } from \"../Reducers/PaddleReducer\";\r\nimport ActionPayload from \"./ActionPayLoad\";\r\nimport { AppState } from \"./AppState\";\r\n\r\n/**\r\n * All reducer that build the application state.\r\n */\r\nconst reducers: ReducersMapObject<AppState, ActionPayload<any>> = {\r\n    blockState: blockReducer,\r\n    paddle: paddleReducer,\r\n    ball: ballReducer,\r\n    gameState: gameStateReducer,\r\n};\r\n\r\nconst allReducers = combineReducers(reducers);\r\n\r\nconst store = createStore<AppState, ActionPayload<any>, AppState, AppState>(allReducers);\r\n\r\n/**\r\n * Returns the store\r\n * @returns {Store}. The redux store.\r\n */\r\nexport const appStore = (): Store<AppState, ActionPayload<any>> => {\r\n    return store;\r\n};\r\n\r\n/**\r\n * Returns the State\r\n * @returns {AppState}. The application state.\r\n */\r\nexport const appState = (): AppState => {\r\n    return appStore().getState();\r\n};","\r\n/**\r\n * A constant object that has an object for each wall. Used to eliminate double bounces.\r\n */\r\nexport const Walls = {\r\n    leftWall: {},\r\n    rightWall: {},\r\n    topWall: {},\r\n    bottomWall: {}\r\n};","import React, { CSSProperties } from \"react\";\nimport { GameFieldBorderColor, GameTick } from \"./Constants\";\nimport { Ball } from \"./Definitions/Ball\";\nimport { GameObject } from \"./Definitions/GameObject\";\nimport { getGameDimensions } from \"./GameDimensions\";\nimport { getBounceAction, getUpdatedOjbect, overlaps } from \"./Lib\";\nimport { AppState } from \"./State/AppState\";\nimport { GameActions } from \"./State/GameActions\";\nimport { appState, appStore } from \"./State/Store\";\nimport { Walls } from \"./WallConstants\";\n\nconst gameDimensions = getGameDimensions();\n\n/**\n * Main game component.\n */\nexport class Main extends React.Component<{}, AppState> {\n\n    /**\n     * Stores a reference to the animation that draws the game.\n     */\n    private tickHandler?: number;\n\n    /**\n     * Used to store the beginning of a game tick.\n     */\n    private tickStart?: number;\n\n    /**\n     * Refux subscription\n     */\n    private subscription?: () => void;\n\n    /**\n     * Initializes the Main component.\n     */\n    constructor(props: object) {\n        super(props);\n\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.tick = this.tick.bind(this);\n        this.onPlayAgain = this.onPlayAgain.bind(this);\n\n        this.onKeyUp = this.onKeyUp.bind(this);\n\n        // Sync the redux state with the component state.\n        this.state = appState();\n    }\n\n    /**\n     * Called when the component mounted.\n     */\n    public componentDidMount(): void {\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n\n        window.addEventListener(\"mousemove\", this.onMouseMove);\n        window.addEventListener(\"keyup\", this.onKeyUp);\n\n        this.subscription = appStore().subscribe(() => {\n            const applicationState = appState();\n\n            if (applicationState.gameState !== this.state.gameState) {\n                this.setState({ gameState: applicationState.gameState });\n\n                if (applicationState.gameState.gameMode === \"ended\") {\n                    if (this.tickHandler) {\n                        window.cancelAnimationFrame(this.tickHandler);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Called before the component unmounts.\n     */\n    public componentWillUnmount(): void {\n        if (this.tickHandler) {\n            window.cancelAnimationFrame(this.tickHandler);\n        }\n\n        window.removeEventListener(\"mousemove\", this.onMouseMove);\n        window.removeEventListener(\"mousemove\", this.onMouseMove);\n\n        if (this.subscription) {\n            this.subscription();\n            delete this.subscription;\n        }\n    }\n\n    private onKeyUp(e: KeyboardEvent): void {\n        if (e.code === \"KeyW\") {\n            appStore().dispatch({type: GameActions.nextLevel});\n        }\n    }\n\n    /**\n     * Handles mouse movement. Used to move the paddle.\n     * @param {MouseEvent} e. MouseEvent.\n     */\n    private onMouseMove(e: MouseEvent): void {\n        if (e) {\n            const x = e.clientX - gameDimensions.left;\n            appStore().dispatch({ type: GameActions.paddleMove, payload: x });\n        }\n    }\n\n    /**\n     * Handles a play again click.\n     */\n    private onPlayAgain(): void {\n        // Reset game state.\n        appStore().dispatch({ type: GameActions.reset });\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Handles a game tick.\n     * @param {number} tick. Current tick count.\n     */\n    public tick(tick: number): void {\n\n        if (!this.tickStart) {\n            this.tickStart = tick;\n        }\n\n        if (this.state.gameState.gameMode === \"ended\") {\n            return;\n        }\n\n        const diff = tick - this.tickStart;\n\n        // Redraw at 60 fps.\n        if (diff > GameTick) {\n            const ball = appState().ball;\n            const blocks = appState().blockState.blocks;\n            const paddle = appState().paddle;\n\n            if (blocks.length === 0) {\n                appStore().dispatch({ type: GameActions.nextLevel });\n            }\n\n            const paddleHit = overlaps(ball, paddle);\n\n            if (paddleHit) {\n                const paddleBounceAction = getBounceAction(ball, paddle);\n                appStore().dispatch({ type: paddleBounceAction, payload: paddle });\n            } else if (blocks) {\n\n                const hitBlock = blocks.find((b) => overlaps(ball, b) && b.hit === false);\n                if (hitBlock) {\n                    appStore().dispatch({ type: GameActions.hitBlock, payload: hitBlock });\n\n                    const action = getBounceAction(ball, hitBlock);\n\n                    if (typeof (action) !== \"undefined\") {\n                        appStore().dispatch({ type: action, payload: hitBlock });\n                    }\n\n                } else if (ball.top <= 0) {\n                    // The ball's top and left are inside the game field.\n                    // Use the game dimension object to store a wall hit.\n                    // Hit the top  wall\n                    appStore().dispatch({ type: GameActions.ballBounceHorizantally, payload: Walls.topWall });\n\n                } else if (ball.left <= 0) {\n                    // Hit the left wall\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.leftWall });\n\n                } else if (ball.left + ball.width >= gameDimensions.size) {\n                    // Hit the right wall\n\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.rightWall });\n                } else if (ball.top + ball.width >= gameDimensions.size) {\n                    // Hit bottom wall.\n                    appStore().dispatch({ type: GameActions.gameLost });\n                }\n            }\n\n            appStore().dispatch({ type: GameActions.tick });\n\n            const updatedState = getUpdatedOjbect(appState(), this.state);\n            if (updatedState) {\n                this.setState(updatedState);\n            }\n            this.tickStart = tick;\n        }\n\n        this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n\n    /**\n     * Returns the styling for the game field.\n     * @returns {CSSProperties}. CSSProperties for the gamefield.\n     */\n    private gameFieldStyle(): CSSProperties | undefined {\n\n        return {\n            position: \"absolute\",\n            left: getGameDimensions().left,\n            top: getGameDimensions().top,\n            width: getGameDimensions().size,\n            height: getGameDimensions().size,\n            borderColor: GameFieldBorderColor,\n            borderStyle: \"solid\",\n            display: \"flex\",\n            justifyContent: \"center\"\n        };\n    }\n\n    /**\n     * Game score style\n     * @returns {CSSProperties}. A style that will draw a rectangle above the game field.\n     */\n    private gameScorebarStyle(): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: getGameDimensions().left,\n            width: getGameDimensions().size,\n            top: getGameDimensions().top - 25,\n            height: 22,\n            borderColor: GameFieldBorderColor,\n            borderStyle: \"solid\",\n            display: \"flex\",\n            flexDirection: \"row\",\n        };\n    }\n\n    /**\n     * Returns css properties for positioning a shape.\n     * @param {ScreenObject} shape. A shape object.\n     * @returns {CSSProperties}. CSS properties for a shape.\n     */\n    private positionStyle(shape: GameObject): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: shape.left,\n            top: shape.top,\n            height: shape.height,\n            width: shape.width,\n            backgroundColor: shape.color,\n        };\n    }\n\n    /**\n     * Returns css properties for positioning and drawing the ball.\n     * @param {Ball} ball.\n     * @returns {CSSProperties}.\n     */\n    private ballStyle(ball: Ball): CSSProperties {\n        const newPosition = this.positionStyle(ball);\n        newPosition.borderRadius = \"50%\";\n        newPosition.backgroundImage = ball.color;\n        return newPosition;\n    }\n\n    /**\n     * Renders the component.\n     */\n    public render(): React.ReactNode {\n        return (\n            <div>\n                <div style={this.gameScorebarStyle()}>\n                    <div key={1} style={{ color: \"white\", justifyContent: \"center\", marginLeft: \"10px\" }}>Level: {this.state.gameState.level}</div>>\n                <div key={2} style={{ color: \"white\", justifyContent: \"center\" }}>Score: {this.state.gameState.score}</div>>\n            </div>\n                <div>\n                    {\n                        this.state.blockState && this.state.paddle && this.state.ball ?\n                            <div style={this.gameFieldStyle()}>\n                                {\n                                    this.state.blockState.blocks.map((b, index) => <div key={index} style={this.positionStyle(b)} />)\n                                }\n                                <div style={this.positionStyle(this.state.paddle)} />\n                                <div style={this.ballStyle(this.state.ball)} />\n                                {\n                                    this.state.gameState.gameMode === \"ended\" ?\n                                        <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"center\" }}>\n                                            <p style={{ alignSelf: \"center\", color: \"white\" }}>Game over</p>\n                                            <button onClick={this.onPlayAgain} style={{ alignSelf: \"center\" }}>Play again</button>\n                                        </div>\n                                        : null\n                                }\n\n                            </div> : null\n                    }\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default Main;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Main from \"./Main\";\n\nReactDOM.render(<Main />, document.getElementById(\"root\"));\n"],"sourceRoot":""}