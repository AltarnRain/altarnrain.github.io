{"version":3,"sources":["GameDimensions.ts","State/GameActions.ts","Constants/Constants.ts","Constants/WallConstants.ts","Lib.ts","Guard.ts","Reducers/BallReducer.ts","Reducers/BlockReducer.ts","Reducers/GameStateReducer.ts","Reducers/PaddleReducer.ts","Reducers/SoundReducer.ts","State/Store.ts","Main.tsx","index.tsx"],"names":["gameDimensions","GameActions","DegreeToRadian","Math","PI","Walls","leftWall","rightWall","topWall","bottomWall","getGameDimensions","size","window","innerHeight","innerWidth","left","top","getBlocks","numberOfBlockRows","numberOfBlockColumns","red","blue","redAdd","blueAdd","blocks","r","c","block","color","x","y","height","width","hit","green","greenAdd","push","overlaps","shape1","shape2","left1","right1","top1","bottom1","left2","right2","top2","bottom2","getBounceAction","ball","shape","directions","getDirectionFromAngle","angle","horizantalLine","verticalLine","shapeBottom","shapeRight","up","a","b","right","down","hitLine","getHitLine","ballBounceHorizantally","ballBounceVertically","changeAngle","paddle","abs","getNextY","distance","currentY","sin","getNextX","currentX","cos","returnValue","forward","velocity","backward","topLeftLine","topRightLine","bottomRightLine","bottomLeftLine","horizantolIntersects","verticalIntersects","intersects","console","log","line1","line2","x1","floor","y1","x2","y2","x3","y3","x4","y4","isNaN","Guard","value","isPaddle","getBallSize","getNewState","angleManipulator","random","angleRandomizer","lastObject","rows","columns","calculateBlockWidth","calculateBlockHeight","forEach","gameMode","level","score","bounce","Howl","src","hitBlock","sounds","reducers","blockState","state","action","type","reset","nextLevel","nextLevelState","produce","draftObject","payload","hitBlockIndex","indexOf","tick","hitBlocks","filter","length","widthReductionFactor","heightReductionFactor","splice","paddleMove","newWidth","draftState","angleChange","newState","gameState","gameLost","resume","pause","soundState","play","toggleSound","allReducers","combineReducers","store","createStore","appStore","appState","getState","Main","props","tickHandler","tickStart","subscription","onMouseMove","bind","onMouseClick","onPlayAgain","onKeyUp","this","requestAnimationFrame","addEventListener","subscribe","applicationState","setState","cancelAnimationFrame","removeEventListener","e","code","dispatch","clientX","paddleBounceAction","find","newComponentState","position","borderColor","borderStyle","display","justifyContent","flexDirection","backgroundColor","css","positionStyle","newPosition","borderRadius","backgroundImage","style","gameScorebarStyle","marginTop","marginLeft","marginRight","textAlign","gameFieldStyle","map","index","key","blockStyle","ballStyle","alignSelf","onClick","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5c0bc8c3.chunk.js","sourcesContent":["/**\r\n * Provides game dimensions.\r\n */\r\n\r\nimport { WindowResizeConstant } from \"./Constants/Constants\";\r\nimport { GameDimensions } from \"./Definitions/GameDimensions\";\r\n\r\nlet gameDimensions: GameDimensions;\r\n\r\nexport const getGameDimensions = (): GameDimensions => {\r\n    if (!gameDimensions) {\r\n        let size = 0;\r\n\r\n        if (window.innerHeight > window.innerWidth) {\r\n            size = window.innerWidth * WindowResizeConstant;\r\n        } else {\r\n            size = window.innerHeight * WindowResizeConstant;\r\n        }\r\n\r\n        const left = (window.innerWidth / 2) - (size / 2);\r\n        const top = (window.innerHeight / 2) - (size / 2);\r\n\r\n        gameDimensions = { left, top, size };\r\n    }\r\n\r\n    return gameDimensions;\r\n};","export enum GameActions {\r\n    /**\r\n     * An action that instructs the reducers to return an initial objects to play the game.\r\n     */\r\n    reset,\r\n\r\n    /**\r\n     * Dispatched when a block is hit.\r\n     */\r\n    hitBlock,\r\n\r\n    /**\r\n     * Dispatched when the user moves the mouse causing th paddle to move.\r\n     */\r\n    paddleMove,\r\n\r\n    /**\r\n     * Dispatch for a game tick.\r\n     */\r\n    tick,\r\n\r\n    /**\r\n     * Dispatchen when the ball bounces of top or bottom of an object.\r\n     */\r\n    ballBounceHorizantally,\r\n\r\n    /**\r\n     * Dispatched when the ball bounces of the side of an object.\r\n     */\r\n    ballBounceVertically,\r\n\r\n    /**\r\n     * Dispatched when the ball hits the bottom of the play field.\r\n     */\r\n    gameLost,\r\n\r\n    /**\r\n     * Dispatched when all the blocks are cleared.\r\n     */\r\n    nextLevel,\r\n\r\n    /**\r\n     * Resume the game.\r\n     */\r\n    resume,\r\n\r\n    /**\r\n     * An action that pauses the game\r\n     */\r\n    pause,\r\n\r\n    /**\r\n     * An action that toggles the sound on and off.\r\n     */\r\n    toggleSound\r\n}","\r\n/**\r\n * A constants used to convert the angle from degree's to radians.\r\n */\r\nexport const DegreeToRadian = Math.PI / 180;\r\n\r\n/**\r\n * A constants that contains the time in milli second for a frame.\r\n */\r\nexport const GameTick = 1000 / 60;\r\n\r\n/**\r\n * Constants for the initial ball velocity.\r\n */\r\nexport const InitialBallVelocity = 10;\r\n\r\n/**\r\n * Constants used in a calculation to randomize the ball's initial angle.\r\n */\r\nexport const BallAngleStartRandomFactor = 10;\r\n\r\n/**\r\n * Constants used in calculation the width and height of the ball relative to the game field diminsions.\r\n */\r\nexport const BallResizeFactor = 0.02;\r\n\r\n/**\r\n * A Constants used ina calculation to increase or decrease the angle of the ball depending on where it hits the paddle.\r\n */\r\nexport const BounceAngleIncreaseConstant = 40;\r\n\r\n/**\r\n * Constant to used to calculate the size of the playing field.\r\n */\r\nexport const WindowResizeConstant = 0.9;\r\n\r\n/**\r\n * Used to calculate the paddle with relative to the game field width.\r\n */\r\nexport const PaddleWithFactor = 40;\r\n\r\n/**\r\n * Used to calculate the height of the paddle relative to the game field height.\r\n */\r\nexport const PaddleHeightFactor = 10;\r\n\r\n/**\r\n * Used to calculate the paddle's top coordinate relative to the game field height.\r\n */\r\nexport const PaddlePositionFactor = 0.9;\r\n\r\n/**\r\n * Speed increase factor for each hit block\r\n */\r\nexport const BallSpeedIncreasePerBlock = 1.02;\r\n\r\n/**\r\n * Speed increase factor for each level.\r\n */\r\nexport const BallSpeedIncreasePerLevel = 1.05;\r\n\r\n/**\r\n * Border color\r\n */\r\nexport const GameFieldBorderColor = \"#2c1145\";\r\n\r\n/**\r\n * The paddle color\r\n */\r\nexport const PaddleColor = \"#8b25ae\";\r\n\r\n/**\r\n * Minimal amount of red in a block\r\n */\r\nexport const MinRed = 30;\r\n\r\n/**\r\n * Maximum amount of red in a block\r\n */\r\nexport const MaxRed = 60;\r\n\r\n/**\r\n * Minimal amount of green in a blcok\r\n */\r\n\r\nexport const MinGreen = 0;\r\n\r\n/**\r\n * Maximum amount of green in a block\r\n */\r\nexport const MaxGreen = 60;\r\n\r\n/**\r\n * Minimal amount of blue in a block\r\n */\r\nexport const MinBlue = 80;\r\n\r\n/**\r\n * Maximum amount of blue in a block\r\n */\r\nexport const MaxBlue = 120;\r\n","\r\n/**\r\n * A constant object that has an object for each wall. Used to eliminate double bounces.\r\n */\r\nexport const Walls = {\r\n    /**\r\n     * Reference constant for the left wall.\r\n     */\r\n    leftWall: {},\r\n\r\n    /**\r\n     * Reference constants for the right wall\r\n     */\r\n    rightWall: {},\r\n\r\n    /**\r\n     * Reference constant for the top wall.\r\n     */\r\n    topWall: {},\r\n\r\n    /**\r\n     * Reference constant for the bottom wall.\r\n     */\r\n    bottomWall: {}\r\n};","/**\r\n * This is a library module that contains functions user throughout the entire game.\r\n */\r\n\r\nimport { BallAngleStartRandomFactor, BounceAngleIncreaseConstant, DegreeToRadian, MaxBlue, MaxRed, MinBlue, MinRed } from \"./Constants/Constants\";\r\nimport { Block } from \"./Definitions/Block\";\r\nimport { Direction } from \"./Definitions/Direction\";\r\nimport { Line } from \"./Definitions/Line\";\r\nimport { ScreenObject } from \"./Definitions/ScreenObject\";\r\nimport { BallState } from \"./State/Definition/BallState\";\r\nimport { GameActions } from \"./State/GameActions\";\r\n\r\n/**\r\n * Returns the initial block setup.\r\n * @param {number} numberOfBlockRows. The amount of rows to add to the block array.\r\n * @param {number} numberOfBlockColumns. The mount of columns to add to the block array.\r\n * @returns {Block[]}. A 1d array that contains block objects.\r\n */\r\nexport const getBlocks = (numberOfBlockRows: number, numberOfBlockColumns: number): Block[] => {\r\n    let red = MinRed;\r\n    let blue = MinBlue;\r\n\r\n    let redAdd = 5;\r\n    let blueAdd = 5;\r\n\r\n    const blocks: Block[] = [];\r\n    for (let r = 0; r < numberOfBlockRows; r++) {\r\n        for (let c = 0; c < numberOfBlockColumns; c++) {\r\n\r\n            const block: Block = {\r\n                color: `rgba(${red}, 0, ${blue}, 1`,\r\n                x: c,\r\n                y: r,\r\n                left: 0,\r\n                top: 0,\r\n                height: 0,\r\n                width: 0,\r\n                hit: false,\r\n                red,\r\n                blue,\r\n                green: 0,\r\n                redAdd: 1,\r\n                blueAdd: 1,\r\n                greenAdd: 1\r\n            };\r\n\r\n            red += redAdd;\r\n            blue += blueAdd;\r\n\r\n            blocks.push(block);\r\n\r\n            if (red > MaxRed || red < MinRed) {\r\n                redAdd *= -1;\r\n            }\r\n\r\n            if (blue > MaxBlue || blue < MinBlue) {\r\n                blueAdd *= -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    return blocks;\r\n};\r\n\r\n/**\r\n * Checks if two shapes overlap\r\n * @param {ScreenObject} shape1. A Shape.\r\n * @param {ScreenObject} shape2. A Shape\r\n * @returns {boolean}. True if the shapes overlap, false otherwise.\r\n */\r\nexport const overlaps = (shape1: ScreenObject, shape2: ScreenObject): boolean => {\r\n\r\n    const left1 = shape1.left;\r\n    const right1 = shape1.left + shape1.width;\r\n    const top1 = shape1.top;\r\n    const bottom1 = shape1.top + shape1.height;\r\n\r\n    const left2 = shape2.left;\r\n    const right2 = shape2.left + shape2.width;\r\n    const top2 = shape2.top;\r\n    const bottom2 = shape2.top + shape2.height;\r\n\r\n    if (bottom1 < top2 || top1 > bottom2) {\r\n        return false;\r\n    }\r\n\r\n    if (right2 < left1 || left2 > right1) {\r\n        return false;\r\n    }\r\n\r\n    // Rectangles overlap\r\n    return true;\r\n};\r\n\r\n/**\r\n * Randomizes an angle.\r\n * @returns {number}. A number that can be added to an angle to slightly change it.\r\n */\r\nexport const angleRandomizer = (): number => {\r\n    const angleManipulator = (Math.random() * BallAngleStartRandomFactor);\r\n    if (Math.random() >= 0.5) {\r\n        return angleManipulator;\r\n    } else {\r\n        return angleManipulator * -1;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the bounce action depending on the balls heading an screen object's position.\r\n * @param {BallState} ball. A ball object.\r\n * @param {Shape} shape. Any game object that derives from ScreenObject.\r\n * @returns {GameActions.ballBounceHorizantally | GameActions.ballBounceVertically }. A ball can bounce vertically or horizantally.\r\n */\r\nexport const getBounceAction = (ball: BallState, shape: ScreenObject): GameActions.ballBounceHorizantally | GameActions.ballBounceVertically => {\r\n\r\n    const directions = getDirectionFromAngle(ball.angle);\r\n\r\n    let horizantalLine: Line = {} as Line;\r\n    let verticalLine: Line = {} as Line;\r\n\r\n    const shapeBottom = shape.top + shape.height;\r\n    const shapeRight = shape.left + shape.width;\r\n\r\n    if (directions.up) {\r\n        horizantalLine = {\r\n            a: {\r\n                x: shape.left,\r\n                y: shapeBottom,\r\n            },\r\n            b: {\r\n                x: shapeRight,\r\n                y: shapeBottom\r\n            }\r\n        };\r\n    }\r\n\r\n    if (directions.right) {\r\n        verticalLine = {\r\n            a: {\r\n                x: shape.left,\r\n                y: shape.top,\r\n            },\r\n            b: {\r\n                x: shape.left,\r\n                y: shapeBottom,\r\n            }\r\n        };\r\n    }\r\n\r\n    if (directions.down) {\r\n        horizantalLine = {\r\n            a: {\r\n                x: shape.left,\r\n                y: shape.top,\r\n            },\r\n            b: {\r\n                x: shapeRight,\r\n                y: shape.top,\r\n            }\r\n        };\r\n    }\r\n\r\n    if (directions.left) {\r\n        verticalLine = {\r\n            a: {\r\n                x: shapeRight,\r\n                y: shape.top,\r\n            },\r\n            b: {\r\n                x: shapeRight,\r\n                y: shapeBottom\r\n            }\r\n        };\r\n    }\r\n\r\n    const hitLine = getHitLine(ball, horizantalLine, verticalLine);\r\n\r\n    if (hitLine === horizantalLine) {\r\n        return GameActions.ballBounceHorizantally;\r\n    } else if (hitLine === verticalLine) {\r\n        return GameActions.ballBounceVertically;\r\n    } else {\r\n        // Default to a horizantal bounce because it is the most likely to occur.\r\n        return GameActions.ballBounceHorizantally;\r\n    }\r\n};\r\n\r\n/**\r\n * Changes the angle based on the position of impact.\r\n * @param {BallState} ball. A ball object\r\n * @param {Paddle} paddle. A paddle object\r\n * @returns {number}. An angle that is slightly altered.\r\n */\r\nexport const changeAngle = (ball: ScreenObject, paddle: ScreenObject): number => {\r\n    const p = Math.abs(ball.left - paddle.left);\r\n\r\n    // calculate a factor based on the shape's width. Since this is a horizantol hit, this results in a\r\n    // number between 0 and 1.\r\n    const v = p / paddle.width;\r\n    const returnValue = BounceAngleIncreaseConstant * (0.5 - v) * -1;\r\n    return returnValue;\r\n};\r\n\r\n/**\r\n * Get next Y (position)\r\n * @param {number} angle. The angle of an object.\r\n * @param {number} distance. The distance the object will travel.\r\n * @param {number} currentY. The current Y coordinate of the object.\r\n * @returns {number}. The next Y position based on the object's angle and 'speed'.\r\n */\r\nexport const getNextY = (angle: number, distance: number, currentY: number) => {\r\n    return Math.sin(angle * DegreeToRadian * -1) * distance + currentY;\r\n};\r\n\r\n/**\r\n * Get next X (position)\r\n * @param {number} angle. The angle of an object.\r\n * @param {number} distance. The distance the object will travel.\r\n * @param {number} currentY. The current X coordinate of the object.\r\n * @returns {number}. The next X position based on the object's angle and 'speed'.\r\n */\r\nexport const getNextX = (angle: number, distance: number, currentX: number) => {\r\n    return Math.cos(angle * DegreeToRadian * -1) * distance + currentX;\r\n};\r\n\r\n/**\r\n * Get the directions from an angle\r\n * @param {number} angle. The angle of an object.\r\n * @returns {Direction[]}. The directions the object is traveling in. e.g. Down-left, or Up-right.\r\n */\r\nexport const getDirectionFromAngle = (angle: number): Direction => {\r\n\r\n    // A ball can travel at two directions at most so the return\r\n    // Value has to be an array with a size of 1 or two.\r\n    const returnValue: Direction = { up: false, down: false, left: false, right: false };\r\n\r\n    const x = getNextX(angle, 10, 0);\r\n    const y = getNextY(angle, 10, 0);\r\n\r\n    if (x > 0) {\r\n        // Ball travels to the right\r\n        returnValue.right = true;\r\n    }\r\n\r\n    if (x < 0) {\r\n        // Ball travels to the left.\r\n        returnValue.left = true;\r\n    }\r\n\r\n    if (y > 0) {\r\n        // Ball travels down.\r\n        returnValue.down = true;\r\n    }\r\n\r\n    if (y < 0) {\r\n        // Ball travels up\r\n        returnValue.up = true;\r\n    }\r\n\r\n    return returnValue;\r\n};\r\n\r\n/**\r\n * Determines which line was hit.\r\n * @param {BallState} ball. The ball.\r\n * @param {Line} horizantalLine. The horizantal line of a shape. Can be the top or bottom.\r\n * @param {Line} verticalLine. The vertical line of a shape. Can be left or right.\r\n * @returns {Line}. The hit line. Returns undefined when the hit line could not be found.\r\n */\r\nexport const getHitLine = (ball: BallState, horizantalLine: Line, verticalLine: Line): Line | undefined => {\r\n\r\n    const forward = ball.velocity;\r\n    const backward = ball.velocity * -1;\r\n\r\n    const topLeftLine: Line = {\r\n        a: {\r\n            x: getNextX(ball.angle, forward, ball.left),\r\n            y: getNextY(ball.angle, forward, ball.top),\r\n        },\r\n        b: {\r\n            x: getNextX(ball.angle, backward, ball.left),\r\n            y: getNextY(ball.angle, backward, ball.top),\r\n        }\r\n    };\r\n\r\n    const topRightLine: Line = {\r\n        a: {\r\n            x: getNextX(ball.angle, forward, ball.left + ball.width),\r\n            y: getNextY(ball.angle, forward, ball.top),\r\n        },\r\n        b: {\r\n            x: getNextX(ball.angle, backward, ball.left + ball.width),\r\n            y: getNextY(ball.angle, backward, ball.top),\r\n        }\r\n    };\r\n\r\n    const bottomRightLine: Line = {\r\n        a: {\r\n            x: getNextX(ball.angle, forward, ball.left + ball.width),\r\n            y: getNextY(ball.angle, forward, ball.top + ball.height),\r\n        },\r\n        b: {\r\n            x: getNextX(ball.angle, backward, ball.left + ball.width),\r\n            y: getNextY(ball.angle, backward, ball.top + ball.height),\r\n        }\r\n    };\r\n\r\n    const bottomLeftLine: Line = {\r\n        a: {\r\n            x: getNextX(ball.angle, forward, ball.left ),\r\n            y: getNextY(ball.angle, forward, ball.top + ball.height),\r\n        },\r\n        b: {\r\n            x: getNextX(ball.angle, backward, ball.left),\r\n            y: getNextY(ball.angle, backward, ball.top + ball.height),\r\n        }\r\n    };\r\n\r\n    let horizantolIntersects = 0;\r\n    let verticalIntersects = 0;\r\n\r\n    horizantolIntersects += intersects(\r\n        topLeftLine,\r\n        horizantalLine) ? 1 : 0;\r\n\r\n    verticalIntersects += intersects(\r\n        topLeftLine,\r\n        verticalLine) ? 1 : 0;\r\n\r\n    horizantolIntersects += intersects(\r\n        topRightLine,\r\n        horizantalLine) ? 1 : 0;\r\n\r\n    verticalIntersects += intersects(\r\n        topRightLine,\r\n        verticalLine) ? 1 : 0;\r\n\r\n    horizantolIntersects += intersects(\r\n        bottomRightLine,\r\n        horizantalLine) ? 1 : 0;\r\n\r\n    verticalIntersects += intersects(\r\n        bottomRightLine,\r\n        verticalLine) ? 1 : 0;\r\n\r\n    horizantolIntersects += intersects(\r\n        bottomLeftLine,\r\n        horizantalLine) ? 1 : 0;\r\n\r\n    verticalIntersects += intersects(\r\n        bottomLeftLine,\r\n        verticalLine) ? 1 : 0;\r\n\r\n    if (horizantolIntersects > verticalIntersects) {\r\n        return horizantalLine;\r\n    } else if (verticalIntersects > horizantolIntersects) {\r\n        return verticalLine;\r\n    } else {\r\n        // tslint:disable-next-line: no-console\r\n        console.log(\"Could not determine the hit\");\r\n        return undefined;\r\n    }\r\n};\r\n\r\n/**\r\n * Returns true if the intercet.\r\n * Source: https://stackoverflow.com/questions/9043805/test-if-two-lines-intersect-javascript-function\r\n */\r\nexport function intersects(line1: Line, line2: Line) {\r\n\r\n    const x1 = Math.floor(line1.a.x);\r\n    const y1 = Math.floor(line1.a.y);\r\n    const x2 = Math.floor(line1.b.x);\r\n    const y2 = Math.floor(line1.b.y);\r\n\r\n    const x3 = Math.floor(line2.a.x);\r\n    const y3 = Math.floor(line2.a.y);\r\n    const x4 = Math.floor(line2.b.x);\r\n    const y4 = Math.floor(line2.b.y);\r\n\r\n    const x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));\r\n    const y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));\r\n    if (isNaN(x) || isNaN(y)) {\r\n        return false;\r\n    } else {\r\n        if (x1 >= x2) {\r\n            if (!(x2 <= x && x <= x1)) { return false; }\r\n        } else {\r\n            if (!(x1 <= x && x <= x2)) { return false; }\r\n        }\r\n        if (y1 >= y2) {\r\n            if (!(y2 <= y && y <= y1)) { return false; }\r\n        } else {\r\n            if (!(y1 <= y && y <= y2)) { return false; }\r\n        }\r\n        if (x3 >= x4) {\r\n            if (!(x4 <= x && x <= x3)) { return false; }\r\n        } else {\r\n            if (!(x3 <= x && x <= x4)) { return false; }\r\n        }\r\n        if (y3 >= y4) {\r\n            if (!(y4 <= y && y <= y3)) { return false; }\r\n        } else {\r\n            if (!(y3 <= y && y <= y4)) { return false; }\r\n        }\r\n    }\r\n    return true;\r\n}","import { PaddleState } from \"./State/Definition/PaddleState\";\r\n\r\n/**\r\n * A constant that contains type guards.\r\n */\r\nexport const Guard = {\r\n\r\n    /**\r\n     * Typeguard for determining if a shape is actually the paddle.\r\n     * @returns {boolean}. True if the object is a paddle, false otherwise.\r\n     */\r\n    isPaddle: (value: any): value is PaddleState => {\r\n        return value && value.isPaddle;\r\n    }\r\n};","import produce from \"immer\";\r\nimport { BallResizeFactor, BallSpeedIncreasePerBlock, BallSpeedIncreasePerLevel, InitialBallVelocity } from \"../Constants/Constants\";\r\nimport { ScreenObject } from \"../Definitions/ScreenObject\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { Guard } from \"../Guard\";\r\nimport { angleRandomizer, changeAngle, getNextX, getNextY } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { BallState } from \"../State/Definition/BallState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles ball actions.\r\n * @param {ball} state. The current ball state.\r\n * @param {ActionPayLoad}. An action, payload optional.\r\n * @returns {BallState}. The ball state.\r\n */\r\nexport const ballReducer = (state: BallState = getNewState(), action: ActionPayload<ScreenObject>): BallState => {\r\n\r\n    switch (action.type) {\r\n        case GameActions.reset: {\r\n            return getNewState();\r\n        }\r\n\r\n        case GameActions.tick: {\r\n\r\n            return produce(state, (draftState) => {\r\n                const left = getNextX(state.angle, state.velocity, state.left);\r\n                const top = getNextY(state.angle, state.velocity, state.top);\r\n\r\n                draftState.top = top;\r\n                draftState.left = left;\r\n            });\r\n        }\r\n\r\n        case GameActions.ballBounceHorizantally:\r\n        case GameActions.ballBounceVertically: {\r\n            return produce(state, (draftObject) => {\r\n                if (action.payload && action.payload !== state.lastObject) {\r\n\r\n                    draftObject.lastObject = action.payload;\r\n\r\n                    if (action.type === GameActions.ballBounceHorizantally) {\r\n                        let angleChange = 0;\r\n\r\n                        // If the baddle is hit we want the ball's angle to increase if it hit\r\n                        // the edges.\r\n                        if (Guard.isPaddle(action.payload)) {\r\n                            // calculate where the ball hit relative to the shape from the left size.\r\n                            angleChange = changeAngle(state, action.payload);\r\n                        }\r\n\r\n                        // When the ball top or bottom makes contact, multiply the current angle by -1 for it to bounce.\r\n                        draftObject.angle = (draftObject.angle + angleChange) * -1;\r\n                    } else {\r\n                        if (action.payload && action.payload !== state.lastObject) {\r\n                            // If the ball hits a side, the new angle is 180 - current angle.\r\n                            draftObject.angle = 180 - draftObject.angle;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        case GameActions.hitBlock:\r\n            // Increase the ball speed for each hit block\r\n            return produce(state, (draftObject) => {\r\n                draftObject.velocity = state.velocity * BallSpeedIncreasePerBlock;\r\n            });\r\n        case GameActions.nextLevel:\r\n            const newState = getNewState();\r\n            newState.velocity = state.velocity * BallSpeedIncreasePerLevel;\r\n\r\n            return newState;\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the ball size that fits the screen size.\r\n * @returns {number}. The size of the ball.\r\n */\r\nconst getBallSize = (): number => {\r\n    return gameDimensions.size * BallResizeFactor;\r\n};\r\n\r\n/**\r\n * Calculate the ball position in the center of the game field.\r\n * @returns {number}. The ball's X or Y coordinate.\r\n */\r\nconst getBallPositionX = (): number => {\r\n    return gameDimensions.size / 2 - gameDimensions.size * BallResizeFactor / 2;\r\n};\r\n\r\n/**\r\n * Calculate the ball position in the center of the game field.\r\n * @returns {number}. The ball's X or Y coordinate.\r\n */\r\nconst getBallPositionY = (): number => {\r\n    return gameDimensions.size / 1.5 - gameDimensions.size * BallResizeFactor / 2;\r\n};\r\n\r\n/**\r\n * Used to obtain a new state for the ball.\r\n * @returns {BallState}. A new ball state.\r\n */\r\nconst getNewState = (): BallState => {\r\n    const angle = 90 + angleRandomizer();\r\n    return {\r\n        angle,\r\n        color: \"radial-gradient(yellow, orange, brown)\",\r\n        height: getBallSize(),\r\n        width: getBallSize(),\r\n        left: getBallPositionX(),\r\n        top: getBallPositionY(),\r\n        velocity: InitialBallVelocity,\r\n        lastObject: {},\r\n    };\r\n};\r\n","import produce from \"immer\";\r\nimport { MaxBlue, MaxGreen, MaxRed, MinBlue, MinGreen, MinRed } from \"../Constants/Constants\";\r\nimport { Block } from \"../Definitions/Block\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { getBlocks } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { BlockState } from \"../State/Definition/BlockState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\n/**\r\n * The block reducer.\r\n * @param {BlockState} state. The current block state.\r\n * @param {ActionPayload} action. An action, payload optional.\r\n * @returns {BlockState}. A 'new' block state.\r\n */\r\nexport const blockReducer = (state: BlockState = getNewState(), action: ActionPayload<Block>): BlockState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n            return getNewState();\r\n        case GameActions.nextLevel:\r\n\r\n            if (state.rows <= 10) {\r\n                // Increase the number of blocks until we hit 10 rows.\r\n                const nextLevelState = getNewState(state.rows + 1, state.columns + 1);\r\n                return nextLevelState;\r\n            } else {\r\n                return getNewState(state.rows, state.columns);\r\n            }\r\n\r\n        case GameActions.hitBlock:\r\n            return produce(state, (draftObject) => {\r\n                if (action.payload) {\r\n                    const hitBlockIndex = state.blocks.indexOf(action.payload);\r\n                    draftObject.blocks[hitBlockIndex].hit = true;\r\n\r\n                    draftObject.blocks.forEach((block) => {\r\n\r\n                        if (block.red > MaxRed || block.red < MinRed) {\r\n                            block.redAdd *= -1;\r\n                        }\r\n\r\n                        if (block.green > MaxGreen || block.green < MinGreen) {\r\n                            block.greenAdd *= -1;\r\n                        }\r\n\r\n                        if (block.blue > MaxBlue || block.blue < MinBlue) {\r\n                            block.blueAdd *= -1;\r\n                        }\r\n\r\n                        block.red += block.redAdd;\r\n                        block.green += block.greenAdd;\r\n                        block.blue += block.blueAdd;\r\n                    });\r\n                }\r\n            });\r\n\r\n        case GameActions.tick:\r\n\r\n            return produce(state, (draftObject) => {\r\n                const hitBlocks = draftObject.blocks.filter((b) => b.hit === true);\r\n\r\n                if (hitBlocks.length > 0) {\r\n\r\n                    // Reduce a hit block by 10% of its original height\r\n                    const widthReductionFactor = calculateBlockWidth(draftObject.columns) * 0.1;\r\n                    const heightReductionFactor = calculateBlockHeight(draftObject.rows) * 0.1;\r\n\r\n                    // Redcue size for a hit block\r\n                    hitBlocks.forEach((block) => {\r\n                        block.width -= widthReductionFactor;\r\n                        block.height -= heightReductionFactor;\r\n\r\n                        // Add half of the mount of pixels to the top and left to make it appear as the block shrinks to its center.\r\n                        block.top += heightReductionFactor / 2;\r\n                        block.left += widthReductionFactor / 2;\r\n\r\n                        if (block.height <= 0 || block.width <= 0) {\r\n                            // Block has reached size '0', time to remove it.\r\n                            draftObject.blocks.splice(draftObject.blocks.indexOf(block), 1);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets a new state for the blocks.\r\n * @param {number} rows. The number of rows the new state should have.\r\n * @param {number} columns. The number of columns the new state should have. Also used to calculate the block size.\r\n * @returns {BlockState}. A new block state.\r\n */\r\nconst getNewState = (rows: number = 5, columns: number = 12): BlockState => {\r\n    const blocks = getBlocks(rows, columns);\r\n\r\n    const width = calculateBlockWidth(columns);\r\n    const height = calculateBlockHeight(columns);\r\n\r\n    blocks.forEach((b) => {\r\n        b.width = width;\r\n        b.height = height;\r\n        b.left = b.x * width;\r\n        b.top = b.y * height;\r\n    });\r\n\r\n    return {\r\n        blocks,\r\n        columns,\r\n        rows,\r\n        height,\r\n        width\r\n    };\r\n};\r\n\r\n/**\r\n * Calculates the height of a block using the screen size and the number of rows.\r\n * @param {number} rows. Amount of rows.\r\n * @returns {number}. The height of a block based on the amount of colums.\r\n */\r\nfunction calculateBlockHeight(columns: number): number {\r\n    // The simples way to draw rectangles is to half the width.\r\n    return calculateBlockWidth(columns) / 2;\r\n}\r\n\r\n/**\r\n * Calculats the width of a block using the screensize.\r\n * @param {number} columns. Amount of colums.\r\n * @returns {number}. The block width based on the amount of colums.\r\n */\r\nfunction calculateBlockWidth(columns: number): number {\r\n    const size = getGameDimensions().size;\r\n    return size / columns;\r\n}\r\n","import produce from \"immer\";\r\nimport { Action } from \"redux\";\r\nimport { GameState } from \"../State/Definition/GameState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\n/**\r\n * game state reducer. Keeps track of score, losing a game, etc.\r\n * @param {GameState} state. The current game state\r\n * @param {Action}. A reduc action. No payload.\r\n * @returns {GameState}. The next game state.\r\n */\r\nexport const gameStateReducer = (state: GameState = getNewState(), action: Action<GameActions>): GameState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n            return getNewState();\r\n        case GameActions.gameLost:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.gameMode = \"ended\";\r\n            });\r\n        case GameActions.nextLevel:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.level += 1;\r\n                draftObject.gameMode = \"paused\";\r\n            });\r\n        case GameActions.hitBlock:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.score += 1;\r\n            });\r\n        case GameActions.resume:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.gameMode = \"running\";\r\n            });\r\n        case GameActions.pause:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.gameMode = \"paused\";\r\n            });\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Creates a new GameState state\r\n * @returns {GameState}. A new game state.\r\n */\r\nconst getNewState = (): GameState => {\r\n    return { gameMode: \"paused\", level: 1, score: 0 };\r\n};\r\n","\r\nimport produce from \"immer\";\r\nimport { PaddleColor, PaddleHeightFactor, PaddlePositionFactor, PaddleWithFactor } from \"../Constants/Constants\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { PaddleState } from \"../State/Definition/PaddleState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles paddle actions\r\n * @param {PaddleState} state. The paddle state.\r\n * @param {ActionPayload<number> }action. An action to be performed on the paddle. Number is the 'left' coordinate of the paddle.\r\n * @returns {PaddleState}. Paddle state.\r\n */\r\nexport const paddleReducer = (state: PaddleState = getNewState(), action: ActionPayload<number>): PaddleState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n\r\n            return getNewState();\r\n\r\n        case GameActions.paddleMove:\r\n\r\n            return produce(state, (draftObject) => {\r\n\r\n                // Prevent the paddle from being drawn outside the playfield.\r\n                if (typeof (action.payload) !== \"undefined\") {\r\n\r\n                    let x;\r\n\r\n                    if (action.payload - state.width / 2 <= 0) {\r\n                        x = 0;\r\n                    } else if (action.payload - state.width / 2 >= (gameDimensions.size - state.width)) {\r\n                        x = gameDimensions.size - state.width;\r\n                    } else {\r\n                        x = action.payload - (state.width / 2);\r\n                    }\r\n\r\n                    draftObject.left = x;\r\n                }\r\n            });\r\n\r\n        case GameActions.nextLevel:\r\n            return produce(state, (draftObject) => {\r\n\r\n                // Redude the paddle size each level by 5%\r\n                const newWidth = draftObject.width * 0.95;\r\n\r\n                if (newWidth < gameDimensions.size / PaddleHeightFactor / 2) {\r\n                    // Paddle doesn't get smaller than half its size.\r\n                    return state;\r\n                } else {\r\n                    draftObject.width = newWidth;\r\n                }\r\n            });\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Generates a new state for the paddle\r\n * @returns {PaddleState}. A new state for the paddle\r\n */\r\nconst getNewState = (): PaddleState => {\r\n    return {\r\n        color: PaddleColor,\r\n        width: gameDimensions.size / PaddleHeightFactor,\r\n        height: gameDimensions.size / PaddleWithFactor,\r\n        top: gameDimensions.size * PaddlePositionFactor,\r\n        left: (gameDimensions.size / 2) - (gameDimensions.size / PaddleHeightFactor / 2),\r\n        isPaddle: true\r\n    };\r\n};","import { Howl } from \"howler\";\r\nimport produce from \"immer\";\r\nimport { Action } from \"redux\";\r\nimport { Bounce, HitBlock } from \"../Constants/Base64Audio\";\r\nimport { SoundState } from \"../State/Definition/SoundState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\n/**\r\n * Sound reducer. Handlers playing the sounds of the game when an action requires a sound.\r\n * @param {SoundState} state. The sound state. Never changes after initialization.\r\n * @param {GameActions} action. An action that requires a sound to be played.\r\n * @returns {SoundState}. The sound state.\r\n */\r\n\r\nexport const soundReducer = (state: SoundState = getNewState(), action: Action): SoundState => {\r\n    switch (action.type) {\r\n        case GameActions.hitBlock:\r\n            if (state.sounds) {\r\n                state.hitBlock.play();\r\n            }\r\n\r\n            break;\r\n        case GameActions.ballBounceHorizantally:\r\n        case GameActions.ballBounceVertically:\r\n            if (state.sounds) {\r\n                state.bounce.play();\r\n            }\r\n\r\n            break;\r\n        case GameActions.toggleSound:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.sounds = !draftObject.sounds;\r\n            });\r\n    }\r\n\r\n    return state;\r\n};\r\n\r\nconst getNewState = (): SoundState => {\r\n    const bounceSound = new Howl({ src: [\"data:audio/wav;base64,\" + Bounce] });\r\n    const hitBlockSound = new Howl({ src: [\"data:audio/wav;base64,\" + HitBlock] });\r\n\r\n    return {\r\n        bounce: bounceSound,\r\n        hitBlock: hitBlockSound,\r\n        sounds: true,\r\n    };\r\n};","import { combineReducers, createStore, ReducersMapObject, Store } from \"redux\";\r\nimport { ballReducer } from \"../Reducers/BallReducer\";\r\nimport { blockReducer } from \"../Reducers/BlockReducer\";\r\nimport { gameStateReducer } from \"../Reducers/GameStateReducer\";\r\nimport { paddleReducer } from \"../Reducers/PaddleReducer\";\r\nimport { soundReducer } from \"../Reducers/SoundReducer\";\r\nimport ActionPayload from \"./ActionPayLoad\";\r\nimport { AppState } from \"./Definition/AppState\";\r\n\r\n/**\r\n * All reducer that build the application state.\r\n */\r\nconst reducers: ReducersMapObject<AppState, ActionPayload<any>> = {\r\n    blockState: blockReducer,\r\n    paddle: paddleReducer,\r\n    ball: ballReducer,\r\n    gameState: gameStateReducer,\r\n    soundState: soundReducer,\r\n};\r\n\r\nconst allReducers = combineReducers(reducers);\r\n\r\nconst store = createStore<AppState, ActionPayload<any>, AppState, AppState>(allReducers);\r\n\r\n/**\r\n * Returns the store\r\n * @returns {Store}. The redux store.\r\n */\r\nexport const appStore = (): Store<AppState, ActionPayload<any>> => {\r\n    return store;\r\n};\r\n\r\n/**\r\n * Returns the State\r\n * @returns {AppState}. The application state.\r\n */\r\nexport const appState = (): AppState => {\r\n    return appStore().getState();\r\n};","import produce from \"immer\";\nimport React, { CSSProperties } from \"react\";\nimport { GameFieldBorderColor, GameTick } from \"./Constants/Constants\";\nimport { Walls } from \"./Constants/WallConstants\";\nimport { Block } from \"./Definitions/Block\";\nimport { GameObject } from \"./Definitions/GameObject\";\nimport { getGameDimensions } from \"./GameDimensions\";\nimport { getBounceAction, overlaps } from \"./Lib\";\nimport { AppState } from \"./State/Definition/AppState\";\nimport { BallState } from \"./State/Definition/BallState\";\nimport { GameActions } from \"./State/GameActions\";\nimport { appState, appStore } from \"./State/Store\";\n\nconst gameDimensions = getGameDimensions();\n\n/**\n * Main game component.\n */\nexport class Main extends React.Component<{}, AppState> {\n\n    /**\n     * Stores a reference to the animation that draws the game.\n     */\n    private tickHandler?: number;\n\n    /**\n     * Used to store the beginning of a game tick.\n     */\n    private tickStart?: number;\n\n    /**\n     * Refux subscription\n     */\n    private subscription?: () => void;\n\n    /**\n     * Initializes the Main component.\n     */\n    constructor(props: object) {\n        super(props);\n\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.onMouseClick = this.onMouseClick.bind(this);\n        this.tick = this.tick.bind(this);\n        this.onPlayAgain = this.onPlayAgain.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n\n        // Sync the redux state with the component state.\n        this.state = appState();\n    }\n\n    /**\n     * Called when the component mounted.\n     */\n    public componentDidMount(): void {\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n\n        window.addEventListener(\"mousemove\", this.onMouseMove);\n        window.addEventListener(\"click\", this.onMouseClick);\n        window.addEventListener(\"keyup\", this.onKeyUp);\n\n        this.subscription = appStore().subscribe(() => {\n            const applicationState = appState();\n\n            if (applicationState.gameState !== this.state.gameState) {\n                this.setState({ gameState: applicationState.gameState });\n\n                if (applicationState.gameState.gameMode === \"ended\") {\n                    if (this.tickHandler) {\n                        window.cancelAnimationFrame(this.tickHandler);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Called before the component unmounts.\n     */\n    public componentWillUnmount(): void {\n        if (this.tickHandler) {\n            window.cancelAnimationFrame(this.tickHandler);\n        }\n\n        window.removeEventListener(\"mousemove\", this.onMouseMove);\n        window.removeEventListener(\"click\", this.onMouseClick);\n\n        if (this.subscription) {\n            this.subscription();\n            delete this.subscription;\n        }\n    }\n\n    private onKeyUp(e: KeyboardEvent): void {\n        if (this.state.gameState.gameMode === \"running\") {\n            switch (e.code) {\n                case \"Space\":\n                    appStore().dispatch({ type: GameActions.pause });\n                    return;\n                case \"KeyW\":\n                    appStore().dispatch({ type: GameActions.nextLevel });\n                    return;\n            }\n        }\n\n        if (e.code === \"KeyS\") {\n            appStore().dispatch({ type: GameActions.toggleSound });\n        }\n    }\n\n    /**\n     * Handles mouse movement. Used to move the paddle.\n     * @param {MouseEvent} e. MouseEvent.\n     */\n    private onMouseMove(e: MouseEvent): void {\n        if (e) {\n            const x = e.clientX - gameDimensions.left;\n            appStore().dispatch({ type: GameActions.paddleMove, payload: x });\n        }\n    }\n\n    /**\n     * Event fires when the user clicks the mouse.\n     */\n    private onMouseClick(): void {\n        if (this.state.gameState.gameMode === \"paused\") {\n            appStore().dispatch({ type: GameActions.resume });\n            this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n        }\n    }\n\n    /**\n     * Handles a play again click.\n     */\n    private onPlayAgain(): void {\n        // Reset game state.\n        appStore().dispatch({ type: GameActions.reset });\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Handles a game tick.\n     * @param {number} tick. Current tick count.\n     */\n    public tick(tick: number): void {\n\n        if (!this.tickStart) {\n            this.tickStart = tick;\n        }\n\n        if (this.state.gameState.gameMode !== \"running\") {\n            return;\n        }\n\n        const diff = tick - this.tickStart;\n\n        // Redraw at 60 fps.\n        if (diff > GameTick) {\n            const ball = appState().ball;\n            const blocks = appState().blockState.blocks;\n            const paddle = appState().paddle;\n\n            if (blocks.length === 0) {\n                appStore().dispatch({ type: GameActions.nextLevel });\n            }\n\n            const paddleHit = overlaps(ball, paddle);\n\n            if (paddleHit) {\n                const paddleBounceAction = getBounceAction(ball, paddle);\n                appStore().dispatch({ type: paddleBounceAction, payload: paddle });\n\n            } else if (blocks) {\n\n                const hitBlock = blocks.find((b) => overlaps(ball, b) && b.hit === false);\n                if (hitBlock) {\n                    appStore().dispatch({ type: GameActions.hitBlock, payload: hitBlock });\n\n                    const action = getBounceAction(ball, hitBlock);\n\n                    if (typeof (action) !== \"undefined\") {\n                        appStore().dispatch({ type: action, payload: hitBlock });\n                    }\n\n                } else if (ball.top <= 0) {\n                    // The ball's top and left are inside the game field.\n                    // Use the game dimension object to store a wall hit.\n                    // Hit the top  wall\n                    appStore().dispatch({ type: GameActions.ballBounceHorizantally, payload: Walls.topWall });\n\n                } else if (ball.left <= 0) {\n                    // Hit the left wall\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.leftWall });\n                } else if (ball.left + ball.width >= gameDimensions.size) {\n                    // Hit the right wall\n\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.rightWall });\n                } else if (ball.top + ball.width >= gameDimensions.size) {\n                    // Hit bottom wall.\n                    appStore().dispatch({ type: GameActions.gameLost });\n                }\n            }\n\n            appStore().dispatch({ type: GameActions.tick });\n\n            const newComponentState = produce(this.state, (draftObject) => {\n                draftObject.ball = appState().ball;\n                draftObject.blockState = appState().blockState;\n                draftObject.gameState = appState().gameState;\n                draftObject.paddle = appState().paddle;\n                draftObject.soundState = appState().soundState;\n            });\n\n            this.setState(newComponentState);\n\n            this.tickStart = tick;\n        }\n\n        this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Returns the styling for the game field.\n     * @returns {CSSProperties}. CSSProperties for the gamefield.\n     */\n    private gameFieldStyle(): CSSProperties | undefined {\n\n        return {\n            position: \"absolute\",\n            left: getGameDimensions().left,\n            top: getGameDimensions().top,\n            width: getGameDimensions().size,\n            height: getGameDimensions().size,\n            borderColor: GameFieldBorderColor,\n            borderStyle: \"solid\",\n            display: \"flex\",\n            justifyContent: \"center\"\n        };\n    }\n\n    /**\n     * Game score style\n     * @returns {CSSProperties}. A style that will draw a rectangle above the game field.\n     */\n    private gameScorebarStyle(): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: getGameDimensions().left,\n            width: getGameDimensions().size,\n            top: getGameDimensions().top - 25,\n            height: 22,\n            borderColor: GameFieldBorderColor,\n            borderStyle: \"solid\",\n            display: \"flex\",\n            flexDirection: \"row\",\n        };\n    }\n\n    /**\n     * Returns css properties for positioning a shape.\n     * @param {ScreenObject} shape. A shape object.\n     * @returns {CSSProperties}. CSS properties for a shape.\n     */\n    private positionStyle(shape: GameObject): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: shape.left,\n            top: shape.top,\n            height: shape.height,\n            width: shape.width,\n            backgroundColor: shape.color,\n        };\n    }\n\n    private blockStyle(block: Block): CSSProperties {\n        const css = this.positionStyle(block);\n        css.backgroundColor = `rgba(${block.red}, ${block.green}, ${block.blue}, 1`;\n        return css;\n    }\n\n    /**\n     * Returns css properties for positioning and drawing the ball.\n     * @param {BallState} ball.\n     * @returns {CSSProperties}.\n     */\n    private ballStyle(ball: BallState): CSSProperties {\n        const newPosition = this.positionStyle(ball);\n        newPosition.borderRadius = \"50%\";\n        newPosition.backgroundImage = ball.color;\n        return newPosition;\n    }\n\n    /**\n     * Renders the component.\n     */\n    public render(): React.ReactNode {\n        return (\n            <div>\n                <div style={this.gameScorebarStyle()} >\n                    <div style={{ width: \"10%\", color: \"white\", marginTop: \"3px\", marginLeft: \"10px\" }}>Level: {this.state.gameState.level}</div>>\n                    <div style={{ width: \"10%\", color: \"white\", marginTop: \"3px\", }}>Score: {this.state.gameState.score}</div>>\n                    <div style={{ width: \"80%\", color: \"white\", marginRight: \"10px\", marginTop: \"3px\", textAlign: \"right\" }}>Press S to turn sound {this.state.soundState.sounds ? \"off\" : \"on\"}</div>\n                </div>\n                <>\n                    {\n                        this.state.blockState && this.state.paddle && this.state.ball ?\n                            <div style={this.gameFieldStyle()}>\n                                {\n                                    this.state.blockState.blocks.map((b, index) => <div key={index} style={this.blockStyle(b)} />)\n                                }\n                                <div style={this.positionStyle(this.state.paddle)} />\n                                <div style={this.ballStyle(this.state.ball)} />\n                                {\n                                    this.state.gameState.gameMode === \"ended\" ?\n                                        <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"center\" }}>\n                                            <p style={{ alignSelf: \"center\", color: \"white\" }}>Game over</p>\n                                            <button onClick={this.onPlayAgain} style={{ alignSelf: \"center\" }}>Play again</button>\n                                        </div> :\n                                        this.state.gameState.gameMode === \"paused\" ?\n                                            <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"center\" }}>\n                                                <p style={{ alignSelf: \"center\", color: \"white\" }}>Click the left mouse button to resume.</p>\n                                            </div> : null\n                                }\n\n                            </div> : null\n                    }\n                </>\n            </div>\n        );\n    }\n}\n\nexport default Main;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Main from \"./Main\";\n\nReactDOM.render(<Main />, document.getElementById(\"root\"));\n"],"sourceRoot":""}