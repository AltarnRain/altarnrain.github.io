{"version":3,"sources":["GameDimensions.ts","State/GameActions.ts","Constants.ts","Lib.ts","Guard.ts","Reducers/BallReducer.ts","Reducers/BlockReducer.ts","Reducers/PaddleReducer.ts","Store.ts","Reducers/GameStateReducer.ts","WallConstants.ts","Main.tsx","index.tsx"],"names":["gameDimensions","GameActions","DegreeToRadian","Math","PI","InitialBallVelocity","BallResizeFactor","NumberOfBlockColumns","WindowResizeConstant","PaddleWithFactor","PaddleHeightFactor","PaddlePositionFactor","BallSpeedIncreasePerBlock","BallSpeedIncreasePerLevel","getGameDimensions","size","window","innerHeight","innerWidth","left","top","blockHeight","blockWidth","getInitialBlocks","blocks","index","r","c","block","color","x","y","height","width","push","overlaps","shape1","shape2","left1","ceil","right1","floor","top1","bottom1","left2","right2","top2","bottom2","angleRandomizer","angleManipulator","random","getBounceAction","ball","shape","right","bottom","cx","cy","x1","x2","y1","y2","withinVerticalBounds","withinHorizantalBounds","directions","angle","returnValue","getNextX","getNextY","getDirectionFromAngle","goingLeft","some","d","goingRight","goingUp","goingDown","ballBounceHorizantally","ballBounceVertically","console","log","changeAngle","paddle","abs","distance","currentY","sin","currentX","cos","Guard","isPaddle","value","reducers","state","action","type","initialize","nextLevel","newState","forEach","b","hitBlock","filter","payload","paddleMove","velocity","lastObject","tick","angleChange","gameState","gameMode","level","score","gameLost","allReducers","combineReducers","store","createStore","appStore","appState","getState","Walls","leftWall","rightWall","topWall","bottomWall","Main","props","tickHandler","tickStart","subscription","onMouseMove","bind","onPlayAgain","e","clientX","dispatch","this","requestAnimationFrame","length","paddleBounceAction","find","setState","addEventListener","subscribe","applicationState","cancelAnimationFrame","removeEventListener","position","borderColor","borderStyle","display","justifyContent","flexDirection","backgroundColor","newPosition","positionStyle","borderRadius","style","gameScorebarStyle","key","marginLeft","gameFieldStyle","map","ballStyle","alignSelf","onClick","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.f42dddb6.chunk.js","sourcesContent":["/**\r\n * Provides game dimensions.\r\n */\r\n\r\nimport { NumberOfBlockColumns, WindowResizeConstant } from \"./Constants\";\r\nimport { GameDimensions } from \"./State/GameDimensions\";\r\n\r\nlet gameDimensions: GameDimensions;\r\n\r\nexport function getGameDimensions(): GameDimensions {\r\n    if (!gameDimensions) {\r\n        let size = 0;\r\n\r\n        if (window.innerHeight > window.innerWidth) {\r\n            size = window.innerWidth * WindowResizeConstant;\r\n        } else {\r\n            size = window.innerHeight * WindowResizeConstant;\r\n        }\r\n\r\n        const left = (window.innerWidth / 2) - (size / 2);\r\n        const top = (window.innerHeight / 2) - (size / 2);\r\n        const blockHeight = size / (NumberOfBlockColumns * 2);\r\n        const blockWidth = size / NumberOfBlockColumns;\r\n\r\n        gameDimensions = { left, top, size, blockHeight, blockWidth, };\r\n    }\r\n\r\n    return gameDimensions;\r\n}","export enum GameActions {\r\n    initialize,\r\n    hitBlock,\r\n    paddleMove,\r\n    tick,\r\n    ballBounceHorizantally,\r\n    ballBounceVertically,\r\n    gameLost,\r\n    nextLevel,\r\n}","\r\n/**\r\n * A constants used to convert the angle from degree's to radians.\r\n */\r\nexport const DegreeToRadian = Math.PI / 180;\r\n\r\n/**\r\n * A constants that contains the time in milli second for a frame.\r\n */\r\nexport const GameTick = 1000 / 60;\r\n\r\n/**\r\n * Constants for the initial ball velocity.\r\n */\r\nexport const InitialBallVelocity = 10;\r\n\r\n/**\r\n * Constants used in a calculation to randomize the ball's initial angle.\r\n */\r\nexport const BallAngleStartRandomFactor = 10;\r\n\r\n/**\r\n * Constants used in calculation the width and height of the ball relative to the game field diminsions.\r\n */\r\nexport const BallResizeFactor = 0.02;\r\n\r\n/**\r\n * A Constants used ina calculation to increase or decrease the angle of the ball depending on where it hits the paddle.\r\n */\r\nexport const BounceAngleIncreaseConstant = 40;\r\n\r\n/**\r\n * The number of blocks from top to bottom\r\n */\r\nexport const NumberOfBlockRows = 5;\r\n\r\n/**\r\n * The number of blocks from left to right.\r\n */\r\nexport const NumberOfBlockColumns = 12;\r\n\r\n/**\r\n * Constant to used to calculate the size of the playing field.\r\n */\r\nexport const WindowResizeConstant = 0.9;\r\n\r\n/**\r\n * Used to calculate the paddle with relative to the game field width.\r\n */\r\nexport const PaddleWithFactor = 40;\r\n\r\n/**\r\n * Used to calculate the height of the paddle relative to the game field height.\r\n */\r\nexport const PaddleHeightFactor = 10;\r\n\r\n/**\r\n * Used to calculate the paddle's top coordinate relative to the game field height.\r\n */\r\nexport const PaddlePositionFactor = 0.9;\r\n\r\n/**\r\n * Speed increase factor for each hit block\r\n */\r\nexport const BallSpeedIncreasePerBlock = 1.02;\r\n\r\n/**\r\n * Speed increase factor for each level.\r\n */\r\nexport const BallSpeedIncreasePerLevel = 0.5;","import { BallAngleStartRandomFactor, BounceAngleIncreaseConstant, DegreeToRadian, NumberOfBlockColumns, NumberOfBlockRows } from \"./Constants\";\r\nimport { Ball } from \"./Definitions/Ball\";\r\nimport { Block } from \"./Definitions/Block\";\r\nimport { Direction } from \"./Definitions/Direction\";\r\nimport { ScreenObject } from \"./Definitions/ScreenObject\";\r\nimport { GameActions } from \"./State/GameActions\";\r\n\r\n/**\r\n * Returns the initial block setup.\r\n * @returns {Block[]}.\r\n */\r\nexport const getInitialBlocks = (): Block[] => {\r\n\r\n    const blocks: Block[] = [];\r\n\r\n    let index = 0;\r\n    for (let r = 0; r < NumberOfBlockRows; r++) {\r\n        index++;\r\n        for (let c = 0; c < NumberOfBlockColumns; c++) {\r\n            const block: Block = {\r\n                color: index % 2 === 0 ? \"red\" : \"blue\",\r\n                x: c,\r\n                y: r,\r\n                left: 0,\r\n                top: 0,\r\n                height: 0,\r\n                width: 0\r\n            };\r\n\r\n            index++;\r\n            blocks.push(block);\r\n        }\r\n    }\r\n\r\n    return blocks;\r\n};\r\n\r\n/**\r\n * Checks if two shapes overlap\r\n * @param {ScreenObject} shape1. A Shape.\r\n * @param {ScreenObject} shape2. A Shape\r\n */\r\nexport const overlaps = (shape1: ScreenObject, shape2: ScreenObject) => {\r\n\r\n    const left1 = Math.ceil(shape1.left);\r\n    const right1 = Math.floor(shape1.left + shape1.width);\r\n    const top1 = Math.ceil(shape1.top);\r\n    const bottom1 = Math.floor(shape1.top + shape1.height);\r\n\r\n    const left2 = Math.ceil(shape2.left);\r\n    const right2 = Math.floor(shape2.left + shape2.width);\r\n    const top2 = Math.ceil(shape2.top);\r\n    const bottom2 = Math.floor(shape2.top + shape2.height);\r\n\r\n    if (bottom1 < top2 || top1 > bottom2) {\r\n        return false;\r\n    }\r\n\r\n    if (right2 < left1 || left2 > right1) {\r\n        return false;\r\n    }\r\n\r\n    // Rectangles overlap\r\n    return true;\r\n};\r\n\r\n/**\r\n * Randomizes an angle.\r\n * @returns {number}. A number that can be added to an angle to slightly change it.\r\n */\r\nexport const angleRandomizer = (): number => {\r\n    const angleManipulator = (Math.random() * BallAngleStartRandomFactor);\r\n    if (Math.random() >= 0.5) {\r\n        return angleManipulator;\r\n    } else {\r\n        return angleManipulator * -1;\r\n    }\r\n};\r\n\r\n/**\r\n * Determine the right action to dispatch when the ball bounces off an object.\r\n * @param {Ball} ball. Ball object.\r\n * @param {ScreenObject} shape. A shape object.\r\n * @returns {GameActions}. The bounce action or undefined if no bounce action could be determined.\r\n */\r\nexport const getBounceAction = (ball: Ball, shape: ScreenObject): GameActions.ballBounceHorizantally | GameActions.ballBounceVertically => {\r\n\r\n    const left = shape.left;\r\n    const right = shape.left + shape.width;\r\n    const top = shape.top;\r\n    const bottom = shape.top + shape.height;\r\n\r\n    const cx = ball.left + (ball.width / 2);\r\n    const cy = ball.top + (ball.height / 2);\r\n\r\n    const x1 = ball.left;\r\n    const x2 = ball.left + ball.width;\r\n\r\n    const y1 = ball.top;\r\n    const y2 = ball.top + ball.height;\r\n\r\n    const withinVerticalBounds = (x1 > left || x2 < right);\r\n    const withinHorizantalBounds = (y1 > top || y2 < bottom);\r\n\r\n    const directions = getDirectionFromAngle(ball.angle);\r\n\r\n    const goingLeft = directions.some((d) => d === \"left\");\r\n    const goingRight = directions.some((d) => d === \"right\");\r\n    const goingUp = directions.some((d) => d === \"up\");\r\n    const goingDown = directions.some((d) => d === \"down\");\r\n\r\n    // Most times the top or bottom of a ScreenObject will be hit so check those first.\r\n    if (goingUp && cy > bottom && withinHorizantalBounds) {\r\n        return GameActions.ballBounceHorizantally;\r\n        // bottom\r\n    } else if (goingDown && cy < top && withinHorizantalBounds) {\r\n        // Top\r\n        return GameActions.ballBounceHorizantally;\r\n    } else if (goingLeft && cx > right && withinVerticalBounds) {\r\n        // Right\r\n        return GameActions.ballBounceVertically;\r\n    } else if (goingRight && cx < left && withinVerticalBounds) {\r\n        // Left\r\n        return GameActions.ballBounceVertically;\r\n    }\r\n\r\n    // tslint:disable-next-line: no-console\r\n    console.log(\"Failed hit detection\");\r\n    return GameActions.ballBounceHorizantally;\r\n};\r\n\r\n/**\r\n * Changes the angle based on the position of impact.\r\n * @param {Ball} ball. A ball object\r\n * @param {Paddle} paddle. A paddle object\r\n */\r\nexport const changeAngle = (ball: ScreenObject, paddle: ScreenObject): number => {\r\n    const p = Math.abs(ball.left - paddle.left);\r\n\r\n    // calculate a factor based on the shape's width. Since this is a horizantol hit, this results in a\r\n    // number between 0 and 1.\r\n    const v = p / paddle.width;\r\n    const returnValue = BounceAngleIncreaseConstant * (0.5 - v) * -1;\r\n    return returnValue;\r\n};\r\n\r\nexport function getNextY(angle: number, distance: number, currentY: number) {\r\n    return Math.sin(angle * DegreeToRadian * -1) * distance + currentY;\r\n}\r\n\r\nexport function getNextX(angle: number, distance: number, currentX: number) {\r\n    return Math.cos(angle * DegreeToRadian * -1) * distance + currentX;\r\n}\r\n\r\nexport function getDirectionFromAngle(angle: number): Direction[] {\r\n\r\n    // A ball can travel at two directions at most so the return\r\n    // Value has to be an array with a size of 1 or two.\r\n    const returnValue: Direction[] = [];\r\n\r\n    const x = getNextX(angle, 10, 0);\r\n    const y = getNextY(angle, 10, 0);\r\n\r\n    if (x > 0) {\r\n        // Ball travels to the right\r\n        returnValue.push(\"right\");\r\n    }\r\n\r\n    if (x < 0) {\r\n        // Ball travels to the left.\r\n        returnValue.push(\"left\");\r\n    }\r\n\r\n    if (y > 0) {\r\n        // Ball travels down.\r\n        returnValue.push(\"down\");\r\n    }\r\n\r\n    if (y < 0) {\r\n        returnValue.push(\"up\");\r\n    }\r\n\r\n    return returnValue;\r\n\r\n}","import { Paddle } from \"./Definitions/Paddle\";\r\n\r\n/**\r\n * A constats that contains type guards.\r\n */\r\nexport const Guard = {\r\n\r\n    /**\r\n     * Typeguard for determining if a shape is actually the paddle.\r\n     * @returns {boolean}. True if the object is a paddle, false otherwise.\r\n     */\r\n    isPaddle: (value: any): value is Paddle => {\r\n        return value && value.isPaddle;\r\n    }\r\n};","import { BallResizeFactor, BallSpeedIncreasePerBlock, BallSpeedIncreasePerLevel, InitialBallVelocity } from \"../Constants\";\r\nimport { Ball } from \"../Definitions/Ball\";\r\nimport { ScreenObject } from \"../Definitions/ScreenObject\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { Guard } from \"../Guard\";\r\nimport { angleRandomizer, changeAngle, getNextX, getNextY } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles ball actions.\r\n */\r\nexport function ballReducer(state: Ball = {} as Ball, action: ActionPayload<ScreenObject>): Ball {\r\n\r\n    switch (action.type) {\r\n        case GameActions.initialize: {\r\n            const angle = 90 + angleRandomizer();\r\n            return {\r\n                angle,\r\n                color: \"yellow\",\r\n                height: gameDimensions.size * BallResizeFactor,\r\n                width: gameDimensions.size * BallResizeFactor,\r\n                left: (gameDimensions.size / 2) - (gameDimensions.size * BallResizeFactor / 2),\r\n                top: (gameDimensions.size / 2) - (gameDimensions.size * BallResizeFactor / 2),\r\n                velocity: InitialBallVelocity,\r\n                lastObject: {},\r\n            };\r\n        }\r\n\r\n        case GameActions.tick: {\r\n            const x = getNextX(state.angle, state.velocity, state.left);\r\n            const y = getNextY(state.angle, state.velocity, state.top);\r\n\r\n            return { ...state, left: x, top: y };\r\n        }\r\n\r\n        case GameActions.ballBounceHorizantally:\r\n        case GameActions.ballBounceVertically: {\r\n\r\n            if (action.payload && action.payload !== state.lastObject) {\r\n                let angle = state.angle;\r\n                let angleChange = 1;\r\n\r\n                if (action.type === GameActions.ballBounceHorizantally) {\r\n\r\n                    // If the baddle is hit we want the ball's angle to increase if it hit\r\n                    // the edges.\r\n                    if (Guard.isPaddle(action.payload)) {\r\n\r\n                        // calculate where the ball hit relative to the shape from the left size.\r\n                        angleChange = changeAngle(state, action.payload);\r\n                    }\r\n\r\n                    // When the ball top or bottom makes contact, multiply the current angle by -1 for it to bounce.\r\n                    angle = (angle + angleChange) * -1;\r\n                } else {\r\n                    if (action.payload && action.payload !== state.lastObject) {\r\n                        // If the ball hits a side, the new angle is 180 - current angle.\r\n                        angle = 180 - angle;\r\n                    }\r\n                }\r\n\r\n                return { ...state, angle, lastObject: action.payload };\r\n            }\r\n\r\n            return state;\r\n        }\r\n\r\n        case GameActions.hitBlock:\r\n            // Increase the ball speed for each hit block\r\n            return { ...state, velocity: state.velocity * BallSpeedIncreasePerBlock };\r\n        case GameActions.nextLevel:\r\n            // Increase ball speed for each level.\r\n            return { ...state, velocity: state.velocity + BallSpeedIncreasePerLevel };\r\n        default:\r\n            return state;\r\n    }\r\n}","import { Block } from \"../Definitions/Block\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { getInitialBlocks } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\nexport function blockReducer(state: Block[] = [], action: ActionPayload<Block>): Block[] {\r\n    switch (action.type) {\r\n        case GameActions.initialize:\r\n        case GameActions.nextLevel:\r\n\r\n            const newState = getInitialBlocks();\r\n\r\n            newState.forEach((b) => {\r\n                b.height = gameDimensions.blockHeight;\r\n                b.width = gameDimensions.blockWidth;\r\n                b.left = b.x * gameDimensions.blockWidth;\r\n                b.top = b.y * gameDimensions.blockHeight;\r\n            });\r\n\r\n            return newState;\r\n        case GameActions.hitBlock:\r\n            return state.filter((b) => b !== action.payload);\r\n        default:\r\n            return state;\r\n    }\r\n}","\r\nimport { PaddleHeightFactor, PaddlePositionFactor, PaddleWithFactor } from \"../Constants\";\r\nimport { Paddle } from \"../Definitions/Paddle\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles paddle actions\r\n * @param {Paddle} state. The paddle state.\r\n * @param {ActionPayload<number> }action. An action to be performed on the paddle. Number is the 'left' coordinate of the paddle.\r\n */\r\nexport function paddleReducer(state: Paddle = { isPaddle: true } as Paddle, action: ActionPayload<number>): Paddle {\r\n    switch (action.type) {\r\n        case GameActions.initialize:\r\n\r\n            const height = gameDimensions.size / PaddleWithFactor;\r\n            const width = gameDimensions.size / PaddleHeightFactor;\r\n            const left = (gameDimensions.size / 2) - (width / 2);\r\n            const top = gameDimensions.size * PaddlePositionFactor;\r\n\r\n            return {\r\n                color: \"white\",\r\n                width,\r\n                top,\r\n                left,\r\n                height,\r\n                isPaddle: true\r\n            };\r\n\r\n        case GameActions.paddleMove:\r\n\r\n            // Prevent the paddle from being drawn outside the playfield.\r\n            if (typeof (action.payload) !== \"undefined\") {\r\n\r\n                let x;\r\n\r\n                if (action.payload - state.width / 2 <= 0) {\r\n                    x = 0;\r\n                } else if (action.payload - state.width / 2 >= (gameDimensions.size - state.width)) {\r\n                    x = gameDimensions.size - state.width;\r\n                } else {\r\n                    x = action.payload - (state.width / 2);\r\n                }\r\n\r\n                if (state.left === x) {\r\n                    return state;\r\n                } else {\r\n                    const newState = { ...state, left: x };\r\n                    return newState;\r\n                }\r\n            } else {\r\n                return state;\r\n            }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}","import { combineReducers, createStore, ReducersMapObject, Store } from \"redux\";\r\nimport { gameStateReducer } from \"./Reducers/GameStateReducer\";\r\nimport { ballReducer } from \"./Reducers/BallReducer\";\r\nimport { blockReducer } from \"./Reducers/BlockReducer\";\r\nimport { paddleReducer } from \"./Reducers/PaddleReducer\";\r\nimport ActionPayload from \"./State/ActionPayLoad\";\r\nimport { AppState } from \"./State/AppState\";\r\n\r\nconst reducers: ReducersMapObject<AppState, ActionPayload<any>> = {\r\n    blocks: blockReducer,\r\n    paddle: paddleReducer,\r\n    ball: ballReducer,\r\n    gameState: gameStateReducer\r\n};\r\n\r\nconst allReducers = combineReducers(reducers);\r\n\r\nconst store = createStore<AppState, ActionPayload<any>, AppState, AppState>(allReducers);\r\n\r\n/**\r\n * Returns the store\r\n * @returns {Store}. The redux store.\r\n */\r\nexport function appStore(): Store<AppState, ActionPayload<any>> {\r\n    return store;\r\n}\r\n\r\n/**\r\n * Returns the State\r\n * @returns {AppState}. The application state.\r\n */\r\nexport function appState(): AppState {\r\n    return appStore().getState();\r\n}","import { Action } from \"redux\";\r\nimport { GameState } from \"../Definitions/GameState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\n/**\r\n * Miscellaneous reducer.\r\n */\r\nexport function gameStateReducer(state: GameState = {} as GameState, action: Action<GameActions>): GameState {\r\n    switch (action.type) {\r\n        case GameActions.initialize:\r\n            return { gameMode: \"running\", level: 1, score: 0 };\r\n        case GameActions.gameLost:\r\n            return { ...state, gameMode: \"ended\" };\r\n        case GameActions.nextLevel:\r\n            return { ...state, level: state.level + 1 };\r\n        case GameActions.hitBlock:\r\n            return { ...state, score: state.score + 1 };\r\n        default:\r\n            return state;\r\n    }\r\n}","\r\n/**\r\n * A constant object that has an object for each wall. Used to eliminate double bounces.\r\n */\r\nexport const Walls = {\r\n    leftWall: {},\r\n    rightWall: {},\r\n    topWall: {},\r\n    bottomWall: {}\r\n};","import React, { CSSProperties } from \"react\";\nimport { GameTick } from \"./Constants\";\nimport { Ball } from \"./Definitions/Ball\";\nimport { GameObject } from \"./Definitions/GameObject\";\nimport { getGameDimensions } from \"./GameDimensions\";\nimport { getBounceAction, overlaps } from \"./Lib\";\nimport { State } from \"./State\";\nimport { GameActions } from \"./State/GameActions\";\nimport { appState, appStore } from \"./Store\";\nimport { Walls } from \"./WallConstants\";\n\nconst gameDimensions = getGameDimensions();\n\n/**\n * Main game component.\n */\nexport class Main extends React.Component<{}, State> {\n\n    /**\n     * Stores a reference to the animation that draws the game.\n     */\n    private tickHandler?: number;\n\n    /**\n     * Used to store the beginning of a game tick.\n     */\n    private tickStart?: number;\n\n    /**\n     * Refux subscription\n     */\n    private subscription?: () => void;\n\n    /**\n     * Initializes the Main component.\n     */\n    constructor(props: object) {\n        super(props);\n\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.tick = this.tick.bind(this);\n        this.onPlayAgain = this.onPlayAgain.bind(this);\n\n        this.state = { gameState: { gameMode: \"running\", level: 1, score: 0 } };\n    }\n\n    /**\n     * Handles mouse movement. Used to move the paddle.\n     * @param {MouseEvent} e. MouseEvent.\n     */\n    private onMouseMove(e: MouseEvent): void {\n        if (e) {\n            const x = e.clientX - gameDimensions.left;\n            appStore().dispatch({ type: GameActions.paddleMove, payload: x });\n        }\n    }\n\n    /**\n     * Handles a play again click.\n     */\n    private onPlayAgain(): void {\n        // Reset game state.\n\n        appStore().dispatch({ type: GameActions.initialize });\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Handles a game tick.\n     * @param {number} tick. Current tick count.\n     */\n    public tick(tick: number): void {\n\n        if (!this.tickStart) {\n            this.tickStart = tick;\n        }\n\n        if (this.state.gameState.gameMode === \"ended\") {\n            return;\n        }\n\n        const diff = tick - this.tickStart;\n\n        // Redraw at 60 fps.\n        if (diff > GameTick) {\n            const ball = appState().ball;\n            const blocks = appState().blocks;\n            const paddle = appState().paddle;\n\n            if (blocks.length === 0) {\n                appStore().dispatch({ type: GameActions.nextLevel});\n            }\n\n            const paddleHit = overlaps(ball, paddle);\n\n            if (paddleHit) {\n                const paddleBounceAction = getBounceAction(ball, paddle);\n                appStore().dispatch({ type: paddleBounceAction, payload: paddle });\n            } else if (blocks) {\n\n                const hitBlock = blocks.find((b) => overlaps(ball, b));\n                if (hitBlock) {\n                    appStore().dispatch({ type: GameActions.hitBlock, payload: hitBlock });\n\n                    const action = getBounceAction(ball, hitBlock);\n\n                    if (typeof (action) !== \"undefined\") {\n                        appStore().dispatch({ type: action, payload: hitBlock });\n                    }\n\n                } else if (ball.top <= 0) {\n                    // The ball's top and left are inside the game field.\n                    // Use the game dimension object to store a wall hit.\n                    // Hit the top  wall\n                    appStore().dispatch({ type: GameActions.ballBounceHorizantally, payload: Walls.topWall });\n\n                } else if (ball.left <= 0) {\n                    // Hit the left wall\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.leftWall });\n\n                } else if (ball.left + ball.width >= gameDimensions.size) {\n                    // Hit the right wall\n\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.rightWall });\n                } else if (ball.top + ball.width >= gameDimensions.size) {\n                    // Hit bottom wall.\n                    appStore().dispatch({ type: GameActions.gameLost });\n                }\n            }\n\n            appStore().dispatch({ type: GameActions.tick });\n\n            this.setState({ ball: appState().ball, blocks: appState().blocks, paddle: appState().paddle });\n            this.tickStart = tick;\n        }\n\n        this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Called when the component mounted.\n     */\n    public componentDidMount(): void {\n\n        appStore().dispatch({ type: GameActions.initialize });\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n\n        window.addEventListener(\"mousemove\", this.onMouseMove);\n\n        this.subscription = appStore().subscribe(() => {\n            const applicationState = appState();\n\n            if (applicationState.gameState !== this.state.gameState) {\n                this.setState({ gameState: applicationState.gameState });\n\n                if (applicationState.gameState.gameMode === \"ended\") {\n                    if (this.tickHandler) {\n                        window.cancelAnimationFrame(this.tickHandler);\n                    }\n                }\n            }\n\n        });\n    }\n\n    /**\n     * Called before the component unmounts.\n     */\n    public componentWillUnmount(): void {\n        if (this.tickHandler) {\n            window.cancelAnimationFrame(this.tickHandler);\n        }\n\n        window.removeEventListener(\"mousemove\", this.onMouseMove);\n\n        if (this.subscription) {\n            this.subscription();\n            delete this.subscription;\n        }\n    }\n\n    /**\n     * Returns the styling for the game field.\n     * @returns {CSSProperties}. CSSProperties for the gamefield.\n     */\n    private gameFieldStyle(): CSSProperties | undefined {\n\n        return {\n            position: \"absolute\",\n            left: gameDimensions.left,\n            top: gameDimensions.top,\n            width: gameDimensions.size,\n            height: gameDimensions.size,\n            borderColor: \"white\",\n            borderStyle: \"solid\",\n            display: \"flex\",\n            justifyContent: \"center\"\n        };\n    }\n\n    private gameScorebarStyle(): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: gameDimensions.left,\n            width: gameDimensions.size,\n            top: gameDimensions.top - 25,\n            height: 22,\n            borderColor: \"white\",\n            borderStyle: \"solid\",\n            display: \"flex\",\n            flexDirection: \"row\",\n        };\n    }\n\n    /**\n     * Returns css properties for positioning a shape.\n     * @param {ScreenObject} shape. A shape object.\n     * @returns {CSSProperties}.\n     */\n    private positionStyle(shape: GameObject): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: shape.left,\n            top: shape.top,\n            height: shape.height,\n            width: shape.width,\n            backgroundColor: shape.color,\n        };\n    }\n\n    /**\n     * Returns css properties for positioning and drawing the ball.\n     * @param {Ball} ball.\n     * @returns {CSSProperties}.\n     */\n    private ballStyle(ball: Ball): CSSProperties {\n        const newPosition = this.positionStyle(ball);\n        newPosition.borderRadius = \"50%\";\n\n        return newPosition;\n    }\n\n    /**\n     * Renders the component.\n     */\n    public render(): React.ReactNode[] {\n        return [\n            <div style={this.gameScorebarStyle()}>\n                <div key={1} style={{ color: \"white\", justifyContent: \"center\", marginLeft: \"10px\" }}>Level: {this.state.gameState.level}</div>>\n                <div key={2} style={{ color: \"white\", justifyContent: \"center\" }}>Score: {this.state.gameState.score}</div>>\n            </div>,\n            <div style={this.gameFieldStyle()}>\n                {\n                    this.state.blocks ? this.state.blocks.map((b, index) => <div key={index} style={this.positionStyle(b)} />) : null\n                }\n                {\n                    this.state.paddle ? <div style={this.positionStyle(this.state.paddle)} /> : null\n                }\n                {\n                    this.state.ball ? <div style={this.ballStyle(this.state.ball)} /> : null\n                }\n                {\n                    this.state.gameState.gameMode === \"ended\" ?\n                        <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"center\" }}>\n                            <p style={{ alignSelf: \"center\", color: \"white\" }}>Game over</p>\n                            <button onClick={this.onPlayAgain} style={{ alignSelf: \"center\" }}>Play again</button>\n                        </div>\n                        : null\n                }\n            </div>\n        ];\n    }\n}\n\nexport default Main;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Main from \"./Main\";\n\nReactDOM.render(<Main />, document.getElementById(\"root\"));\n"],"sourceRoot":""}