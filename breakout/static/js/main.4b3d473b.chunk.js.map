{"version":3,"sources":["GameDimensions.ts","State/GameActions.ts","Constants/Constants.ts","Constants/WallConstants.ts","Lib.ts","Guard.ts","Reducers/BallReducer.ts","Reducers/BlockReducer.ts","Reducers/GameStateReducer.ts","Reducers/PaddleReducer.ts","Reducers/SoundReducer.ts","State/Store.ts","Main.tsx","index.tsx"],"names":["gameDimensions","GameActions","DegreeToRadian","Math","PI","Walls","leftWall","rightWall","topWall","bottomWall","getGameDimensions","size","window","innerHeight","innerWidth","left","top","getBlocks","numberOfBlockRows","numberOfBlockColumns","red","blue","redAdd","blueAdd","blocks","r","c","block","color","x","y","height","width","hit","green","greenAdd","push","overlaps","shape1","shape2","left1","ceil","right1","floor","top1","bottom1","left2","right2","top2","bottom2","getBounceAction","ball","shape","hitSide","getHitSide","ballBounceVertically","ballBounceHorizantally","console","log","shapeLeft","shapeRight","shapeTop","shapeBottom","ballLeft","ballRight","ballTop","withinVerticalBounds","withinHorizantalBounds","directions","getDirectionFromAngle","angle","goingLeft","some","d","goingRight","goingUp","goingDown","changeAngle","paddle","abs","getNextY","distance","currentY","sin","getNextX","currentX","cos","returnValue","Guard","value","isPaddle","getBallSize","getNewState","angleManipulator","random","angleRandomizer","velocity","lastObject","rows","columns","calculateBlockWidth","calculateBlockHeight","forEach","b","gameMode","level","score","bounce","Howl","src","hitBlock","reducers","blockState","state","action","type","reset","nextLevel","nextLevelState","produce","draftObject","payload","hitBlockIndex","indexOf","tick","hitBlocks","filter","length","widthReductionFactor","heightReductionFactor","splice","paddleMove","newWidth","draftState","angleChange","gameState","gameLost","resume","pause","soundState","play","allReducers","combineReducers","store","createStore","appStore","appState","getState","Main","props","tickHandler","tickStart","subscription","onMouseMove","bind","onMouseClick","onPlayAgain","onKeyUp","this","requestAnimationFrame","addEventListener","subscribe","applicationState","setState","cancelAnimationFrame","removeEventListener","e","code","dispatch","clientX","paddleBounceAction","find","newComponentState","position","borderColor","borderStyle","display","justifyContent","flexDirection","backgroundColor","css","positionStyle","newPosition","borderRadius","backgroundImage","style","gameScorebarStyle","key","marginLeft","gameFieldStyle","map","index","blockStyle","ballStyle","alignSelf","onClick","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.4b3d473b.chunk.js","sourcesContent":["/**\r\n * Provides game dimensions.\r\n */\r\n\r\nimport { WindowResizeConstant } from \"./Constants/Constants\";\r\nimport { GameDimensions } from \"./Definitions/GameDimensions\";\r\n\r\nlet gameDimensions: GameDimensions;\r\n\r\nexport const getGameDimensions = (): GameDimensions => {\r\n    if (!gameDimensions) {\r\n        let size = 0;\r\n\r\n        if (window.innerHeight > window.innerWidth) {\r\n            size = window.innerWidth * WindowResizeConstant;\r\n        } else {\r\n            size = window.innerHeight * WindowResizeConstant;\r\n        }\r\n\r\n        const left = (window.innerWidth / 2) - (size / 2);\r\n        const top = (window.innerHeight / 2) - (size / 2);\r\n\r\n        gameDimensions = { left, top, size };\r\n    }\r\n\r\n    return gameDimensions;\r\n};","export enum GameActions {\r\n    /**\r\n     * An action that instructs the reducers to return an initial objects to play the game.\r\n     */\r\n    reset,\r\n    /**\r\n     * Dispatched when a block is hit.\r\n     */\r\n    hitBlock,\r\n    /**\r\n     * Dispatched when the user moves the mouse causing th paddle to move.\r\n     */\r\n    paddleMove,\r\n    /**\r\n     * Dispatch for a game tick.\r\n     */\r\n    tick,\r\n    /**\r\n     * Dispatchen when the ball bounces of top or bottom of an object.\r\n     */\r\n    ballBounceHorizantally,\r\n    /**\r\n     * Dispatched when the ball bounces of the side of an object.\r\n     */\r\n    ballBounceVertically,\r\n    /**\r\n     * Dispatched when the ball hits the bottom of the play field.\r\n     */\r\n    gameLost,\r\n    /**\r\n     * Dispatched when all the blocks are cleared.\r\n     */\r\n    nextLevel,\r\n    /**\r\n     * Resume the game.\r\n     */\r\n    resume,\r\n\r\n    /**\r\n     * An action that pauses the game\r\n     */\r\n    pause\r\n}","\r\n/**\r\n * A constants used to convert the angle from degree's to radians.\r\n */\r\nexport const DegreeToRadian = Math.PI / 180;\r\n\r\n/**\r\n * A constants that contains the time in milli second for a frame.\r\n */\r\nexport const GameTick = 1000 / 60;\r\n\r\n/**\r\n * Constants for the initial ball velocity.\r\n */\r\nexport const InitialBallVelocity = 10;\r\n\r\n/**\r\n * Constants used in a calculation to randomize the ball's initial angle.\r\n */\r\nexport const BallAngleStartRandomFactor = 10;\r\n\r\n/**\r\n * Constants used in calculation the width and height of the ball relative to the game field diminsions.\r\n */\r\nexport const BallResizeFactor = 0.02;\r\n\r\n/**\r\n * A Constants used ina calculation to increase or decrease the angle of the ball depending on where it hits the paddle.\r\n */\r\nexport const BounceAngleIncreaseConstant = 40;\r\n\r\n/**\r\n * Constant to used to calculate the size of the playing field.\r\n */\r\nexport const WindowResizeConstant = 0.9;\r\n\r\n/**\r\n * Used to calculate the paddle with relative to the game field width.\r\n */\r\nexport const PaddleWithFactor = 40;\r\n\r\n/**\r\n * Used to calculate the height of the paddle relative to the game field height.\r\n */\r\nexport const PaddleHeightFactor = 10;\r\n\r\n/**\r\n * Used to calculate the paddle's top coordinate relative to the game field height.\r\n */\r\nexport const PaddlePositionFactor = 0.9;\r\n\r\n/**\r\n * Speed increase factor for each hit block\r\n */\r\nexport const BallSpeedIncreasePerBlock = 1.02;\r\n\r\n/**\r\n * Speed increase factor for each level.\r\n */\r\nexport const BallSpeedIncreasePerLevel = 1.05;\r\n\r\n/**\r\n * Border color\r\n */\r\nexport const GameFieldBorderColor = \"#2c1145\";\r\n\r\n/**\r\n * The paddle color\r\n */\r\nexport const PaddleColor = \"#8b25ae\";\r\n\r\n/**\r\n * Minimal amount of red in a block\r\n */\r\nexport const MinRed = 30;\r\n\r\n/**\r\n * Maximum amount of red in a block\r\n */\r\nexport const MaxRed = 60;\r\n\r\n/**\r\n * Minimal amount of green in a blcok\r\n */\r\n\r\nexport const MinGreen = 0;\r\n\r\n/**\r\n * Maximum amount of green in a block\r\n */\r\nexport const MaxGreen = 60;\r\n\r\n/**\r\n * Minimal amount of blue in a block\r\n */\r\nexport const MinBlue = 80;\r\n\r\n/**\r\n * Maximum amount of blue in a block\r\n */\r\nexport const MaxBlue = 120;\r\n","\r\n/**\r\n * A constant object that has an object for each wall. Used to eliminate double bounces.\r\n */\r\nexport const Walls = {\r\n    /**\r\n     * Reference constant for the left wall.\r\n     */\r\n    leftWall: {},\r\n\r\n    /**\r\n     * Reference constants for the right wall\r\n     */\r\n    rightWall: {},\r\n\r\n    /**\r\n     * Reference constant for the top wall.\r\n     */\r\n    topWall: {},\r\n\r\n    /**\r\n     * Reference constant for the bottom wall.\r\n     */\r\n    bottomWall: {}\r\n};","/**\r\n * This is a library module that contains functions user throughout the entire game.\r\n */\r\n\r\nimport { BallAngleStartRandomFactor, BounceAngleIncreaseConstant, DegreeToRadian, MaxBlue, MaxRed, MinBlue, MinRed } from \"./Constants/Constants\";\r\nimport { Block } from \"./Definitions/Block\";\r\nimport { ScreenObject } from \"./Definitions/ScreenObject\";\r\nimport { Direction, hitSide as HitSide } from \"./Definitions/Types\";\r\nimport { BallState } from \"./State/Definition/BallState\";\r\nimport { GameActions } from \"./State/GameActions\";\r\n\r\n/**\r\n * Returns the initial block setup.\r\n * @param {number} numberOfBlockRows. The amount of rows to add to the block array.\r\n * @param {number} numberOfBlockColumns. The mount of columns to add to the block array.\r\n * @returns {Block[]}. A 1d array that contains block objects.\r\n */\r\nexport const getBlocks = (numberOfBlockRows: number, numberOfBlockColumns: number): Block[] => {\r\n    let red = MinRed;\r\n    let blue = MinBlue;\r\n\r\n    let redAdd =  5;\r\n    let blueAdd = 5;\r\n\r\n    const blocks: Block[] = [];\r\n    for (let r = 0; r < numberOfBlockRows; r++) {\r\n        for (let c = 0; c < numberOfBlockColumns; c++) {\r\n\r\n            const block: Block = {\r\n                color: `rgba(${red}, 0, ${blue}, 1`,\r\n                x: c,\r\n                y: r,\r\n                left: 0,\r\n                top: 0,\r\n                height: 0,\r\n                width: 0,\r\n                hit: false,\r\n                red,\r\n                blue,\r\n                green: 0,\r\n                redAdd: 1,\r\n                blueAdd: 1,\r\n                greenAdd: 1\r\n            };\r\n\r\n            red += redAdd;\r\n            blue += blueAdd;\r\n\r\n            blocks.push(block);\r\n\r\n            if (red > MaxRed || red < MinRed) {\r\n                redAdd *= -1;\r\n            }\r\n\r\n            if (blue > MaxBlue || blue < MinBlue) {\r\n                blueAdd *= -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    return blocks;\r\n};\r\n\r\n/**\r\n * Checks if two shapes overlap\r\n * @param {ScreenObject} shape1. A Shape.\r\n * @param {ScreenObject} shape2. A Shape\r\n * @returns {boolean}. True if the shapes overlap, false otherwise.\r\n */\r\nexport const overlaps = (shape1: ScreenObject, shape2: ScreenObject): boolean => {\r\n\r\n    const left1 = Math.ceil(shape1.left);\r\n    const right1 = Math.floor(shape1.left + shape1.width);\r\n    const top1 = Math.ceil(shape1.top);\r\n    const bottom1 = Math.floor(shape1.top + shape1.height);\r\n\r\n    const left2 = Math.ceil(shape2.left);\r\n    const right2 = Math.floor(shape2.left + shape2.width);\r\n    const top2 = Math.ceil(shape2.top);\r\n    const bottom2 = Math.floor(shape2.top + shape2.height);\r\n\r\n    if (bottom1 < top2 || top1 > bottom2) {\r\n        return false;\r\n    }\r\n\r\n    if (right2 < left1 || left2 > right1) {\r\n        return false;\r\n    }\r\n\r\n    // Rectangles overlap\r\n    return true;\r\n};\r\n\r\n/**\r\n * Randomizes an angle.\r\n * @returns {number}. A number that can be added to an angle to slightly change it.\r\n */\r\nexport const angleRandomizer = (): number => {\r\n    const angleManipulator = (Math.random() * BallAngleStartRandomFactor);\r\n    if (Math.random() >= 0.5) {\r\n        return angleManipulator;\r\n    } else {\r\n        return angleManipulator * -1;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the bounce action depending on the balls heading an screen object's position.\r\n * @param {BallState} ball. A ball object.\r\n * @param {Shape} shape. Any game object that derives from ScreenObject.\r\n * @returns {GameActions.ballBounceHorizantally | GameActions.ballBounceVertically }. A ball can bounce vertically or horizantally.\r\n */\r\nexport const getBounceAction = (ball: BallState, shape: ScreenObject): GameActions.ballBounceHorizantally | GameActions.ballBounceVertically => {\r\n    const hitSide = getHitSide(ball, shape);\r\n\r\n    if (hitSide === \"left\" || hitSide === \"right\") {\r\n        return GameActions.ballBounceVertically;\r\n    } else if (hitSide === \"top\" || hitSide === \"bottom\") {\r\n        return GameActions.ballBounceHorizantally;\r\n    } else {\r\n        // tslint:disable-next-line: no-console\r\n        console.log(\"Failed hit detection\");\r\n        return GameActions.ballBounceHorizantally;\r\n    }\r\n};\r\n\r\n/**\r\n * Determine the right action to dispatch when the ball bounces off an object.\r\n * @param {BallState} ball. Ball object.\r\n * @param {ScreenObject} shape. A shape object.\r\n * @returns {HitSide}. The side where the ball would bounce based on its current position and the shape's position.\r\n */\r\nexport const getHitSide = (ball: BallState, shape: ScreenObject): HitSide => {\r\n\r\n    const shapeLeft = shape.left;\r\n    const shapeRight = shape.left + shape.width;\r\n    const shapeTop = shape.top;\r\n    const shapeBottom = shape.top + shape.height;\r\n\r\n    const ballLeft = ball.left;\r\n    const ballRight = ball.left + ball.width;\r\n\r\n    const ballTop = ball.top;\r\n    const ballBottom = ball.top + ball.height;\r\n\r\n    const withinVerticalBounds = (ballBottom > shapeTop && ballTop < shapeBottom);\r\n    const withinHorizantalBounds = (ballRight > shapeLeft && ballLeft < shapeRight);\r\n\r\n    const directions = getDirectionFromAngle(ball.angle);\r\n\r\n    const goingLeft = directions.some((d) => d === \"left\");\r\n    const goingRight = directions.some((d) => d === \"right\");\r\n    const goingUp = directions.some((d) => d === \"up\");\r\n    const goingDown = directions.some((d) => d === \"down\");\r\n\r\n    // Most times the top or bottom of a ScreenObject will be hit so check those first.\r\n    if (goingUp && withinHorizantalBounds) {\r\n        return \"bottom\";\r\n        // bottom\r\n    } else if (goingDown && withinHorizantalBounds) {\r\n        // Top\r\n        return \"top\";\r\n    } else if (goingLeft && withinVerticalBounds) {\r\n        // Right\r\n        return \"right\";\r\n    } else if (goingRight && withinVerticalBounds) {\r\n        // Left\r\n        return \"left\";\r\n    } else {\r\n        return undefined;\r\n    }\r\n};\r\n\r\n/**\r\n * Changes the angle based on the position of impact.\r\n * @param {BallState} ball. A ball object\r\n * @param {Paddle} paddle. A paddle object\r\n * @returns {number}. An angle that is slightly altered.\r\n */\r\nexport const changeAngle = (ball: ScreenObject, paddle: ScreenObject): number => {\r\n    const p = Math.abs(ball.left - paddle.left);\r\n\r\n    // calculate a factor based on the shape's width. Since this is a horizantol hit, this results in a\r\n    // number between 0 and 1.\r\n    const v = p / paddle.width;\r\n    const returnValue = BounceAngleIncreaseConstant * (0.5 - v) * -1;\r\n    return returnValue;\r\n};\r\n\r\n/**\r\n * Get next Y (position)\r\n * @param {number} angle. The angle of an object.\r\n * @param {number} distance. The distance the object will travel.\r\n * @param {number} currentY. The current Y coordinate of the object.\r\n * @returns {number}. The next Y position based on the object's angle and 'speed'.\r\n */\r\nexport const getNextY = (angle: number, distance: number, currentY: number) => {\r\n    return Math.sin(angle * DegreeToRadian * -1) * distance + currentY;\r\n};\r\n\r\n/**\r\n * Get next X (position)\r\n * @param {number} angle. The angle of an object.\r\n * @param {number} distance. The distance the object will travel.\r\n * @param {number} currentY. The current X coordinate of the object.\r\n * @returns {number}. The next X position based on the object's angle and 'speed'.\r\n */\r\nexport const getNextX = (angle: number, distance: number, currentX: number) => {\r\n    return Math.cos(angle * DegreeToRadian * -1) * distance + currentX;\r\n};\r\n\r\n/**\r\n * Get the directions from an angle\r\n * @param {number} angle. The angle of an object.\r\n * @returns {Direction[]}. The directions the object is traveling in. e.g. Down-left, or Up-right.\r\n */\r\nexport const getDirectionFromAngle = (angle: number): Direction[] => {\r\n\r\n    // A ball can travel at two directions at most so the return\r\n    // Value has to be an array with a size of 1 or two.\r\n    const returnValue: Direction[] = [];\r\n\r\n    const x = getNextX(angle, 10, 0);\r\n    const y = getNextY(angle, 10, 0);\r\n\r\n    if (x > 0) {\r\n        // Ball travels to the right\r\n        returnValue.push(\"right\");\r\n    }\r\n\r\n    if (x < 0) {\r\n        // Ball travels to the left.\r\n        returnValue.push(\"left\");\r\n    }\r\n\r\n    if (y > 0) {\r\n        // Ball travels down.\r\n        returnValue.push(\"down\");\r\n    }\r\n\r\n    if (y < 0) {\r\n        returnValue.push(\"up\");\r\n    }\r\n\r\n    return returnValue;\r\n};","import { PaddleState } from \"./State/Definition/PaddleState\";\r\n\r\n/**\r\n * A constant that contains type guards.\r\n */\r\nexport const Guard = {\r\n\r\n    /**\r\n     * Typeguard for determining if a shape is actually the paddle.\r\n     * @returns {boolean}. True if the object is a paddle, false otherwise.\r\n     */\r\n    isPaddle: (value: any): value is PaddleState => {\r\n        return value && value.isPaddle;\r\n    }\r\n};","import produce from \"immer\";\r\nimport { BallResizeFactor, BallSpeedIncreasePerBlock, BallSpeedIncreasePerLevel, InitialBallVelocity } from \"../Constants/Constants\";\r\nimport { ScreenObject } from \"../Definitions/ScreenObject\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { Guard } from \"../Guard\";\r\nimport { angleRandomizer, changeAngle, getNextX, getNextY } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { BallState } from \"../State/Definition/BallState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles ball actions.\r\n * @param {ball} state. The current ball state.\r\n * @param {ActionPayLoad}. An action, payload optional.\r\n * @returns {BallState}. The ball state.\r\n */\r\nexport const ballReducer = (state: BallState = getNewState(), action: ActionPayload<ScreenObject>): BallState => {\r\n\r\n    switch (action.type) {\r\n        case GameActions.reset: {\r\n            return getNewState();\r\n        }\r\n\r\n        case GameActions.tick: {\r\n\r\n            return produce(state, (draftState) => {\r\n                const left = getNextX(state.angle, state.velocity, state.left);\r\n                const top = getNextY(state.angle, state.velocity, state.top);\r\n\r\n                draftState.top = top;\r\n                draftState.left = left;\r\n            });\r\n        }\r\n\r\n        case GameActions.ballBounceHorizantally:\r\n        case GameActions.ballBounceVertically: {\r\n            return produce(state, (draftObject) => {\r\n                if (action.payload && action.payload !== state.lastObject) {\r\n\r\n                    draftObject.lastObject = action.payload;\r\n\r\n                    if (action.type === GameActions.ballBounceHorizantally) {\r\n                        let angleChange = 1;\r\n\r\n                        // If the baddle is hit we want the ball's angle to increase if it hit\r\n                        // the edges.\r\n                        if (Guard.isPaddle(action.payload)) {\r\n                            // calculate where the ball hit relative to the shape from the left size.\r\n                            angleChange = changeAngle(state, action.payload);\r\n                        }\r\n\r\n                        // When the ball top or bottom makes contact, multiply the current angle by -1 for it to bounce.\r\n                        draftObject.angle = (draftObject.angle + angleChange) * -1;\r\n                    } else {\r\n                        if (action.payload && action.payload !== state.lastObject) {\r\n                            // If the ball hits a side, the new angle is 180 - current angle.\r\n                            draftObject.angle = 180 - draftObject.angle;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        case GameActions.hitBlock:\r\n            // Increase the ball speed for each hit block\r\n            return produce(state, (draftObject) => {\r\n                draftObject.velocity = state.velocity * BallSpeedIncreasePerBlock;\r\n            });\r\n        case GameActions.nextLevel:\r\n            // Increase ball speed for each level.\r\n            // Increase the ball speed for each hit block\r\n            return produce(state, (draftObject) => {\r\n                draftObject.velocity = state.velocity * BallSpeedIncreasePerLevel;\r\n            });\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the ball size that fits the screen size.\r\n * @returns {number}. The size of the ball.\r\n */\r\nconst getBallSize = (): number => {\r\n    return gameDimensions.size * BallResizeFactor;\r\n};\r\n\r\n/**\r\n * Calculate the ball position in the center of the game field.\r\n * @returns {number}. The ball's X or Y coordinate.\r\n */\r\nconst getBallPositionX = (): number => {\r\n    return gameDimensions.size / 2 - gameDimensions.size * BallResizeFactor / 2;\r\n};\r\n\r\n/**\r\n * Calculate the ball position in the center of the game field.\r\n * @returns {number}. The ball's X or Y coordinate.\r\n */\r\nconst getBallPositionY = (): number => {\r\n    return gameDimensions.size / 1.5 - gameDimensions.size * BallResizeFactor / 2;\r\n};\r\n\r\n/**\r\n * Used to obtain a new state for the ball.\r\n * @returns {BallState}. A new ball state.\r\n */\r\nconst getNewState = (): BallState => {\r\n    const angle = 90 + angleRandomizer();\r\n    return {\r\n        angle,\r\n        color: \"radial-gradient(yellow, orange, brown)\",\r\n        height: getBallSize(),\r\n        width: getBallSize(),\r\n        left: getBallPositionX(),\r\n        top: getBallPositionY(),\r\n        velocity: InitialBallVelocity,\r\n        lastObject: {},\r\n    };\r\n};\r\n","import produce from \"immer\";\r\nimport { MaxBlue, MaxRed, MinBlue, MinRed, MinGreen, MaxGreen } from \"../Constants/Constants\";\r\nimport { Block } from \"../Definitions/Block\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport { getBlocks } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { BlockState } from \"../State/Definition/BlockState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\n/**\r\n * The block reducer.\r\n * @param {BlockState} state. The current block state.\r\n * @param {ActionPayload} action. An action, payload optional.\r\n * @returns {BlockState}. A 'new' block state.\r\n */\r\nexport const blockReducer = (state: BlockState = getNewState(), action: ActionPayload<Block>): BlockState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n            return getNewState();\r\n        case GameActions.nextLevel:\r\n\r\n            if (state.rows <= 10) {\r\n                // Increase the number of blocks until we hit 10 rows.\r\n                const nextLevelState = getNewState(state.rows + 1, state.columns + 1);\r\n                return nextLevelState;\r\n            } else {\r\n                return getNewState(state.rows, state.columns);\r\n            }\r\n\r\n        case GameActions.hitBlock:\r\n            return produce(state, (draftObject) => {\r\n                if (action.payload) {\r\n                    const hitBlockIndex = state.blocks.indexOf(action.payload);\r\n                    draftObject.blocks[hitBlockIndex].hit = true;\r\n                }\r\n            });\r\n\r\n        case GameActions.tick:\r\n\r\n            return produce(state, (draftObject) => {\r\n                const hitBlocks = draftObject.blocks.filter((b) => b.hit === true);\r\n\r\n                if (hitBlocks.length > 0) {\r\n\r\n                    // Reduce a hit block by 10% of its original height\r\n                    const widthReductionFactor = calculateBlockWidth(draftObject.columns) * 0.1;\r\n                    const heightReductionFactor = calculateBlockHeight(draftObject.rows) * 0.1;\r\n\r\n                    // Redcue size for a hit block\r\n                    hitBlocks.forEach((block) => {\r\n                        block.width -= widthReductionFactor;\r\n                        block.height -= heightReductionFactor;\r\n\r\n                        // Add half of the mount of pixels to the top and left to make it appear as the block shrinks to its center.\r\n                        block.top += heightReductionFactor / 2;\r\n                        block.left += widthReductionFactor / 2;\r\n\r\n                        if (block.height <= 0 || block.width <= 0) {\r\n                            // Block has reached size '0', time to remove it.\r\n                            draftObject.blocks.splice(draftObject.blocks.indexOf(block), 1);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                draftObject.blocks.forEach((block) => {\r\n\r\n                    if (block.red > MaxRed || block.red < MinRed) {\r\n                        block.redAdd *= -1;\r\n                    }\r\n\r\n                    if (block.green > MaxGreen || block.green < MinGreen) {\r\n                        block.greenAdd *= -1;\r\n                    }\r\n\r\n                    if (block.blue > MaxBlue || block.blue < MinBlue) {\r\n                        block.blueAdd *= -1;\r\n                    }\r\n\r\n                    block.red += block.redAdd;\r\n                    block.green += block.greenAdd;\r\n                    block.blue += block.blueAdd;\r\n                });\r\n            });\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets a new state for the blocks.\r\n * @param {number} rows. The number of rows the new state should have.\r\n * @param {number} columns. The number of columns the new state should have. Also used to calculate the block size.\r\n * @returns {BlockState}. A new block state.\r\n */\r\nconst getNewState = (rows: number = 5, columns: number = 12): BlockState => {\r\n    const blocks = getBlocks(rows, columns);\r\n\r\n    const width = calculateBlockWidth(columns);\r\n    const height = calculateBlockHeight(columns);\r\n\r\n    blocks.forEach((b) => {\r\n        b.width = width;\r\n        b.height = height;\r\n        b.left = b.x * width;\r\n        b.top = b.y * height;\r\n    });\r\n\r\n    return {\r\n        blocks,\r\n        columns,\r\n        rows,\r\n        height,\r\n        width\r\n    };\r\n};\r\n\r\n/**\r\n * Calculates the height of a block using the screen size and the number of rows.\r\n * @param {number} rows. Amount of rows.\r\n * @returns {number}. The height of a block based on the amount of colums.\r\n */\r\nfunction calculateBlockHeight(columns: number): number {\r\n    // The simples way to draw rectangles is to half the width.\r\n    return calculateBlockWidth(columns) / 2;\r\n}\r\n\r\n/**\r\n * Calculats the width of a block using the screensize.\r\n * @param {number} columns. Amount of colums.\r\n * @returns {number}. The block width based on the amount of colums.\r\n */\r\nfunction calculateBlockWidth(columns: number): number {\r\n    const size = getGameDimensions().size;\r\n    return size / columns;\r\n}\r\n","import { Action } from \"redux\";\r\nimport { GameState } from \"../State/Definition/GameState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\nimport produce from \"immer\";\r\n\r\n/**\r\n * game state reducer. Keeps track of score, losing a game, etc.\r\n * @param {GameState} state. The current game state\r\n * @param {Action}. A reduc action. No payload.\r\n * @returns {GameState}. The next game state.\r\n */\r\nexport const gameStateReducer = (state: GameState = getNewState(), action: Action<GameActions>): GameState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n            return getNewState();\r\n        case GameActions.gameLost:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.gameMode = \"ended\";\r\n            });\r\n        case GameActions.nextLevel:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.level += 1;\r\n            });\r\n        case GameActions.hitBlock:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.score +=1;\r\n            });\r\n        case GameActions.resume:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.gameMode = \"running\";\r\n            });\r\n        case GameActions.pause:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.gameMode = \"paused\";\r\n            });\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Creates a new GameState state\r\n * @returns {GameState}. A new game state.\r\n */\r\nconst getNewState = (): GameState => {\r\n    return { gameMode: \"paused\", level: 1, score: 0 };\r\n};\r\n","\r\nimport produce from \"immer\";\r\nimport { PaddleColor, PaddleHeightFactor, PaddlePositionFactor, PaddleWithFactor } from \"../Constants/Constants\";\r\nimport { getGameDimensions } from \"../GameDimensions\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport { PaddleState } from \"../State/Definition/PaddleState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles paddle actions\r\n * @param {PaddleState} state. The paddle state.\r\n * @param {ActionPayload<number> }action. An action to be performed on the paddle. Number is the 'left' coordinate of the paddle.\r\n * @returns {PaddleState}. Paddle state.\r\n */\r\nexport const paddleReducer = (state: PaddleState = getNewState(), action: ActionPayload<number>): PaddleState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n\r\n            return getNewState();\r\n\r\n        case GameActions.paddleMove:\r\n\r\n            return produce(state, (draftObject) => {\r\n\r\n                // Prevent the paddle from being drawn outside the playfield.\r\n                if (typeof (action.payload) !== \"undefined\") {\r\n\r\n                    let x;\r\n\r\n                    if (action.payload - state.width / 2 <= 0) {\r\n                        x = 0;\r\n                    } else if (action.payload - state.width / 2 >= (gameDimensions.size - state.width)) {\r\n                        x = gameDimensions.size - state.width;\r\n                    } else {\r\n                        x = action.payload - (state.width / 2);\r\n                    }\r\n\r\n                    draftObject.left = x;\r\n                }\r\n            });\r\n\r\n        case GameActions.nextLevel:\r\n            return produce(state, (draftObject) => {\r\n\r\n                // Redude the paddle size each level by 5%\r\n                const newWidth = draftObject.width * 0.95;\r\n\r\n                if (newWidth < gameDimensions.size / PaddleHeightFactor / 2) {\r\n                    // Paddle doesn't get smaller than half its size.\r\n                    return state;\r\n                } else {\r\n                    draftObject.width = newWidth;\r\n                }\r\n            });\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Generates a new state for the paddle\r\n * @returns {PaddleState}. A new state for the paddle\r\n */\r\nconst getNewState = (): PaddleState => {\r\n    return {\r\n        color: PaddleColor,\r\n        width: gameDimensions.size / PaddleHeightFactor,\r\n        height: gameDimensions.size / PaddleWithFactor,\r\n        top: gameDimensions.size * PaddlePositionFactor,\r\n        left: (gameDimensions.size / 2) - (gameDimensions.size / PaddleHeightFactor / 2),\r\n        isPaddle: true\r\n    };\r\n};","import { Howl } from \"howler\";\r\nimport { Action } from \"redux\";\r\nimport { Bounce, HitBlock } from \"../Constants/Base64Audio\";\r\nimport { SoundState } from \"../State/Definition/SoundState\";\r\nimport { GameActions } from \"../State/GameActions\";\r\n\r\n/**\r\n * Sound reducer. Handlers playing the sounds of the game when an action requires a sound.\r\n * @param {SoundState} state. The sound state. Never changes after initialization.\r\n * @param {GameActions} action. An action that requires a sound to be played.\r\n * @returns {SoundState}. The sound state.\r\n */\r\n\r\nexport const soundReducer = (state: SoundState = getNewState(), action: Action): SoundState => {\r\n    switch (action.type) {\r\n        case GameActions.hitBlock:\r\n            state.hitBlock.play();\r\n            break;\r\n        case GameActions.ballBounceHorizantally:\r\n        case GameActions.ballBounceVertically:\r\n            state.bounce.play();\r\n            break;\r\n    }\r\n\r\n    return state;\r\n};\r\n\r\nconst getNewState = (): SoundState => {\r\n    const bounceSound = new Howl({ src: [\"data:audio/wav;base64,\" + Bounce] });\r\n    const hitBlockSound = new Howl({ src: [\"data:audio/wav;base64,\" + HitBlock] });\r\n\r\n    return {\r\n        bounce: bounceSound,\r\n        hitBlock: hitBlockSound\r\n    };\r\n};","import { combineReducers, createStore, ReducersMapObject, Store } from \"redux\";\r\nimport { ballReducer } from \"../Reducers/BallReducer\";\r\nimport { blockReducer } from \"../Reducers/BlockReducer\";\r\nimport { gameStateReducer } from \"../Reducers/GameStateReducer\";\r\nimport { paddleReducer } from \"../Reducers/PaddleReducer\";\r\nimport { soundReducer } from \"../Reducers/SoundReducer\";\r\nimport ActionPayload from \"./ActionPayLoad\";\r\nimport { AppState } from \"./Definition/AppState\";\r\n\r\n/**\r\n * All reducer that build the application state.\r\n */\r\nconst reducers: ReducersMapObject<AppState, ActionPayload<any>> = {\r\n    blockState: blockReducer,\r\n    paddle: paddleReducer,\r\n    ball: ballReducer,\r\n    gameState: gameStateReducer,\r\n    soundState: soundReducer,\r\n};\r\n\r\nconst allReducers = combineReducers(reducers);\r\n\r\nconst store = createStore<AppState, ActionPayload<any>, AppState, AppState>(allReducers);\r\n\r\n/**\r\n * Returns the store\r\n * @returns {Store}. The redux store.\r\n */\r\nexport const appStore = (): Store<AppState, ActionPayload<any>> => {\r\n    return store;\r\n};\r\n\r\n/**\r\n * Returns the State\r\n * @returns {AppState}. The application state.\r\n */\r\nexport const appState = (): AppState => {\r\n    return appStore().getState();\r\n};","import produce from \"immer\";\nimport React, { CSSProperties } from \"react\";\nimport { GameFieldBorderColor, GameTick } from \"./Constants/Constants\";\nimport { Walls } from \"./Constants/WallConstants\";\nimport { Block } from \"./Definitions/Block\";\nimport { GameObject } from \"./Definitions/GameObject\";\nimport { getGameDimensions } from \"./GameDimensions\";\nimport { getBounceAction, overlaps } from \"./Lib\";\nimport { AppState } from \"./State/Definition/AppState\";\nimport { BallState } from \"./State/Definition/BallState\";\nimport { GameActions } from \"./State/GameActions\";\nimport { appState, appStore } from \"./State/Store\";\n\nconst gameDimensions = getGameDimensions();\n\n/**\n * Main game component.\n */\nexport class Main extends React.Component<{}, AppState> {\n\n    /**\n     * Stores a reference to the animation that draws the game.\n     */\n    private tickHandler?: number;\n\n    /**\n     * Used to store the beginning of a game tick.\n     */\n    private tickStart?: number;\n\n    /**\n     * Refux subscription\n     */\n    private subscription?: () => void;\n\n    /**\n     * Initializes the Main component.\n     */\n    constructor(props: object) {\n        super(props);\n\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.onMouseClick = this.onMouseClick.bind(this);\n        this.tick = this.tick.bind(this);\n        this.onPlayAgain = this.onPlayAgain.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n\n        // Sync the redux state with the component state.\n        this.state = appState();\n    }\n\n    /**\n     * Called when the component mounted.\n     */\n    public componentDidMount(): void {\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n\n        window.addEventListener(\"mousemove\", this.onMouseMove);\n        window.addEventListener(\"click\", this.onMouseClick);\n        window.addEventListener(\"keyup\", this.onKeyUp);\n\n        this.subscription = appStore().subscribe(() => {\n            const applicationState = appState();\n\n            if (applicationState.gameState !== this.state.gameState) {\n                this.setState({ gameState: applicationState.gameState });\n\n                if (applicationState.gameState.gameMode === \"ended\") {\n                    if (this.tickHandler) {\n                        window.cancelAnimationFrame(this.tickHandler);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Called before the component unmounts.\n     */\n    public componentWillUnmount(): void {\n        if (this.tickHandler) {\n            window.cancelAnimationFrame(this.tickHandler);\n        }\n\n        window.removeEventListener(\"mousemove\", this.onMouseMove);\n        window.removeEventListener(\"click\", this.onMouseClick);\n\n        if (this.subscription) {\n            this.subscription();\n            delete this.subscription;\n        }\n    }\n\n    private onKeyUp(e: KeyboardEvent): void {\n        switch (e.code) {\n            case \"KeyW\":\n                appStore().dispatch({ type: GameActions.nextLevel });\n                break;\n            case \"Space\":\n                appStore().dispatch({ type: GameActions.pause });\n                break;\n\n        }\n    }\n\n    /**\n     * Handles mouse movement. Used to move the paddle.\n     * @param {MouseEvent} e. MouseEvent.\n     */\n    private onMouseMove(e: MouseEvent): void {\n        if (e) {\n            const x = e.clientX - gameDimensions.left;\n            appStore().dispatch({ type: GameActions.paddleMove, payload: x });\n        }\n    }\n\n    /**\n     * Event fires when the user clicks the mouse.\n     */\n    private onMouseClick(): void {\n        if (this.state.gameState.gameMode === \"paused\") {\n            appStore().dispatch({ type: GameActions.resume });\n            this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n        }\n    }\n\n    /**\n     * Handles a play again click.\n     */\n    private onPlayAgain(): void {\n        // Reset game state.\n        appStore().dispatch({ type: GameActions.reset });\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Handles a game tick.\n     * @param {number} tick. Current tick count.\n     */\n    public tick(tick: number): void {\n\n        if (!this.tickStart) {\n            this.tickStart = tick;\n        }\n\n        if (this.state.gameState.gameMode !== \"running\") {\n            return;\n        }\n\n        const diff = tick - this.tickStart;\n\n        // Redraw at 60 fps.\n        if (diff > GameTick) {\n            const ball = appState().ball;\n            const blocks = appState().blockState.blocks;\n            const paddle = appState().paddle;\n\n            if (blocks.length === 0) {\n                appStore().dispatch({ type: GameActions.nextLevel });\n            }\n\n            const paddleHit = overlaps(ball, paddle);\n\n            if (paddleHit) {\n                const paddleBounceAction = getBounceAction(ball, paddle);\n                appStore().dispatch({ type: paddleBounceAction, payload: paddle });\n\n            } else if (blocks) {\n\n                const hitBlock = blocks.find((b) => overlaps(ball, b) && b.hit === false);\n                if (hitBlock) {\n                    appStore().dispatch({ type: GameActions.hitBlock, payload: hitBlock });\n\n                    const action = getBounceAction(ball, hitBlock);\n\n                    if (typeof (action) !== \"undefined\") {\n                        appStore().dispatch({ type: action, payload: hitBlock });\n                    }\n\n                } else if (ball.top <= 0) {\n                    // The ball's top and left are inside the game field.\n                    // Use the game dimension object to store a wall hit.\n                    // Hit the top  wall\n                    appStore().dispatch({ type: GameActions.ballBounceHorizantally, payload: Walls.topWall });\n\n                } else if (ball.left <= 0) {\n                    // Hit the left wall\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.leftWall });\n                } else if (ball.left + ball.width >= gameDimensions.size) {\n                    // Hit the right wall\n\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload: Walls.rightWall });\n                } else if (ball.top + ball.width >= gameDimensions.size) {\n                    // Hit bottom wall.\n                    appStore().dispatch({ type: GameActions.gameLost });\n                }\n            }\n\n            appStore().dispatch({ type: GameActions.tick });\n\n            const newComponentState = produce(this.state, (draftObject) => {\n                draftObject.ball = appState().ball;\n                draftObject.blockState = appState().blockState;\n                draftObject.gameState = appState().gameState;\n                draftObject.paddle = appState().paddle;\n            });\n\n            this.setState(newComponentState);\n\n            this.tickStart = tick;\n        }\n\n        this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Returns the styling for the game field.\n     * @returns {CSSProperties}. CSSProperties for the gamefield.\n     */\n    private gameFieldStyle(): CSSProperties | undefined {\n\n        return {\n            position: \"absolute\",\n            left: getGameDimensions().left,\n            top: getGameDimensions().top,\n            width: getGameDimensions().size,\n            height: getGameDimensions().size,\n            borderColor: GameFieldBorderColor,\n            borderStyle: \"solid\",\n            display: \"flex\",\n            justifyContent: \"center\"\n        };\n    }\n\n    /**\n     * Game score style\n     * @returns {CSSProperties}. A style that will draw a rectangle above the game field.\n     */\n    private gameScorebarStyle(): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: getGameDimensions().left,\n            width: getGameDimensions().size,\n            top: getGameDimensions().top - 25,\n            height: 22,\n            borderColor: GameFieldBorderColor,\n            borderStyle: \"solid\",\n            display: \"flex\",\n            flexDirection: \"row\",\n        };\n    }\n\n    /**\n     * Returns css properties for positioning a shape.\n     * @param {ScreenObject} shape. A shape object.\n     * @returns {CSSProperties}. CSS properties for a shape.\n     */\n    private positionStyle(shape: GameObject): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: shape.left,\n            top: shape.top,\n            height: shape.height,\n            width: shape.width,\n            backgroundColor: shape.color,\n        };\n    }\n\n    private blockStyle(block: Block): CSSProperties {\n        const css = this.positionStyle(block);\n        css.backgroundColor = `rgba(${block.red}, ${block.green}, ${block.blue}, 1`;\n        return css;\n    }\n\n    /**\n     * Returns css properties for positioning and drawing the ball.\n     * @param {BallState} ball.\n     * @returns {CSSProperties}.\n     */\n    private ballStyle(ball: BallState): CSSProperties {\n        const newPosition = this.positionStyle(ball);\n        newPosition.borderRadius = \"50%\";\n        newPosition.backgroundImage = ball.color;\n        return newPosition;\n    }\n\n    /**\n     * Renders the component.\n     */\n    public render(): React.ReactNode {\n        return (\n            <div>\n                <div style={this.gameScorebarStyle()} >\n                    <div key={1} style={{ color: \"white\", justifyContent: \"center\", marginLeft: \"10px\" }}>Level: {this.state.gameState.level}</div>>\n                    <div key={2} style={{ color: \"white\", justifyContent: \"center\" }}>Score: {this.state.gameState.score}</div>>\n                </div>\n                <>\n                    {\n                        this.state.blockState && this.state.paddle && this.state.ball ?\n                            <div style={this.gameFieldStyle()}>\n                                {\n                                    this.state.blockState.blocks.map((b, index) => <div key={index} style={this.blockStyle(b)} />)\n                                }\n                                <div style={this.positionStyle(this.state.paddle)} />\n                                <div style={this.ballStyle(this.state.ball)} />\n                                {\n                                    this.state.gameState.gameMode === \"ended\" ?\n                                        <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"center\" }}>\n                                            <p style={{ alignSelf: \"center\", color: \"white\" }}>Game over</p>\n                                            <button onClick={this.onPlayAgain} style={{ alignSelf: \"center\" }}>Play again</button>\n                                        </div> :\n                                        this.state.gameState.gameMode === \"paused\" ?\n                                            <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"center\" }}>\n                                                <p style={{ alignSelf: \"center\", color: \"white\" }}>Click the left mouse button to resume.</p>\n                                            </div> : null\n                                }\n\n                            </div> : null\n                    }\n                </>\n            </div>\n        );\n    }\n}\n\nexport default Main;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Main from \"./Main\";\n\nReactDOM.render(<Main />, document.getElementById(\"root\"));\n"],"sourceRoot":""}