{"version":3,"sources":["GameDimensions.ts","State/GameActions.ts","Constants/Constants.ts","Constants/WallConstants.ts","Lib.ts","Guard.ts","Reducers/BallReducer.ts","Reducers/BlockReducer.ts","Reducers/GameStateReducer.ts","Reducers/PaddleReducer.ts","Reducers/SoundReducer.ts","State/Store.ts","Main.tsx","index.tsx"],"names":["gameDimensions","GameActions","DegreeToRadian","Math","PI","Walls","leftWall","rightWall","topWall","bottomWall","getGameDimensions","size","window","innerHeight","innerWidth","left","top","getBlocks","numberOfBlockRows","numberOfBlockColumns","red","blue","redAdd","blueAdd","blocks","r","c","block","color","x","y","height","width","hit","green","greenAdd","push","overlaps","shape1","shape2","left1","right1","top1","bottom1","left2","right2","top2","bottom2","getBounceAction","ball","shape","directions","getDirectionFromAngle","angle","horizantalLine","verticalLine","shapeBottom","shapeRight","up","a","b","right","down","hitLine","getHitLine","ballBounceHorizantally","ballBounceVertically","changeAngle","paddle","abs","getNextY","distance","currentY","sin","getNextX","currentX","cos","returnValue","forward","velocity","backward","topLeftLine","topRightLine","bottomRightLine","bottomLeftLine","horizantolIntersects","verticalIntersects","intersects","console","log","line1","line2","x1","floor","y1","x2","y2","x3","y3","x4","y4","isNaN","Guard","value","isPaddle","getBallSize","getNewState","angleManipulator","random","angleRandomizer","lastObject","ballReducer","state","action","type","reset","tick","produce","draftState","draftObject","payload","angleChange","hitBlock","nextLevel","newState","rows","columns","calculateBlockWidth","calculateBlockHeight","forEach","blockReducer","nextLevelState","hitBlockIndex","indexOf","hitBlocks","filter","length","widthReductionFactor","heightReductionFactor","splice","gameMode","level","score","gameStateReducer","gameLost","resume","pause","paddleReducer","paddleMove","newWidth","bounce","Howl","src","sounds","reducers","blockState","gameState","soundState","play","toggleSound","allReducers","combineReducers","store","createStore","appStore","appState","getState","Main","props","tickHandler","tickStart","subscription","onMouseMove","bind","onMouseClick","onPlayAgain","onKeyUp","this","requestAnimationFrame","addEventListener","subscribe","applicationState","setState","cancelAnimationFrame","removeEventListener","e","code","dispatch","clientX","diff","paddleBounceAction","find","ticks","newComponentState","position","borderColor","borderStyle","display","justifyContent","flexDirection","backgroundColor","css","positionStyle","newPosition","borderRadius","backgroundImage","style","gameScorebarStyle","marginTop","marginLeft","marginRight","textAlign","gameFieldStyle","map","index","key","blockStyle","ballStyle","alignSelf","onClick","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.0ce64a48.chunk.js","sourcesContent":["/**\r\n * Provides game dimensions.\r\n */\r\n\r\nimport { WindowResizeConstant } from \"./Constants/Constants\";\r\nimport { GameDimensions } from \"./Definitions/GameDimensions\";\r\n\r\nlet gameDimensions: GameDimensions;\r\n\r\nconst getGameDimensions = (): GameDimensions => {\r\n    if (!gameDimensions) {\r\n        let size = 0;\r\n\r\n        if (window.innerHeight > window.innerWidth) {\r\n            size = window.innerWidth * WindowResizeConstant;\r\n        } else {\r\n            size = window.innerHeight * WindowResizeConstant;\r\n        }\r\n\r\n        const left = (window.innerWidth / 2) - (size / 2);\r\n        const top = (window.innerHeight / 2) - (size / 2);\r\n\r\n        gameDimensions = { left, top, size };\r\n    }\r\n\r\n    return gameDimensions;\r\n};\r\n\r\nexport default getGameDimensions;","enum  GameActions {\r\n    /**\r\n     * An action that instructs the reducers to return an initial objects to play the game.\r\n     */\r\n    reset,\r\n\r\n    /**\r\n     * Dispatched when a block is hit.\r\n     */\r\n    hitBlock,\r\n\r\n    /**\r\n     * Dispatched when the user moves the mouse causing th paddle to move.\r\n     */\r\n    paddleMove,\r\n\r\n    /**\r\n     * Dispatch for a game tick.\r\n     */\r\n    tick,\r\n\r\n    /**\r\n     * Dispatchen when the ball bounces of top or bottom of an object.\r\n     */\r\n    ballBounceHorizantally,\r\n\r\n    /**\r\n     * Dispatched when the ball bounces of the side of an object.\r\n     */\r\n    ballBounceVertically,\r\n\r\n    /**\r\n     * Dispatched when the ball hits the bottom of the play field.\r\n     */\r\n    gameLost,\r\n\r\n    /**\r\n     * Dispatched when all the blocks are cleared.\r\n     */\r\n    nextLevel,\r\n\r\n    /**\r\n     * Resume the game.\r\n     */\r\n    resume,\r\n\r\n    /**\r\n     * An action that pauses the game\r\n     */\r\n    pause,\r\n\r\n    /**\r\n     * An action that toggles the sound on and off.\r\n     */\r\n    toggleSound\r\n}\r\n\r\nexport default GameActions;","\r\n/**\r\n * A constants used to convert the angle from degree's to radians.\r\n */\r\nexport const DegreeToRadian = Math.PI / 180;\r\n\r\n/**\r\n * A constants that contains the time in milli second for a frame.\r\n */\r\nexport const GameTick = 1000 / 60;\r\n\r\n/**\r\n * Constants for the initial ball velocity.\r\n */\r\nexport const InitialBallVelocity = 10;\r\n\r\n/**\r\n * Constants used in a calculation to randomize the ball's initial angle.\r\n */\r\nexport const BallAngleStartRandomFactor = 10;\r\n\r\n/**\r\n * Constants used in calculation the width and height of the ball relative to the game field diminsions.\r\n */\r\nexport const BallResizeFactor = 0.02;\r\n\r\n/**\r\n * A Constants used ina calculation to increase or decrease the angle of the ball depending on where it hits the paddle.\r\n */\r\nexport const BounceAngleIncreaseConstant = 40;\r\n\r\n/**\r\n * Constant to used to calculate the size of the playing field.\r\n */\r\nexport const WindowResizeConstant = 0.9;\r\n\r\n/**\r\n * Used to calculate the paddle with relative to the game field width.\r\n */\r\nexport const PaddleWithFactor = 40;\r\n\r\n/**\r\n * Used to calculate the height of the paddle relative to the game field height.\r\n */\r\nexport const PaddleHeightFactor = 10;\r\n\r\n/**\r\n * Used to calculate the paddle's top coordinate relative to the game field height.\r\n */\r\nexport const PaddlePositionFactor = 0.9;\r\n\r\n/**\r\n * Speed increase factor for each hit block\r\n */\r\nexport const BallSpeedIncreasePerBlock = 1.02;\r\n\r\n/**\r\n * Speed increase factor for each level.\r\n */\r\nexport const BallSpeedIncreasePerLevel = 1.05;\r\n\r\n/**\r\n * Border color\r\n */\r\nexport const GameFieldBorderColor = \"#2c1145\";\r\n\r\n/**\r\n * The paddle color\r\n */\r\nexport const PaddleColor = \"#8b25ae\";\r\n\r\n/**\r\n * Minimal amount of red in a block\r\n */\r\nexport const MinRed = 30;\r\n\r\n/**\r\n * Maximum amount of red in a block\r\n */\r\nexport const MaxRed = 60;\r\n\r\n/**\r\n * Minimal amount of green in a blcok\r\n */\r\n\r\nexport const MinGreen = 0;\r\n\r\n/**\r\n * Maximum amount of green in a block\r\n */\r\nexport const MaxGreen = 60;\r\n\r\n/**\r\n * Minimal amount of blue in a block\r\n */\r\nexport const MinBlue = 80;\r\n\r\n/**\r\n * Maximum amount of blue in a block\r\n */\r\nexport const MaxBlue = 120;\r\n","\r\n/**\r\n * A constant object that has an object for each wall. Used to eliminate double bounces.\r\n */\r\nconst Walls = {\r\n    /**\r\n     * Reference constant for the left wall.\r\n     */\r\n    leftWall: {},\r\n\r\n    /**\r\n     * Reference constants for the right wall\r\n     */\r\n    rightWall: {},\r\n\r\n    /**\r\n     * Reference constant for the top wall.\r\n     */\r\n    topWall: {},\r\n\r\n    /**\r\n     * Reference constant for the bottom wall.\r\n     */\r\n    bottomWall: {}\r\n};\r\n\r\nexport default Walls;","/**\r\n * This is a library module that contains functions user throughout the entire game.\r\n */\r\n\r\nimport { BallAngleStartRandomFactor, BounceAngleIncreaseConstant, DegreeToRadian, MaxBlue, MaxRed, MinBlue, MinRed } from \"./Constants/Constants\";\r\nimport Block from \"./Definitions/Block\";\r\nimport Direction from \"./Definitions/Direction\";\r\nimport Line from \"./Definitions/Line\";\r\nimport ScreenObject from \"./Definitions/ScreenObject\";\r\nimport BallState from \"./State/Definition/BallState\";\r\nimport GameActions from \"./State/GameActions\";\r\n\r\n/**\r\n * Returns the initial block setup.\r\n * @param {number} numberOfBlockRows. The amount of rows to add to the block array.\r\n * @param {number} numberOfBlockColumns. The mount of columns to add to the block array.\r\n * @returns {Block[]}. A 1d array that contains block objects.\r\n */\r\nexport const getBlocks = (numberOfBlockRows: number, numberOfBlockColumns: number): Block[] => {\r\n    let red = MinRed;\r\n    let blue = MinBlue;\r\n\r\n    let redAdd = 5;\r\n    let blueAdd = 5;\r\n\r\n    const blocks: Block[] = [];\r\n    for (let r = 0; r < numberOfBlockRows; r++) {\r\n        for (let c = 0; c < numberOfBlockColumns; c++) {\r\n\r\n            const block: Block = {\r\n                color: `rgba(${red}, 0, ${blue}, 1`,\r\n                x: c,\r\n                y: r,\r\n                left: 0,\r\n                top: 0,\r\n                height: 0,\r\n                width: 0,\r\n                hit: false,\r\n                red,\r\n                blue,\r\n                green: 0,\r\n                redAdd: 1,\r\n                blueAdd: 1,\r\n                greenAdd: 1\r\n            };\r\n\r\n            red += redAdd;\r\n            blue += blueAdd;\r\n\r\n            blocks.push(block);\r\n\r\n            if (red > MaxRed || red < MinRed) {\r\n                redAdd *= -1;\r\n            }\r\n\r\n            if (blue > MaxBlue || blue < MinBlue) {\r\n                blueAdd *= -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    return blocks;\r\n};\r\n\r\n/**\r\n * Checks if two shapes overlap\r\n * @param {ScreenObject} shape1. A Shape.\r\n * @param {ScreenObject} shape2. A Shape\r\n * @returns {boolean}. True if the shapes overlap, false otherwise.\r\n */\r\nexport const overlaps = (shape1: ScreenObject, shape2: ScreenObject): boolean => {\r\n\r\n    const left1 = shape1.left;\r\n    const right1 = shape1.left + shape1.width;\r\n    const top1 = shape1.top;\r\n    const bottom1 = shape1.top + shape1.height;\r\n\r\n    const left2 = shape2.left;\r\n    const right2 = shape2.left + shape2.width;\r\n    const top2 = shape2.top;\r\n    const bottom2 = shape2.top + shape2.height;\r\n\r\n    if (bottom1 < top2 || top1 > bottom2) {\r\n        return false;\r\n    }\r\n\r\n    if (right2 < left1 || left2 > right1) {\r\n        return false;\r\n    }\r\n\r\n    // Rectangles overlap\r\n    return true;\r\n};\r\n\r\n/**\r\n * Randomizes an angle.\r\n * @returns {number}. A number that can be added to an angle to slightly change it.\r\n */\r\nexport const angleRandomizer = (): number => {\r\n    const angleManipulator = (Math.random() * BallAngleStartRandomFactor);\r\n    if (Math.random() >= 0.5) {\r\n        return angleManipulator;\r\n    } else {\r\n        return angleManipulator * -1;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the bounce action depending on the balls heading an screen object's position.\r\n * @param {BallState} ball. A ball object.\r\n * @param {Shape} shape. Any game object that derives from ScreenObject.\r\n * @returns {GameActions.ballBounceHorizantally | GameActions.ballBounceVertically }. A ball can bounce vertically or horizantally.\r\n */\r\nexport const getBounceAction = (ball: BallState, shape: ScreenObject): GameActions.ballBounceHorizantally | GameActions.ballBounceVertically => {\r\n\r\n    const directions = getDirectionFromAngle(ball.angle);\r\n\r\n    let horizantalLine: Line = {} as Line;\r\n    let verticalLine: Line = {} as Line;\r\n\r\n    const shapeBottom = shape.top + shape.height;\r\n    const shapeRight = shape.left + shape.width;\r\n\r\n    if (directions.up) {\r\n        horizantalLine = {\r\n            a: {\r\n                x: shape.left,\r\n                y: shapeBottom,\r\n            },\r\n            b: {\r\n                x: shapeRight,\r\n                y: shapeBottom\r\n            }\r\n        };\r\n    }\r\n\r\n    if (directions.right) {\r\n        verticalLine = {\r\n            a: {\r\n                x: shape.left,\r\n                y: shape.top,\r\n            },\r\n            b: {\r\n                x: shape.left,\r\n                y: shapeBottom,\r\n            }\r\n        };\r\n    }\r\n\r\n    if (directions.down) {\r\n        horizantalLine = {\r\n            a: {\r\n                x: shape.left,\r\n                y: shape.top,\r\n            },\r\n            b: {\r\n                x: shapeRight,\r\n                y: shape.top,\r\n            }\r\n        };\r\n    }\r\n\r\n    if (directions.left) {\r\n        verticalLine = {\r\n            a: {\r\n                x: shapeRight,\r\n                y: shape.top,\r\n            },\r\n            b: {\r\n                x: shapeRight,\r\n                y: shapeBottom\r\n            }\r\n        };\r\n    }\r\n\r\n    const hitLine = getHitLine(ball, horizantalLine, verticalLine);\r\n\r\n    if (hitLine === horizantalLine) {\r\n        return GameActions.ballBounceHorizantally;\r\n    } else if (hitLine === verticalLine) {\r\n        return GameActions.ballBounceVertically;\r\n    } else {\r\n        // Default to a horizantal bounce because it is the most likely to occur.\r\n        return GameActions.ballBounceHorizantally;\r\n    }\r\n};\r\n\r\n/**\r\n * Changes the angle based on the position of impact.\r\n * @param {BallState} ball. A ball object\r\n * @param {Paddle} paddle. A paddle object\r\n * @returns {number}. An angle that is slightly altered.\r\n */\r\nexport const changeAngle = (ball: ScreenObject, paddle: ScreenObject): number => {\r\n    const p = Math.abs(ball.left - paddle.left);\r\n\r\n    // calculate a factor based on the shape's width. Since this is a horizantol hit, this results in a\r\n    // number between 0 and 1.\r\n    const v = p / paddle.width;\r\n    const returnValue = BounceAngleIncreaseConstant * (0.5 - v) * -1;\r\n    return returnValue;\r\n};\r\n\r\n/**\r\n * Get next Y (position)\r\n * @param {number} angle. The angle of an object.\r\n * @param {number} distance. The distance the object will travel.\r\n * @param {number} currentY. The current Y coordinate of the object.\r\n * @returns {number}. The next Y position based on the object's angle and 'speed'.\r\n */\r\nexport const getNextY = (angle: number, distance: number, currentY: number) => {\r\n    return Math.sin(angle * DegreeToRadian * -1) * distance + currentY;\r\n};\r\n\r\n/**\r\n * Get next X (position)\r\n * @param {number} angle. The angle of an object.\r\n * @param {number} distance. The distance the object will travel.\r\n * @param {number} currentY. The current X coordinate of the object.\r\n * @returns {number}. The next X position based on the object's angle and 'speed'.\r\n */\r\nexport const getNextX = (angle: number, distance: number, currentX: number) => {\r\n    return Math.cos(angle * DegreeToRadian * -1) * distance + currentX;\r\n};\r\n\r\n/**\r\n * Get the directions from an angle\r\n * @param {number} angle. The angle of an object.\r\n * @returns {Direction[]}. The directions the object is traveling in. e.g. Down-left, or Up-right.\r\n */\r\nexport const getDirectionFromAngle = (angle: number): Direction => {\r\n\r\n    // A ball can travel at two directions at most so the return\r\n    // Value has to be an array with a size of 1 or two.\r\n    const returnValue: Direction = { up: false, down: false, left: false, right: false };\r\n\r\n    const x = getNextX(angle, 10, 0);\r\n    const y = getNextY(angle, 10, 0);\r\n\r\n    if (x > 0) {\r\n        // Ball travels to the right\r\n        returnValue.right = true;\r\n    }\r\n\r\n    if (x < 0) {\r\n        // Ball travels to the left.\r\n        returnValue.left = true;\r\n    }\r\n\r\n    if (y > 0) {\r\n        // Ball travels down.\r\n        returnValue.down = true;\r\n    }\r\n\r\n    if (y < 0) {\r\n        // Ball travels up\r\n        returnValue.up = true;\r\n    }\r\n\r\n    return returnValue;\r\n};\r\n\r\n/**\r\n * Determines which line was hit.\r\n * @param {BallState} ball. The ball.\r\n * @param {Line} horizantalLine. The horizantal line of a shape. Can be the top or bottom.\r\n * @param {Line} verticalLine. The vertical line of a shape. Can be left or right.\r\n * @returns {Line}. The hit line. Returns undefined when the hit line could not be found.\r\n */\r\nexport const getHitLine = (ball: BallState, horizantalLine: Line, verticalLine: Line): Line | undefined => {\r\n\r\n    const forward = ball.velocity;\r\n    const backward = ball.velocity * -1;\r\n\r\n    const topLeftLine: Line = {\r\n        a: {\r\n            x: getNextX(ball.angle, forward, ball.left),\r\n            y: getNextY(ball.angle, forward, ball.top),\r\n        },\r\n        b: {\r\n            x: getNextX(ball.angle, backward, ball.left),\r\n            y: getNextY(ball.angle, backward, ball.top),\r\n        }\r\n    };\r\n\r\n    const topRightLine: Line = {\r\n        a: {\r\n            x: getNextX(ball.angle, forward, ball.left + ball.width),\r\n            y: getNextY(ball.angle, forward, ball.top),\r\n        },\r\n        b: {\r\n            x: getNextX(ball.angle, backward, ball.left + ball.width),\r\n            y: getNextY(ball.angle, backward, ball.top),\r\n        }\r\n    };\r\n\r\n    const bottomRightLine: Line = {\r\n        a: {\r\n            x: getNextX(ball.angle, forward, ball.left + ball.width),\r\n            y: getNextY(ball.angle, forward, ball.top + ball.height),\r\n        },\r\n        b: {\r\n            x: getNextX(ball.angle, backward, ball.left + ball.width),\r\n            y: getNextY(ball.angle, backward, ball.top + ball.height),\r\n        }\r\n    };\r\n\r\n    const bottomLeftLine: Line = {\r\n        a: {\r\n            x: getNextX(ball.angle, forward, ball.left ),\r\n            y: getNextY(ball.angle, forward, ball.top + ball.height),\r\n        },\r\n        b: {\r\n            x: getNextX(ball.angle, backward, ball.left),\r\n            y: getNextY(ball.angle, backward, ball.top + ball.height),\r\n        }\r\n    };\r\n\r\n    let horizantolIntersects = 0;\r\n    let verticalIntersects = 0;\r\n\r\n    horizantolIntersects += intersects(\r\n        topLeftLine,\r\n        horizantalLine) ? 1 : 0;\r\n\r\n    verticalIntersects += intersects(\r\n        topLeftLine,\r\n        verticalLine) ? 1 : 0;\r\n\r\n    horizantolIntersects += intersects(\r\n        topRightLine,\r\n        horizantalLine) ? 1 : 0;\r\n\r\n    verticalIntersects += intersects(\r\n        topRightLine,\r\n        verticalLine) ? 1 : 0;\r\n\r\n    horizantolIntersects += intersects(\r\n        bottomRightLine,\r\n        horizantalLine) ? 1 : 0;\r\n\r\n    verticalIntersects += intersects(\r\n        bottomRightLine,\r\n        verticalLine) ? 1 : 0;\r\n\r\n    horizantolIntersects += intersects(\r\n        bottomLeftLine,\r\n        horizantalLine) ? 1 : 0;\r\n\r\n    verticalIntersects += intersects(\r\n        bottomLeftLine,\r\n        verticalLine) ? 1 : 0;\r\n\r\n    if (horizantolIntersects > verticalIntersects) {\r\n        return horizantalLine;\r\n    } else if (verticalIntersects > horizantolIntersects) {\r\n        return verticalLine;\r\n    } else {\r\n        // tslint:disable-next-line: no-console\r\n        console.log(\"Could not determine the hit\");\r\n        return undefined;\r\n    }\r\n};\r\n\r\n/**\r\n * Returns true if the intercet.\r\n * Source: https://stackoverflow.com/questions/9043805/test-if-two-lines-intersect-javascript-function\r\n */\r\nexport function intersects(line1: Line, line2: Line) {\r\n\r\n    const x1 = Math.floor(line1.a.x);\r\n    const y1 = Math.floor(line1.a.y);\r\n    const x2 = Math.floor(line1.b.x);\r\n    const y2 = Math.floor(line1.b.y);\r\n\r\n    const x3 = Math.floor(line2.a.x);\r\n    const y3 = Math.floor(line2.a.y);\r\n    const x4 = Math.floor(line2.b.x);\r\n    const y4 = Math.floor(line2.b.y);\r\n\r\n    const x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));\r\n    const y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));\r\n    if (isNaN(x) || isNaN(y)) {\r\n        return false;\r\n    } else {\r\n        if (x1 >= x2) {\r\n            if (!(x2 <= x && x <= x1)) { return false; }\r\n        } else {\r\n            if (!(x1 <= x && x <= x2)) { return false; }\r\n        }\r\n        if (y1 >= y2) {\r\n            if (!(y2 <= y && y <= y1)) { return false; }\r\n        } else {\r\n            if (!(y1 <= y && y <= y2)) { return false; }\r\n        }\r\n        if (x3 >= x4) {\r\n            if (!(x4 <= x && x <= x3)) { return false; }\r\n        } else {\r\n            if (!(x3 <= x && x <= x4)) { return false; }\r\n        }\r\n        if (y3 >= y4) {\r\n            if (!(y4 <= y && y <= y3)) { return false; }\r\n        } else {\r\n            if (!(y3 <= y && y <= y4)) { return false; }\r\n        }\r\n    }\r\n    return true;\r\n}","import PaddleState from \"./State/Definition/PaddleState\";\r\n\r\n/**\r\n * A constant that contains type guards.\r\n */\r\nexport const Guard = {\r\n\r\n    /**\r\n     * Typeguard for determining if a shape is actually the paddle.\r\n     * @returns {boolean}. True if the object is a paddle, false otherwise.\r\n     */\r\n    isPaddle: (value: any): value is PaddleState => {\r\n        return value && value.isPaddle;\r\n    }\r\n};","import produce from \"immer\";\r\nimport { BallResizeFactor, BallSpeedIncreasePerBlock, BallSpeedIncreasePerLevel, InitialBallVelocity } from \"../Constants/Constants\";\r\nimport ScreenObject from \"../Definitions/ScreenObject\";\r\nimport getGameDimensions from \"../GameDimensions\";\r\nimport { Guard } from \"../Guard\";\r\nimport { angleRandomizer, changeAngle, getNextX, getNextY } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport BallState from \"../State/Definition/BallState\";\r\nimport GameActions from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles ball actions.\r\n * @param {ball} state. The current ball state.\r\n * @param {ActionPayLoad}. An action, payload optional.\r\n * @returns {BallState}. The ball state.\r\n */\r\nconst ballReducer = (state: BallState = getNewState(), action: ActionPayload<ScreenObject>): BallState => {\r\n\r\n    switch (action.type) {\r\n        case GameActions.reset: {\r\n            return getNewState();\r\n        }\r\n\r\n        case GameActions.tick: {\r\n\r\n            return produce(state, (draftState) => {\r\n\r\n                const left = getNextX(state.angle, state.velocity, state.left);\r\n                const top = getNextY(state.angle, state.velocity, state.top);\r\n\r\n                draftState.top = top;\r\n                draftState.left = left;\r\n            });\r\n        }\r\n\r\n        case GameActions.ballBounceHorizantally:\r\n        case GameActions.ballBounceVertically: {\r\n            return produce(state, (draftObject) => {\r\n                if (action.payload && action.payload !== state.lastObject) {\r\n\r\n                    draftObject.lastObject = action.payload;\r\n\r\n                    if (action.type === GameActions.ballBounceHorizantally) {\r\n                        let angleChange = 0;\r\n\r\n                        // If the baddle is hit we want the ball's angle to increase if it hit\r\n                        // the edges.\r\n                        if (Guard.isPaddle(action.payload)) {\r\n                            // calculate where the ball hit relative to the shape from the left size.\r\n                            angleChange = changeAngle(state, action.payload);\r\n                        }\r\n\r\n                        // When the ball top or bottom makes contact, multiply the current angle by -1 for it to bounce.\r\n                        draftObject.angle = (draftObject.angle + angleChange) * -1;\r\n                    } else {\r\n                        if (action.payload && action.payload !== state.lastObject) {\r\n                            // If the ball hits a side, the new angle is 180 - current angle.\r\n                            draftObject.angle = 180 - draftObject.angle;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        case GameActions.hitBlock:\r\n            // Increase the ball speed for each hit block\r\n            return produce(state, (draftObject) => {\r\n                draftObject.velocity = state.velocity * BallSpeedIncreasePerBlock;\r\n            });\r\n        case GameActions.nextLevel:\r\n            const newState = getNewState();\r\n            newState.velocity = state.velocity * BallSpeedIncreasePerLevel;\r\n\r\n            return newState;\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the ball size that fits the screen size.\r\n * @returns {number}. The size of the ball.\r\n */\r\nconst getBallSize = (): number => {\r\n    return gameDimensions.size * BallResizeFactor;\r\n};\r\n\r\n/**\r\n * Calculate the ball position in the center of the game field.\r\n * @returns {number}. The ball's X or Y coordinate.\r\n */\r\nconst getBallPositionX = (): number => {\r\n    return gameDimensions.size / 2 - gameDimensions.size * BallResizeFactor / 2;\r\n};\r\n\r\n/**\r\n * Calculate the ball position in the center of the game field.\r\n * @returns {number}. The ball's X or Y coordinate.\r\n */\r\nconst getBallPositionY = (): number => {\r\n    return gameDimensions.size / 1.5 - gameDimensions.size * BallResizeFactor / 2;\r\n};\r\n\r\n/**\r\n * Used to obtain a new state for the ball.\r\n * @returns {BallState}. A new ball state.\r\n */\r\nconst getNewState = (): BallState => {\r\n    const angle = 90 + angleRandomizer();\r\n    return {\r\n        angle,\r\n        color: \"radial-gradient(yellow, orange, brown)\",\r\n        height: getBallSize(),\r\n        width: getBallSize(),\r\n        left: getBallPositionX(),\r\n        top: getBallPositionY(),\r\n        velocity: InitialBallVelocity,\r\n        lastObject: {},\r\n    };\r\n};\r\n\r\nexport default ballReducer;","import produce from \"immer\";\r\nimport { MaxBlue, MaxGreen, MaxRed, MinBlue, MinGreen, MinRed } from \"../Constants/Constants\";\r\nimport Block from \"../Definitions/Block\";\r\nimport getGameDimensions from \"../GameDimensions\";\r\nimport { getBlocks } from \"../Lib\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport BlockState from \"../State/Definition/BlockState\";\r\nimport GameActions from \"../State/GameActions\";\r\n\r\n/**\r\n * The block reducer.\r\n * @param {BlockState} state. The current block state.\r\n * @param {ActionPayload} action. An action, payload optional.\r\n * @returns {BlockState}. A 'new' block state.\r\n */\r\nconst blockReducer = (state: BlockState = getNewState(), action: ActionPayload<Block>): BlockState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n            return getNewState();\r\n        case GameActions.nextLevel:\r\n\r\n            if (state.rows <= 10) {\r\n                // Increase the number of blocks until we hit 10 rows.\r\n                const nextLevelState = getNewState(state.rows + 1, state.columns + 1);\r\n                return nextLevelState;\r\n            } else {\r\n                return getNewState(state.rows, state.columns);\r\n            }\r\n\r\n        case GameActions.hitBlock:\r\n            return produce(state, (draftObject) => {\r\n                if (action.payload && action.payload) {\r\n                    const hitBlockIndex = state.blocks.indexOf(action.payload);\r\n                    draftObject.blocks[hitBlockIndex].hit = true;\r\n\r\n                    draftObject.blocks.forEach((block) => {\r\n\r\n                        if (block.red > MaxRed || block.red < MinRed) {\r\n                            block.redAdd *= -1;\r\n                        }\r\n\r\n                        if (block.green > MaxGreen || block.green < MinGreen) {\r\n                            block.greenAdd *= -1;\r\n                        }\r\n\r\n                        if (block.blue > MaxBlue || block.blue < MinBlue) {\r\n                            block.blueAdd *= -1;\r\n                        }\r\n\r\n                        block.red += block.redAdd;\r\n                        block.green += block.greenAdd;\r\n                        block.blue += block.blueAdd;\r\n                    });\r\n                }\r\n            });\r\n\r\n        case GameActions.tick:\r\n\r\n            return produce(state, (draftObject) => {\r\n                const hitBlocks = draftObject.blocks.filter((b) => b.hit === true);\r\n\r\n                if (hitBlocks.length > 0) {\r\n\r\n                    // Reduce a hit block by 10% of its original height\r\n                    const widthReductionFactor = calculateBlockWidth(draftObject.columns) * 0.1;\r\n                    const heightReductionFactor = calculateBlockHeight(draftObject.rows) * 0.1;\r\n\r\n                    // Redcue size for a hit block\r\n                    hitBlocks.forEach((block) => {\r\n                        block.width -= widthReductionFactor;\r\n                        block.height -= heightReductionFactor;\r\n\r\n                        // Add half of the mount of pixels to the top and left to make it appear as the block shrinks to its center.\r\n                        block.top += heightReductionFactor / 2;\r\n                        block.left += widthReductionFactor / 2;\r\n\r\n                        if (block.height <= 0 || block.width <= 0) {\r\n                            // Block has reached size '0', time to remove it.\r\n                            draftObject.blocks.splice(draftObject.blocks.indexOf(block), 1);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Gets a new state for the blocks.\r\n * @param {number} rows. The number of rows the new state should have.\r\n * @param {number} columns. The number of columns the new state should have. Also used to calculate the block size.\r\n * @returns {BlockState}. A new block state.\r\n */\r\nconst getNewState = (rows: number = 5, columns: number = 12): BlockState => {\r\n    const blocks = getBlocks(rows, columns);\r\n\r\n    const width = calculateBlockWidth(columns);\r\n    const height = calculateBlockHeight(columns);\r\n\r\n    blocks.forEach((b) => {\r\n        b.width = width;\r\n        b.height = height;\r\n        b.left = b.x * width;\r\n        b.top = b.y * height;\r\n    });\r\n\r\n    return {\r\n        blocks,\r\n        columns,\r\n        rows,\r\n        height,\r\n        width\r\n    };\r\n};\r\n\r\n/**\r\n * Calculates the height of a block using the screen size and the number of rows.\r\n * @param {number} rows. Amount of rows.\r\n * @returns {number}. The height of a block based on the amount of colums.\r\n */\r\nfunction calculateBlockHeight(columns: number): number {\r\n    // The simples way to draw rectangles is to half the width.\r\n    return calculateBlockWidth(columns) / 2;\r\n}\r\n\r\n/**\r\n * Calculats the width of a block using the screensize.\r\n * @param {number} columns. Amount of colums.\r\n * @returns {number}. The block width based on the amount of colums.\r\n */\r\nfunction calculateBlockWidth(columns: number): number {\r\n    const size = getGameDimensions().size;\r\n    return size / columns;\r\n}\r\n\r\nexport default blockReducer;","import produce from \"immer\";\r\nimport { Action } from \"redux\";\r\nimport GameState from \"../State/Definition/GameState\";\r\nimport GameActions from \"../State/GameActions\";\r\n\r\n/**\r\n * game state reducer. Keeps track of score, losing a game, etc.\r\n * @param {GameState} state. The current game state\r\n * @param {Action}. A reduc action. No payload.\r\n * @returns {GameState}. The next game state.\r\n */\r\nconst gameStateReducer = (state: GameState = getNewState(), action: Action<GameActions>): GameState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n            return getNewState();\r\n        case GameActions.gameLost:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.gameMode = \"ended\";\r\n            });\r\n        case GameActions.nextLevel:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.level += 1;\r\n            });\r\n        case GameActions.hitBlock:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.score += 1;\r\n            });\r\n        case GameActions.resume:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.gameMode = \"running\";\r\n            });\r\n        case GameActions.pause:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.gameMode = \"paused\";\r\n            });\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Creates a new GameState state\r\n * @returns {GameState}. A new game state.\r\n */\r\nconst getNewState = (): GameState => {\r\n    return { gameMode: \"paused\", level: 1, score: 0 };\r\n};\r\n\r\nexport default gameStateReducer;","\r\nimport produce from \"immer\";\r\nimport { PaddleColor, PaddleHeightFactor, PaddlePositionFactor, PaddleWithFactor } from \"../Constants/Constants\";\r\nimport getGameDimensions from \"../GameDimensions\";\r\nimport ActionPayload from \"../State/ActionPayLoad\";\r\nimport PaddleState from \"../State/Definition/PaddleState\";\r\nimport GameActions from \"../State/GameActions\";\r\n\r\nconst gameDimensions = getGameDimensions();\r\n\r\n/**\r\n * Handles paddle actions\r\n * @param {PaddleState} state. The paddle state.\r\n * @param {ActionPayload<number> }action. An action to be performed on the paddle. Number is the 'left' coordinate of the paddle.\r\n * @returns {PaddleState}. Paddle state.\r\n */\r\nconst paddleReducer = (state: PaddleState = getNewState(), action: ActionPayload<number>): PaddleState => {\r\n    switch (action.type) {\r\n        case GameActions.reset:\r\n\r\n            return getNewState();\r\n\r\n        case GameActions.paddleMove:\r\n\r\n            return produce(state, (draftObject) => {\r\n\r\n                // Prevent the paddle from being drawn outside the playfield.\r\n                if (typeof (action.payload) !== \"undefined\") {\r\n\r\n                    let x;\r\n\r\n                    if (action.payload - state.width / 2 <= 0) {\r\n                        x = 0;\r\n                    } else if (action.payload - state.width / 2 >= (gameDimensions.size - state.width)) {\r\n                        x = gameDimensions.size - state.width;\r\n                    } else {\r\n                        x = action.payload - (state.width / 2);\r\n                    }\r\n\r\n                    draftObject.left = x;\r\n                }\r\n            });\r\n\r\n        case GameActions.nextLevel:\r\n            return produce(state, (draftObject) => {\r\n\r\n                // Redude the paddle size each level by 5%\r\n                const newWidth = draftObject.width * 0.95;\r\n\r\n                if (newWidth < gameDimensions.size / PaddleHeightFactor / 2) {\r\n                    // Paddle doesn't get smaller than half its size.\r\n                    return state;\r\n                } else {\r\n                    draftObject.width = newWidth;\r\n                }\r\n            });\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n/**\r\n * Generates a new state for the paddle\r\n * @returns {PaddleState}. A new state for the paddle\r\n */\r\nconst getNewState = (): PaddleState => {\r\n    return {\r\n        color: PaddleColor,\r\n        width: gameDimensions.size / PaddleHeightFactor,\r\n        height: gameDimensions.size / PaddleWithFactor,\r\n        top: gameDimensions.size * PaddlePositionFactor,\r\n        left: (gameDimensions.size / 2) - (gameDimensions.size / PaddleHeightFactor / 2),\r\n        isPaddle: true\r\n    };\r\n};\r\n\r\nexport default paddleReducer;","import { Howl } from \"howler\";\r\nimport produce from \"immer\";\r\nimport { Action } from \"redux\";\r\nimport { Bounce, HitBlock } from \"../Constants/Base64Audio\";\r\nimport SoundState from \"../State/Definition/SoundState\";\r\nimport GameActions from \"../State/GameActions\";\r\n\r\n/**\r\n * Sound reducer. Handlers playing the sounds of the game when an action requires a sound.\r\n * @param {SoundState} state. The sound state. Never changes after initialization.\r\n * @param {GameActions} action. An action that requires a sound to be played.\r\n * @returns {SoundState}. The sound state.\r\n */\r\n\r\nconst soundReducer = (state: SoundState = getNewState(), action: Action): SoundState => {\r\n    switch (action.type) {\r\n        case GameActions.hitBlock:\r\n            if (state.sounds) {\r\n                state.hitBlock.play();\r\n            }\r\n\r\n            break;\r\n        case GameActions.ballBounceHorizantally:\r\n        case GameActions.ballBounceVertically:\r\n            if (state.sounds) {\r\n                state.bounce.play();\r\n            }\r\n\r\n            break;\r\n        case GameActions.toggleSound:\r\n            return produce(state, (draftObject) => {\r\n                draftObject.sounds = !draftObject.sounds;\r\n            });\r\n    }\r\n\r\n    return state;\r\n};\r\n\r\nconst getNewState = (): SoundState => {\r\n    const bounceSound = new Howl({ src: [\"data:audio/wav;base64,\" + Bounce] });\r\n    const hitBlockSound = new Howl({ src: [\"data:audio/wav;base64,\" + HitBlock] });\r\n\r\n    return {\r\n        bounce: bounceSound,\r\n        hitBlock: hitBlockSound,\r\n        sounds: true,\r\n    };\r\n};\r\n\r\nexport default soundReducer;","import { combineReducers, createStore, ReducersMapObject, Store } from \"redux\";\r\nimport ballReducer from \"../Reducers/BallReducer\";\r\nimport blockReducer from \"../Reducers/BlockReducer\";\r\nimport gameStateReducer from \"../Reducers/GameStateReducer\";\r\nimport paddleReducer from \"../Reducers/PaddleReducer\";\r\nimport soundReducer from \"../Reducers/SoundReducer\";\r\nimport ActionPayload from \"./ActionPayLoad\";\r\nimport AppState from \"./Definition/AppState\";\r\n\r\n/**\r\n * All reducer that build the application state.\r\n */\r\nconst reducers: ReducersMapObject<AppState, ActionPayload<any>> = {\r\n    blockState: blockReducer,\r\n    paddle: paddleReducer,\r\n    ball: ballReducer,\r\n    gameState: gameStateReducer,\r\n    soundState: soundReducer,\r\n};\r\n\r\nconst allReducers = combineReducers(reducers);\r\n\r\nconst store = createStore<AppState, ActionPayload<any>, AppState, AppState>(allReducers);\r\n\r\n/**\r\n * Returns the store\r\n * @returns {Store}. The redux store.\r\n */\r\nexport const appStore = (): Store<AppState, ActionPayload<any>> => {\r\n    return store;\r\n};\r\n\r\n/**\r\n * Returns the State\r\n * @returns {AppState}. The application state.\r\n */\r\nexport const appState = (): AppState => {\r\n    return appStore().getState();\r\n};","import produce from \"immer\";\nimport React, { CSSProperties } from \"react\";\nimport { GameFieldBorderColor, GameTick } from \"./Constants/Constants\";\nimport Walls from \"./Constants/WallConstants\";\nimport Block from \"./Definitions/Block\";\nimport GameObject from \"./Definitions/GameObject\";\nimport getGameDimensions from \"./GameDimensions\";\nimport { getBounceAction, overlaps } from \"./Lib\";\nimport AppState from \"./State/Definition/AppState\";\nimport BallState from \"./State/Definition/BallState\";\nimport GameActions from \"./State/GameActions\";\nimport { appState, appStore } from \"./State/Store\";\n\nconst gameDimensions = getGameDimensions();\n\n/**\n * Main game component.\n */\nexport class Main extends React.Component<{}, AppState> {\n\n    /**\n     * Stores a reference to the animation that draws the game.\n     */\n    private tickHandler?: number;\n\n    /**\n     * Used to store the beginning of a game tick.\n     */\n    private tickStart?: number;\n\n    /**\n     * Refux subscription\n     */\n    private subscription?: () => void;\n\n    /**\n     * Initializes the Main component.\n     */\n    constructor(props: object) {\n        super(props);\n\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.onMouseClick = this.onMouseClick.bind(this);\n        this.tick = this.tick.bind(this);\n        this.onPlayAgain = this.onPlayAgain.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n\n        // Sync the redux state with the component state.\n        this.state = appState();\n    }\n\n    /**\n     * Called when the component mounted.\n     */\n    public componentDidMount(): void {\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n\n        window.addEventListener(\"mousemove\", this.onMouseMove);\n        window.addEventListener(\"click\", this.onMouseClick);\n        window.addEventListener(\"keyup\", this.onKeyUp);\n\n        this.subscription = appStore().subscribe(() => {\n            const applicationState = appState();\n\n            if (applicationState.gameState !== this.state.gameState) {\n                this.setState({ gameState: applicationState.gameState });\n\n                if (applicationState.gameState.gameMode === \"ended\") {\n                    if (this.tickHandler) {\n                        window.cancelAnimationFrame(this.tickHandler);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Called before the component unmounts.\n     */\n    public componentWillUnmount(): void {\n        if (this.tickHandler) {\n            window.cancelAnimationFrame(this.tickHandler);\n        }\n\n        window.removeEventListener(\"mousemove\", this.onMouseMove);\n        window.removeEventListener(\"click\", this.onMouseClick);\n\n        if (this.subscription) {\n            this.subscription();\n            delete this.subscription;\n        }\n    }\n\n    private onKeyUp(e: KeyboardEvent): void {\n        if (this.state.gameState.gameMode === \"running\") {\n            switch (e.code) {\n                case \"Space\":\n                    appStore().dispatch({ type: GameActions.pause });\n                    return;\n                case \"KeyW\":\n                    appStore().dispatch({ type: GameActions.nextLevel });\n                    return;\n            }\n        }\n\n        if (e.code === \"KeyS\") {\n            appStore().dispatch({ type: GameActions.toggleSound });\n        }\n    }\n\n    /**\n     * Handles mouse movement. Used to move the paddle.\n     * @param {MouseEvent} e. MouseEvent.\n     */\n    private onMouseMove(e: MouseEvent): void {\n        if (e) {\n            const x = e.clientX - gameDimensions.left;\n            appStore().dispatch({ type: GameActions.paddleMove, payload: x });\n        }\n    }\n\n    /**\n     * Event fires when the user clicks the mouse.\n     */\n    private onMouseClick(): void {\n        if (this.state.gameState.gameMode === \"paused\") {\n            appStore().dispatch({ type: GameActions.resume });\n            this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n        }\n    }\n\n    /**\n     * Handles a play again click.\n     */\n    private onPlayAgain(): void {\n        // Reset game state.\n        appStore().dispatch({ type: GameActions.reset });\n        this.tickHandler = this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Handles a game tick.\n     * @param {number} tick. Current tick count.\n     */\n    public tick(tick: number): void {\n\n        if (!this.tickStart) {\n            this.tickStart = tick;\n        }\n\n        if (this.state.gameState.gameMode !== \"running\") {\n            return;\n        }\n\n        const diff = tick - this.tickStart;\n\n        // Redraw at 60 fps.\n        if (diff > GameTick) {\n            const ball = appState().ball;\n            const blocks = appState().blockState.blocks;\n            const paddle = appState().paddle;\n\n            if (blocks.length === 0) {\n                appStore().dispatch({ type: GameActions.nextLevel });\n            }\n\n            const paddleHit = overlaps(ball, paddle);\n\n            if (paddleHit) {\n                const paddleBounceAction = getBounceAction(ball, paddle);\n                appStore().dispatch({ type: paddleBounceAction, payload: paddle  });\n\n            } else if (blocks) {\n\n                const hitBlock = blocks.find((b) => overlaps(ball, b) && b.hit === false);\n                if (hitBlock) {\n                    appStore().dispatch({ type: GameActions.hitBlock, payload: hitBlock});\n\n                    const action = getBounceAction(ball, hitBlock);\n\n                    if (typeof (action) !== \"undefined\") {\n                        appStore().dispatch({ type: action, payload: hitBlock });\n                    }\n\n                } else if (ball.top <= 0) {\n                    // The ball's top and left are inside the game field.\n                    // Use the game dimension object to store a wall hit.\n                    // Hit the top  wall\n                    appStore().dispatch({ type: GameActions.ballBounceHorizantally, payload:  Walls.topWall  });\n\n                } else if (ball.left <= 0) {\n                    // Hit the left wall\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload:  Walls.leftWall  });\n                } else if (ball.left + ball.width >= gameDimensions.size) {\n                    // Hit the right wall\n\n                    appStore().dispatch({ type: GameActions.ballBounceVertically, payload:  Walls.rightWall  });\n                } else if (ball.top + ball.width >= gameDimensions.size) {\n                    // Hit bottom wall.\n                    appStore().dispatch({ type: GameActions.gameLost });\n                }\n            }\n\n            appStore().dispatch({ type: GameActions.tick, action: { ticks: diff } });\n\n            const newComponentState = produce(this.state, (draftObject) => {\n                draftObject.ball = appState().ball;\n                draftObject.blockState = appState().blockState;\n                draftObject.gameState = appState().gameState;\n                draftObject.paddle = appState().paddle;\n                draftObject.soundState = appState().soundState;\n            });\n\n            this.setState(newComponentState);\n\n            this.tickStart = tick;\n        }\n\n        this.tickHandler = window.requestAnimationFrame(this.tick);\n    }\n\n    /**\n     * Returns the styling for the game field.\n     * @returns {CSSProperties}. CSSProperties for the gamefield.\n     */\n    private gameFieldStyle(): CSSProperties | undefined {\n\n        return {\n            position: \"absolute\",\n            left: getGameDimensions().left,\n            top: getGameDimensions().top,\n            width: getGameDimensions().size,\n            height: getGameDimensions().size,\n            borderColor: GameFieldBorderColor,\n            borderStyle: \"solid\",\n            display: \"flex\",\n            justifyContent: \"center\"\n        };\n    }\n\n    /**\n     * Game score style\n     * @returns {CSSProperties}. A style that will draw a rectangle above the game field.\n     */\n    private gameScorebarStyle(): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: getGameDimensions().left,\n            width: getGameDimensions().size,\n            top: getGameDimensions().top - 25,\n            height: 22,\n            borderColor: GameFieldBorderColor,\n            borderStyle: \"solid\",\n            display: \"flex\",\n            flexDirection: \"row\",\n        };\n    }\n\n    /**\n     * Returns css properties for positioning a shape.\n     * @param {ScreenObject} shape. A shape object.\n     * @returns {CSSProperties}. CSS properties for a shape.\n     */\n    private positionStyle(shape: GameObject): CSSProperties {\n        return {\n            position: \"absolute\",\n            left: shape.left,\n            top: shape.top,\n            height: shape.height,\n            width: shape.width,\n            backgroundColor: shape.color,\n        };\n    }\n\n    private blockStyle(block: Block): CSSProperties {\n        const css = this.positionStyle(block);\n        css.backgroundColor = `rgba(${block.red}, ${block.green}, ${block.blue}, 1`;\n        return css;\n    }\n\n    /**\n     * Returns css properties for positioning and drawing the ball.\n     * @param {BallState} ball.\n     * @returns {CSSProperties}.\n     */\n    private ballStyle(ball: BallState): CSSProperties {\n        const newPosition = this.positionStyle(ball);\n        newPosition.borderRadius = \"50%\";\n        newPosition.backgroundImage = ball.color;\n        return newPosition;\n    }\n\n    /**\n     * Renders the component.\n     */\n    public render(): React.ReactNode {\n        return (\n            <div>\n                <div style={this.gameScorebarStyle()} >\n                    <div style={{ width: \"10%\", color: \"white\", marginTop: \"3px\", marginLeft: \"10px\" }}>Level: {this.state.gameState.level}</div>>\n                    <div style={{ width: \"10%\", color: \"white\", marginTop: \"3px\", }}>Score: {this.state.gameState.score}</div>>\n                    <div style={{ width: \"80%\", color: \"white\", marginRight: \"10px\", marginTop: \"3px\", textAlign: \"right\" }}>Press S to turn sound {this.state.soundState.sounds ? \"off\" : \"on\"}</div>\n                </div>\n                <>\n                    {\n                        this.state.blockState && this.state.paddle && this.state.ball ?\n                            <div style={this.gameFieldStyle()}>\n                                {\n                                    this.state.blockState.blocks.map((b, index) => <div key={index} style={this.blockStyle(b)} />)\n                                }\n                                <div style={this.positionStyle(this.state.paddle)} />\n                                <div style={this.ballStyle(this.state.ball)} />\n                                {\n                                    this.state.gameState.gameMode === \"ended\" ?\n                                        <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"center\" }}>\n                                            <p style={{ alignSelf: \"center\", color: \"white\" }}>Game over</p>\n                                            <button onClick={this.onPlayAgain} style={{ alignSelf: \"center\" }}>Play again</button>\n                                        </div> :\n                                        this.state.gameState.gameMode === \"paused\" ?\n                                            <div style={{ display: \"flex\", flexDirection: \"column\", justifyContent: \"center\" }}>\n                                                <p style={{ alignSelf: \"center\", color: \"white\" }}>Click the left mouse button to resume.</p>\n                                            </div> : null\n                                }\n\n                            </div> : null\n                    }\n                </>\n            </div>\n        );\n    }\n}\n\nexport default Main;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Main from \"./Main\";\n\nReactDOM.render(<Main />, document.getElementById(\"root\"));\n"],"sourceRoot":""}